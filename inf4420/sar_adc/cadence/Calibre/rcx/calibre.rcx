// xCalibre/calibre  RC/LVS command file based on the follow calibre command file//
/////////////////////////////////////////////////////////////////////////////////
// 
//  @(#) TSMC 90nm CALIBRE LVS/RC COMMAND FILE  
//  @(#) TSMC 90 NM CMOS LOGIC/MMRF GENERAL PURPOSE DEVICE FORMATION EXAMPLES AND LVS PROPERTIES  
//  @(#) DEVICE FORMATION EXAMPLE AND LVS PROPERTIES DOCUMENT: T-N90-CL-LS-001 V2.0  
//  @(#) COMMAND FILE DOCUMENT : T-N90-CL-LS-001-C1 
//  @(#) COMMAND FILE VERSION : V2.0c 
//  @(#) COMMAND FILE METAL SCHEME : 1P9M 
//  @(#) COMMAND FILE DATE : 06/14/2010 
//  @(#) EDA TOOL VERSION:  Calibre 2007.3_36.25 (Nov.2007) ; StarXtract 2009.06 
//  @(#) SPICE MODEL CARD: 90NM LOGIC HIGH PERFORMANCE 1p9m SALICIDE 1.2v/2.5v CU_LOW K (CLN90GT) 
//  @(#) DOCUMENT NUMBER: T-N90-CL-SP-013 v1.3 2006/08/07 
//  @(#) SPICE MODEL CARD: 90NM LOGIC HIGH PERFORMANCE 1p9m SALICIDE 1.2v/1.8v CU_LOW K (CLN90GT) 
//  @(#) DOCUMENT NUMBER: T-N90-CL-SP-028 v1.2 2006/08/07 
//  @(#) SPICE MODEL CARD: 90NM LOGIC LOW POWER 1p9m+ALRDL SALICIDE 1.2v/2.5v CU_LOW K (CLN90LP) 
//  @(#) DOCUMENT NUMBER: T-N90-LO-SP-008 v2.2 2008/09/16 
//  @(#) SPICE MODEL CARD: 90NM LOGIC LOW POWER 1p9m+ALRDL SALICIDE 1.2v/3.3v CU_LOW K (CLN90LP) 
//  @(#) DOCUMENT NUMBER: T-N90-LO-SP-009 v2.3 2009/02/11 
//  @(#) SPICE MODEL CARD: 90NM LOGIC LOW POWER 1p9m SALICIDE 1.2v CU_LOW K (CLN90LP ULTRA HIGH VT) 
//  @(#) DOCUMENT NUMBER: T-N90-CL-SP-027 v1.1 2006/06/02   
//  @(#) SPICE MODEL CARD: 90NM LOGIC GENERAL PURPOSE 1p9m+ALRDL SALICIDE 1.0v/1.8v CU_LOW K (CLN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-LO-SP-001 v1.5 2006/08/07 
//  @(#) SPICE MODEL CARD: 90NM LOGIC GENERAL PURPOSE 1p9m+ALRDL SALICIDE 1.0v/2.5v CU_LOW K (CLN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-LO-SP-002 v2.0 2008/12/15 
//  @(#) SPICE MODEL CARD: 90NM LOGIC GENERAL PURPOSE 1p9m+ALRDL SALICIDE 1.0v/3.3v CU_LOW K (CLN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-LO-SP-003 v2.1 2009/02/09 
//  @(#) SPICE MODEL CARD: 90nm MIX-SIGNAL SALICIDE (1P9M+AL_RDL, 1.2V/2.5V) (CMN90LP) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-001 v2.0 2008/10/03 
//  @(#) SPICE MODEL CARD: 90nm MIX-SIGNAL SALICIDE (1P9M+AL_RDL, 1.2V/3.3V) (CMN90LP) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-003 v2.0 2008/10/03 
//  @(#) SPICE MODEL CARD: 90NM CMOS MIXED SIGNAL HIGH PERFORMANCE 1p9m+ALRDL SALICIDE 1.2v/2.5v CU_LOW K (CMN90GT) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-007 v1.1 2006/11/08 
//  @(#) SPICE MODEL CARD: 90NM CMOS MIXED SIGNAL HIGH PERFORMANCE 1p9m_ALRDL SALICIDE 1.2v/1.8v CU_LOW K (CMN90GT) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-021 v1.0 2006/11/08 
//  @(#) SPICE MODEL CARD: 90NM CMOS MIXED SIGNAL GENERAL PURPOSE 1p9m+ALRDL SALICIDE 1.0v/1.8v/3.3v CU_LOW K (CMN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-011 v1.2 2006/11/08 
//  @(#) SPICE MODEL CARD: 90nm MIX-SIGNAL SALICIDE (1P9M+AL_RDL, 1.0V/2.5V) (CMN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-012 v2.0 2008/09/01 
//  @(#) SPICE MODEL CARD: 90NM CMOS eDRAM LOGIC 1p9m SALICIDE 1.2v/2.5v CU_LOW K (CLN90GT) 
//  @(#) DOCUMENT NUMBER: T-N90-CE-SP-001 v1.1 2007/07/07 
//  @(#) SPICE MODEL CARD: 90NM CMOS MIXED SIGNAL RF LOW POWER 1p9m SALICIDE 1.2v/2.5v CU_LOW K (CRN90LP) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-004 v1.2 2008/11/30 
//  @(#) SPICE MODEL CARD: 90NM CMOS MIXED SIGNAL RF LOW POWER 1p9m SALICIDE 1.2v/3.3v CU_LOW K (CRN90LP) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-005 v1.2 2008/11/30 
//  @(#) SPICE MODEL CARD: 90NM CMOS MIXED SIGNAL RF GENERAL PURPOSE 1p9m SALICIDE 1.2v/2.5v CU_LOW K (CRN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-013 v1.1 2008/11/30 
//  @(#) SPICE MODEL CARD: 90NM CMOS MIXED SIGNAL RF GENERAL PURPOSE 1p9m SALICIDE 1.2v/3.3v CU_LOW K (CRN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-016 v1.1 2008/11/30 
//  @(#) SPICE MODEL CARD: 90NM CMOS LOGIC SALICIDE 1P9M+RDL 3.3V SPICE MODELS (PHASE-IN USING 2.5V PROCESS) 
//  @(#) DOCUMENT NUMBER: T-N90-CL-SP-029 v1.1 2006/08/23 
//  @(#) SPICE MODEL CARD: 90NM CMOS LOGIC LOW POWER 1P9M+RDL SALICIDE CU_LOW K 2.5V AND OVERDRIVED TO 3.3V SPICE MODELS (PHASE-IN) 
//  @(#) DOCUMENT NUMBER: T-N90-CL-SP-033 v1.1 2006/03/14   
//  @(#) SPICE MODEL CARD: 90nm MIX-SIGNAL SALICIDE (1P9M+AL_RDL, 1.0V/3.3V) (CMN90G) 
//  @(#) DOCUMENT NUMBER: T-N90-CM-SP-025 v2.0 2008/09/08 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
// DISCLAIMER 
// 
// This file usually contains the super set of device extraction rule at TSMC
// processes. However, all of device in basic deck may not be offered at current
// SPICE model. PLEASE ALWAYS REFER TO THE CORRESPONDING SPICE MODEL DOCUMENT
// FOR ANY DEVICE YOU WOULD LIKE USE.
// 
// The information contained herein is provided by TSMC on an "AS IS" basis 
// without any warranty, and TSMC has no obligation to support or otherwise 
// maintain the information.  TSMC disclaims any representation that the 
// information does not infringe any intellectual property rights or proprietary 
// rights of any third parties.  There are no other warranties given by TSMC, 
// whether express, implied or statutory, including, without limitation, implied 
// warranties of merchantability and fitness for a particular purpose. 
// 
// STATEMENT OF USE 
// 
// This information contains confidential and proprietary information of TSMC. 
// No part of this information may be reproduced, transmitted, transcribed, 
// stored in a retrieval system, or translated into any human or computer 
// language, in any form or by any means, electronic, mechanical, magnetic, 
// optical, chemical, manual, or otherwise, without the prior written permission 
// of TSMC.  This information was prepared for informational purpose and is for 
// use by TSMC's customers only.  TSMC reserves the right to make changes in the 
// information at any time and without notice. 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
//                           CHANGE HISTORY 
//  
//   Date     version   Who                      Description 
// ---------- ------- --------- ------------------------------------------------- 
//  Version Change Notice: 
//  
// 06/10/2004  V1.1a  C.S.Yang -   New Created  
//  
// 12/08/2004  V1.2a  C.S.Yang -   1) Add 1.0V/1.2V NPN BJT device. 
//	                         2) Add two optional diode : pwdnw, dnwpsub 
//	                         3) Change subtype name of ESD diode to ndio_esd 
//	                         4) Modify the connection of PNP collector 
//	                         5) PO and OD without CO will not be considered for LVS recognition when 
//	                            the switch "RC_DECK" is off. 
//	                         6) Modify the definition and connection of PNP collector due to soft  
//	                            connect issue. 
//	                         7) Modify the connection of dnwpsub diode due to soft connect issue. 
//	                         8) Modify the terminal of dnwpsub due to the case "nwell inside nwell ring". 
//	                         9) Add a layer (17;51) to recognize low Vt device in LP process. 
// 
// 01/04/2005  V1.3a  K.M.Liu      1) Added 1T_MIM devices ( official devices: nch_w, pch_w, pch_1tr, ndio_w and pdio_w		 
//                                                           internal devices: nch_dnw_w and cm capacitor) 
//                                 2) Added POWER_NAME and GROUND_NAME variables. 
//				 3) Added ERC floating gate check. 
//				 4) Added ERC gate connect to POWER or GROUND check 
//				 5) Revised the LOD processing layer from nthin1 to OD and from pthin to OD. 
//				 6) Added "TACVDD" into POWER  
//				 7) Revised the moscap property formula to meet the DRM. 
//				 8) Added "NWDMY1" layer for 3-terminals nwell resistor under OD 
//				 9) Added "RPDMY1" layer for 3-terminals P+/N+ OD resistors. 
//				10) Added rnwod_m,rpodl_m,rpods_m,rpodwo_m,rnodl_m,rnods_m and rnodwo_m devices 
//				    which are 3-terminals resistors. 
//				11) Added switch "MODEL_NAME" to control the layout netlist device names 
//				    which are following the spice model. The default is turn off.    
//06/22/2005  V1.3b  S.L.Hwong    1) Revised the logic operation to form gate1 derived layer.  
//                                2) Revised the logic operation to form nplug, pplug.  
//	         		3) Revised the logic operation to form bjt PV.  
//				4) Revised the logic operation to form psub without psub separation band, psubband. 
// 
//12/12/2005  V1.3c  Y.T.Pu       1) Revised the logic operation to form nplug, pplug. 
//                                   Add the layers of tpdiffco and tndiffco, for forming the nplug, pplug.  
//				2) Added rppolyl_dis,rnpolyl_dis,rppolys_dis,rnpolys_dis,rppolywo_dis,rnpolywo_dis 
//				   and rnwsti_m, which are 3T resistors. 
//				3) Updated the device of CM of 1T_MIM Cap, which cannot interact with RPO layer. 
//				4) Updated the poly_term definition, which is for 3T poly resistor only. 
//				    				     
//03/15/2006 V1.4a Y.T.Pu     1) Cancel the "CONNECT M1 CO" and "CONNECT poly CO in this deck.  
//                                 Re-define the M1X = M1a OR DUM1.  
//                                   
//10/30/2006  v1.4b  James Kuo	1) Add Cu_RDL option  
// 				2) Update the definition of layer poly.  
// 				3) Update spice model names of metal resistors  
// 				   as following.    
// 				     
// 					rm1s 	=> rm1w  
// 					rm2_7s	=> rm2_7w  
// 					rm8_9s	=> rm8_9w  
// 					rm10s	=> rm10w  
//(					UTM top metal resistor => rmt  )					 
// 									  
//				4) Add CCI option.   
//				5) Update the definition of n_psub.  
//				6) Add device crtmom, mimcap_2p0_sin, mimcap_2p0_sin_3t,  
//						mimcap_1p5_sin, mimcap_1p5_sin_3t  
//						mimcap_1p0_sin, mimcap_1p0_sin_3t  
//11/29/2006 			7) Update recognition layer of 1T-mim capacitor						  
// 				  
//12/15/2006  V1.5a  Y.J.Wang    1).Based on spice model T-N90-CL-SP-013 V1.3, T-N90-LO-SP-009 V1.3,  
//                                  WPE use BSIM 4.5.  
//			       2). Adding mimcap and mimcap_3t   
//			                  (mimcap_2p0_sin and mimcap_2p0_sin_3t turn off CAP switches;  
//					   mimcap_1p5_sin and mimcap_1p5_sin_3t turn on CAP_1P5 switch;  
//					   mimcap_1p0_sin and mimcap_1p0_sin_3t turn on CAP_1P0 switch.)  
//			       3). Adding crtmom (baseband).  
//  
//01/12/2007		       4). Adding mac devices description for turn-on switch WPE.  
//			       5). Native devices will not extract WPE params.  
//  
//(02/05/2007  v1.1d  Y.J.Wang   1).Modified the soft-connection check for dnw layer.    ) 
//(                              2).Adding CBD for VIA_top to connect RDL and Metal_top. ) 
// 
//03/13/2007  V1.5c  Y.J.Wang    1). Modified the typo missing word "ELSE". 
//                               2). Adding CCI deck in. 
//                               3). Adding 5LM deck for top metal= metal5 scheme. 
// 
//05/10/2007  V1.5d_pre1 Y.J.Wang     1). Adding 1p4m calibre/cci deck for IO team. 
//                                    2). Take off switch named "Without_RDL".		 
// 
//11/22/2007  V1.5d  Y.J.Wang    1). Updating of Hercules ERC rule of floating wells. 
//			       2). Modified RODMY with adding SRM. 
//			       3). Updating n_pplug formation. 
//			       4). Updating WPE boundary for PMOS (Core/IO). 
//			       5). Adding ULVT and UHVT devices. 
//				     
//04/11/2008  V1.5e Y.J.Wang     1). Update ulvt and uthvt devices for logic model updated. 
//                               2). Modified psub_term formation, p+od resistor formation, and adding some resistor internal parameters. 
//			       3). Adding new switch "FILTER_DGS_TIED_MOS". 
//			       4). Update DFM macros.				     
// 
//12/22/2008        Y.J.Wang     1). Adding new devices ULP SRAM. 
// 			       2). Modifying ULVT devices: adding LVID layer in LP process (turn-on LP switch). 
//			       3). Modifying decap (CM) connection and formation, not compared capacitance. 
//			       4). Modified pwdnw formation and NPN device will not extract pwdnw device when turn-on "extract_dnwdio" switch. 
//			       5). Revised metal/poly/od resistors for not include DUMMY DUM/DPO/DOD for resistor formation. 
// 
//12/24/2008  V2.0a Y.J.Wang     1). Based on WPE effect use BSIM4v5 model in CRN90G/LP spice model v1.2, we can integrate 90nm all process. 
//			       2). Because 90nm DRM allow stacking devices under RF w/i shield mimcap and 2T baseband mimcap, 
//			           we adds new mimcap-um_sin_rf and mimcap_sin with new DUMMY layer :  
//				   RFDMY(drawing1)=(161;10) and CTMDMY(drawing1)=(148;10). 
//			       3). Enhance RTMOM devices for adding new parameter busflag for different LBUS width. 
// 			       4). Adding ERC switch for each ERC rules, some are default turn-off, and use it by customer decision. 
//			       5). Change WPE model of Core,IO MOS(not include SRM) from BSIM4.4 to BSIM4.5,  
//			           sc will seperate into sca,scb, and scc. 
//			       6). Change hcell to be xcell and put all RF pcells in deck to fit new cell-blocking format. 
//			       7). The wpe params : sca/scb/scc of RF MOS only support GUI mode (only for calibre view and assura extractview). 
//			       8). Remove floating gate checking in ERC section, because DRM has rule PO.R.8 to define it. 
//			       9). Adding new RF devices schottky barrier diode sbd_rf and sbd_rf_nw. 
// 
//07/02/2009  V2.0b Y.R.Xie      1). Rename 2.5v over-drived devices from 33 to 25od, based two phase-in model cards.			        
//			       2). Update ERC rules check of mnpg/mppg to include all core/IO MOS(exclude SRAM and RF MOS). 
//                               3). Add crtmom to cell blocking 
//                               4). Revise the logic operation of gate 
// 
//04/16/2010  V2.0c_pre042310  
//                  Y.R.Xie      1). Revise mim_block connection 
//                               2). Add SRAM to gate shielding 
//                               3). Revise CCI moscap gate shielding  
// 
//06/14/2010  V2.0c Y.R.Xie      1). Update the title 
// 
//////////////////////////////////////////////////////////////////////////////// 
// 
//                             DEVICE FORMULA 
//	 CORE == 1.0v or 1.2v  
//	 I/O  == 2.5v or 3.3v or 1.8v 
//   ----- ----------------------------- ---------------------------------- 
//   NAME     DESCRIPTION                   DEVICE LAYER OPERATION 
//   ----- ----------------------------- ---------------------------------- 
// 
// 
//   M[nch]          CORE Standard VT NMOS         ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-VTL_N-UHVT_N-ULVT_N)-DNW-SRM-OD1T-POS)  
//   M[nch_dnw]      CORE Standard VT NMOS/DNW     ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-VTL_N-UHVT_N-ULVT_N)*DNW-SRM-OD1T-POS)  
//   M[nch_hvt]      CORE High     VT NMOS         ((NGATE-OD25-OD18-OD33-NT_N*VTH_N-VTL_N-UHVT_N-ULVT_N)-DNW-SRM-OD1T-POS) 
//   M[nch_lvt]      CORE Low      VT NMOS         ((NGATE-OD25-OD18-OD33-NT_N-VTH_N*VTL_N-UHVT_N-ULVT_N)-DNW-SRM-OD1T-POS) 
//   M[nch_uthvt]    CORE Ultra-High VT NMOS       ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-VTL_N*UHVT_N-ULVT_N)-DNW-SRM-OD1T-POS) 
//   M[nch_ulvt]     CORE G  Ultra-Low  VT NMOS    ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-UHVT_N*ULVT_N)-DNW-SRM-OD1T-POS) 
//   M[nch_ulvt]     CORE LP Ultra-Low  VT NMOS    ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-UHVT_N*ULVT_N*VTL_N)-DNW-SRM-OD1T-POS) 
//   M[nch_hvt_dnw]  CORE High     VT NMOS/DNW     ((NGATE-OD25-OD18-OD33-NT_N*VTH_N-VTL_N-UHVT_N-ULVT_N)*DNW-SRM-OD1T-POS) 
//   M[nch_lvt_dnw]  CORE Low      VT NMOS/DNW     ((NGATE-OD25-OD18-OD33-NT_N-VTH_N*VTL_N-UHVT_N-ULVT_N)*DNW-SRM-OD1T-POS) 
//   M[nch_uthvt_dnw] CORE Ultra-High VT NMOS/DNW  ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-VTL_N*UHVT_N-ULVT_N)*DNW-SRM-OD1T)-POS 
//   M[nch_ulvt_dnw] CORE G  Ultra-Low  VT NMOS    ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-UHVT_N*ULVT_N)*DNW-SRM-OD1T-POS) 
//   M[nch_ulvt_dnw] CORE LP Ultra-Low  VT NMOS    ((NGATE-OD25-OD18-OD33-NT_N-VTH_N-UHVT_N*ULVT_N*VTL_N)*DNW-SRM-OD1T-POS) 
// 
//   M[nch_18]       I/O 1.8V Std VT NMOS          ((NGATE*OD18-OD25-OD33-NT_N)-DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)  
//   M[nch_25]       I/O 2.5V Std VT NMOS          ((NGATE-OD18*OD25-OD33-NT_N)-OVD-DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)  
//   M[nch_25od]     I/O 2.5V Std VT OvdrvNMOS     ((NGATE-OD18*OD25-OD33-NT_N)*OVD-DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)   
//   M[nch_33]       I/O 3.3V Std VT NMOS          ((NGATE-OD18-OD25*OD33-NT_N)-DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T-CELLM) 
//   M[nch_18_dnw]   I/O 1.8V Std VT NMOS/DNW      ((NGATE*OD18-OD25-OD33-NT_N)*DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)  
//   M[nch_25_dnw]   I/O 2.5V Std VT NMOS/DNW      ((NGATE-OD18*OD25-OD33-NT_N)-OVD*DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)  
//   M[nch_25od_dnw] I/O 2.5V Std VT OvdrvNMOS/DNW ((NGATE-OD18*OD25-OD33-NT_N)*OVD*DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T) 
//   M[nch_33_dnw]   I/O 3.3V Std VT NMOS/DNW      ((NGATE-OD18-OD25*OD33-NT_N)*DNW-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T-CELLM) 
// 
//   M[nch_na]       CORE native device            ((NGATE-OD25-OD18-OD33)*NT_N-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)  
//   M[nch_na18]     I/O 1.8V native device        ((NGATE*OD18-OD23-OD33)*NT_N-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)   
//   M[nch_na25]     I/O 2.5V native device        ((NGATE*OD25-OD33-OD18)*NT_N-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)   
//   M[nch_na33]     I/O 3.3V native device        ((NGATE*OD33-OD25-OD18)*NT_N-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM-OD1T)   
//    
//   M[nch_w]        1T_MIM NMOS                   ((NGATE-OD25-OD18-OD33-NT_N)-DNW*OD1T-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM)  
//   M[nch_dnw_w]    1T_MIM NMOS/DNW               ((NGATE-OD25-OD18-OD33-NT_N)*DNW*OD1T-VTH_N-VTL_N-UHVT_N-ULVT_N-SRM)  
//   M[nchpg_sr]     SRAM passgate NMOS            ((NGATE-OD25-OD18-OD33-NT_N)*SRM*SRAMPSGT-VTH_N-VTL_N-UHVT_N-ULVT_N-OD1T)  
//   M[nchpd_sr]     SRAM pulldown NMOS            ((NGATE-OD25-OD18-OD33-NT_N)*SRM-SRAMPSGT-VTH_N-VTL_N-UHVT_N-ULVT_N-OD1T) 
//   M[nchpg_hvtsr]  SRAM High VT passgate NMOS    ((NGATE-OD25-OD18-OD33-NT_N)*SRM*SRAMPSGT*VTH_N-SRAMULP-VTL_N-UHVT_N-ULVT_N-OD1T)  
//   M[nchpd_hvtsr]  SRAM High VT pulldown NMOS    ((NGATE-OD25-OD18-OD33-NT_N)*SRM-SRAMPSGT*VTH_N-SRAMULP-VTL_N-UHVT_N-ULVT_N-OD1T) 
//   M[nchpg_ulpsr]  SRAM ULP High VT passgate NMOS ((NGATE-OD25-OD18-OD33-NT_N)*SRM*SRAMPSGT*VTH_N*SRAMULP-VTL_N-UHVT_N-ULVT_N-OD1T)  
//   M[nchpd_ulpsr]  SRAM ULP High VT pulldown NMOS ((NGATE-OD25-OD18-OD33-NT_N)*SRM-SRAMPSGT*VTH_N*SRAMULP-VTL_N-UHVT_N-ULVT_N-OD1T) 
//    
//   M[pch]          CORE Standard VT PMOS         ((PGATE-OD18-OD25-OD33)-VTH_P-VTL_P-UHVT_P-ULVT_P-SRM-OD1T-POS)  
//   M[pch_hvt]      CORE High     VT PMOS         ((PGATE-OD18-OD25-OD33)*VTH_P-VTL_P-UHVT_P-ULVT_P-SRM-OD1T-POS)  
//   M[pch_lvt]      CORE Low      VT PMOS         ((PGATE-OD18-OD25-OD33)-VTH_P*VTL_P-UHVT_P-ULVT_P-SRM-OD1T-POS) 
//   M[pch_uthvt]    CORE Ultra-High VT PMOS       ((PGATE-OD18-OD25-OD33)-VTH_P-VTL_P*UHVT_P-ULVT_P-SRM-OD1T-POS) 
//   M[pch_ulvt]     CORE G  Ultra-Low  VT PMOS    ((PGATE-OD18-OD25-OD33)-VTH_P-UHVT_P*ULVT_P-SRM-OD1T-POS) 
//   M[pch_ulvt]     CORE LP Ultra-Low  VT PMOS    ((PGATE-OD18-OD25-OD33)-VTH_P-UHVT_P*ULVT_P*VTL_P-SRM-OD1-POST-POS) 
//   M[pch_18]       I/O 1.8V Std VT PMOS          ((PGATE*OD18-OD25-OD33)-VTH_P-VTL_P-UHVT_P-ULVT_P-SRM-OD1T)  
//   M[pch_25]       I/O 2.5V Std VT PMOS          ((PGATE-OD18*OD25-OD33-OVD)-VTH_P-VTL_P-UHVT_P-ULVT_P-SRM-OD1T) 
//   M[pch_25od]     I/O 2.5V Std VT Ovdrv PMOS    ((PGATE-OD18*OD25-OD33*OVD)-VTH_P-VTL_P-UHVT_P-ULVT_P-SRM-OD1T) 
//   M[pch_33]       I/O 3.3V Std VT PMOS          ((PGATE-OD18-OD25*OD33)-VTH_P-VTL_P-UHVT_P-ULVT_P-SRM-OD1T) 
//   M[pch_w]        1T_MIM PMOS                   ((PGATE-OD18-OD25-OD33*OD1T)-VTH_P-VTL_P-UHVT_P-ULVT_P-SRM)  
//   M[pch_1tr]      1T_MIM PMOS in cell           ((PGATE-OD18-OD25-OD33*OD1T*p3)-VTH_P-VTL_P-UHVT_P-ULVT_P-SRM) 
//   M[pchpu_sr]     SRAM PMOS pullup              ((PGATE-OD18-OD25-OD33-VTH_P*SRM)-VTL_P-UHVT_P-ULVT_P-OD1T) 
//   M[pchpu_hvtsr]  SRAM High VT PMOS pullup      ((PGATE-OD18-OD25-OD33*VTH_P*SRM)-SRAMULP-VTL_P-UHVT_P-ULVT_P-OD1T) 
//   M[pchpu_ulpsr]  SRAM ULP High VT PMOS pullup  ((PGATE-OD18-OD25-OD33*VTH_P*SRM)*SRAMULP-VTL_P-UHVT_P-ULVT_P-OD1T) 
// 
// 
//   rnwod        N-Well resistor under OD                  (NWDMYi*NW*(ODI*RPO))  
//   rnwsti       N-Well resister under STI                 (NWDMYi*NW-(ODI*RPO))  
//   rppolywo     P+Poly resistor w/o Silicide              (RPDMYi*POI*PP*RPO*RH)  
//   rnpolywo     N+Poly resistor w/o Silicide              (RPDMYi*POI*NP*RPO*RH)  
//   rnpolys      N+poly resistor w/i Silicide Width < 2um  (RPDMYi*POI*NP-RPO) 
//   rppolys      P+poly resistor w/i Silicide Width < 2um  (RPDMYi*POI*PP-RPO) 
//   rnpolyl      N+poly resistor w/i Silicide Width >= 2um (RPDMYi*POI*NP-RPO) 
//   rppolyl      P+poly resistor w/i Silicide Width >= 2um (RPDMYi*POI*PP-RPO) 
//   rpodwo       P+diff resistor w/o Silicide              (RPDMYi*ODI*PP*RPO*RH*NW)  
//   rnodwo       N+diff resistor w/o Silicide              (RPDMYi*ODI*NP*RPO*RH-NW)  
//   rpodl        P+diff resistor w/i Silicide width >= 2um (RPDMYi*ODI*PP-RPO*NW)  
//   rnodl        N+diff resistor w/i Silicide width >= 2um (RPDMYi*ODI*NP-RPO-NW)  
//   rpods        P+diff resistor w/i Silicide width < 2um  (RPDMYi*ODI*PP-RPO*NW)  
//   rnods        N+diff resistor w/i Silicide width < 2um  (RPDMYi*ODI*NP-RPO-NW)  
//   rm1          METAL1 resistor                           (RMDMY1*METAL1)  
//   rm2          METAL2 resistor                           (RMDMY2*METAL2)  
//   rm3          METAL3 resistor                           (RMDMY3*METAL3)  
//   rm4          METAL4 resistor                           (RMDMY4*METAL4)  
//   rm5          METAL5 resistor                           (RMDMY5*METAL5)  
//   rm6          METAL6 resistor                           (RMDMY6*METAL6)  
//   rm7          METAL7 resistor                           (RMDMY7*METAL7)  
//   rm8          METAL8 resistor                           (RMDMY8*METAL8)  
//   rm9          METAL9 resistor                           (RMDMY9*METAL9)  
//   rm10         AP/MD RDL resistor                        (RMDMYh*METAL10) 
// 
//   D[PDIO]        CORE diode P+/NW                ((DIODMY*OD*PP-OD25-OD33-OD18*NW)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NDIO]        CORE diode N+/PW                ((DIODMY*OD*NP-OD25-OD33-OD18*PSUB)-VTH_N-VTL_N-UHVT_N-ULVT_N-OD1T)   
//   D[NWDIO]       CORE diode NW/PW                ((DIODMY*NW-OD25-OD33-OD18)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[PDIO_hvt]    CORE High-VT diode P+/NW        ((DIODMY*OD*PP-OD25-OD33-OD18*NW)*VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T) 
//   D[NDIO_hvt]    CORE High-VT diode N+/PW        ((DIODMY*OD*NP-OD25-OD33-OD18*PSUB)*VTH_N-VTL_N-UHVT_N-ULVT_N-OD1T) 
//   D[PDIO_lvt]    CORE Low-VT diode P+/NW         ((DIODMY*OD*PP-OD25-OD33-OD18*NW)-VTH_P*VTL_P-UHVT_P-ULVT_P-OD1T) 
//   D[NDIO_lvt]    CORE Low-VT diode N+/PW         ((DIODMY*OD*NP-OD25-OD33-OD18*PSUB)-VTH_N*VTL_N-UHVT_N-ULVT_N-OD1T) 
//   D[PDIO_uthvt]   CORE Ultra-High VT diode P+/NW  ((DIODMY*OD*PP-OD25-OD33-OD18*NW)-VTH_P-VTL_P*UHVT_P-ULVT_P-OD1T) 
//   D[NDIO_uthvt]   CORE Ultra-High VT diode N+/PW  ((DIODMY*OD*NP-OD25-OD33-OD18*PSUB)-VTH_N-VTL_N*UHVT_N-ULVT_N-OD1T) 
//   D[PDIO_ulvt]   CORE G Ultra-Low VT diode P+/NW ((DIODMY*OD*PP-OD25-OD33-OD18*NW)-VTH_P-UHVT_P*ULVT_P*VTL_P-OD1T) 
//   D[NDIO_ulvt]   CORE G Ultra-Low VT diode N+/PW ((DIODMY*OD*NP-OD25-OD33-OD18*PSUB)-VTH_N-UHVT_N*ULVT_N*VTL_N-OD1T) 
//   D[PDIO_ulvt]   CORE LP Ultra-Low VT diode P+/NW ((DIODMY*OD*PP-OD25-OD33-OD18*NW)*VTH_P-UHVT_P*ULVT_P*VTL_P-OD1T) 
//   D[NDIO_ulvt]   CORE LP Ultra-Low VT diode N+/PW ((DIODMY*OD*NP-OD25-OD33-OD18*PSUB)*VTH_N-UHVT_N*ULVT_N*VTL_N-OD1T) 
//   D[PDIO_w]      1T_MIM diode P+/NW              (DIODMY*OD*PP-OD25-OD33-OD18*NW*OD1T)   
//   D[NDIO_w]      1T_MIM diode N+/PW              (DIODMY*OD*NP-OD25-OD33-OD18*PSUB*OD1T)   
//   D[NWDIO_w]     1T_MIM diode NW/PW              (DIODMY*NW-OD25-OD33-OD18*OD1T)  
// 
//   D[PDIO_18]     I/O 1.8V diode P+/NW            ((DIODMY*OD*PP*OD18-OD25-OD33*NW)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NDIO_18]     I/O 1.8V diode N+/PW            ((DIODMY*OD*NP*OD18-OD25-OD33*PSUB)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[PDIO_25]     I/O 2.5V diode P+/NW            ((DIODMY*OD*PP-OD18*OD25-OD33*NW-OVD)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NDIO_25]     I/O 2.5V diode N+/PW            ((DIODMY*OD*NP-OD18*OD25-OD33*PSUB-OVD)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[PDIO_25od]   I/O 2.5V diode P+/NW Ovdrv      ((DIODMY*OD*PP-OD18*OD25-OD33*NW*OVD)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T) 
//   D[NDIO_25od]   I/O 2.5V diode N+/PW Ovdrv      ((DIODMY*OD*NP-OD18*OD25-OD33*PSUB*OVD)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)  
//   D[PDIO_33]     I/O 3.3V diode P+/NW            ((DIODMY*OD*PP-OD18-OD25*OD33*NW)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NDIO_33]     I/O 3.3V diode N+/PW            ((DIODMY*OD*NP-OD18-OD25*OD33*PSUB)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NWDIO_18]    I/O 1.8V diode NW/PW            ((DIODMY*NW*OD18-OD25-OD33)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NWDIO_25]    I/O 2.5V diode NW/PW            ((DIODMY*NW-OD18*OD25-OD33)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NWDIO_33]    I/O 3.3V diode NW/PW            ((DIODMY*NW-OD18-OD25*OD33)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
// 
//   D[NDIO_na]     CORE native diode N+/PW         ((DIODMY*OD*NP-OD18-OD25-OD33*PSUB*NT_N)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NDIO_na18]   I/O 1.8V native diode N+/PW     ((DIODMY*OD*NP*OD18-OD25-OD33*PSUB*NT_N)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NDIO_na25]   I/O 2.5V native diode N+/PW     ((DIODMY*OD*NP-OD18*OD25-OD33*PSUB*NT_N)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)   
//   D[NDIO_na33]   I/O 3.3V native diode N+/PW     ((DIODMY*OD*NP-OD18-OD25*OD33*PSUB*NT_N)-VTH_P-VTL_P-UHVT_P-ULVT_P-OD1T)  
//   D[NDIO_esd]    ESD diode                       (ESD3*OD*NP*RPO-NW-PO)   
//   D[PWDNW]       diode PW/DNW                    (DNW-NW)  
//   D[DNWPSUB]     diode DNW/PSUB                  (DNW*NW) 
// 
//   Q[PNP10]       CORE PNP-BJT                (BJTDMY*OD*PP*NW*RPO)   
//   Q[PNP5]        CORE PNP-BJT                (BJTDMY*OD*PP*NW*RPO)   
//   Q[PNP2]        CORE PNP-BJT                (BJTDMY*OD*PP*NW*RPO)   
//   Q[NPN10]       CORE NPN-BJT                (BJTDMY*OD*NP-NW*RPO*DNW)   
//   Q[NPN5]        CORE NPN-BJT                (BJTDMY*OD*NP-NW*RPO*DNW)   
//   Q[NPN2]        CORE NPN-BJT                (BJTDMY*OD*NP-NW*RPO*DNW)   
//   C[CM]          1T_MIM CAP.                 (crown*p3-RPO*OD)  
//   nmoscap        MOSCAP Varactor             (VARGT-OD18-OD25-OD33) 
//   nmoscap_18     1.8V MOSCAP Varactor        (VARGT*OD18-OD25-OD33) 
//   nmoscap_25     2.5V MOSCAP Varactor        (VARGT-OD18*OD25-OD33) 
//   nmoscap_33     3.3V MOSCAP Varactor        (VARGT-OD18-OD25*OD33) 
// 
// 
//   rnwod_m        3T N-Well resistor under OD                     (NWDMY1*NW*(ODI*RPO))  
//   rnwsti_m       3T N-Well resister under STI                    (NWDMY1*NW-(ODI*RPO)) 
//   rpodwo_m       3T P+diff resistor w/o Silicide                 (RPDMY1*ODI*PP*RPO*RH*NW)  
//   rnodwo_m       3T N+diff resistor w/o Silicide                 (RPDMY1*ODI*NP*RPO*RH-NW)  
//   rpodl_m        3T P+diff resistor w/i Silicide  width >= 1.8um (RPDMY1*ODI*PP-RPO*NW)  
//   rnodl_m        3T N+diff resistor w/i Silicide  width >= 1.8um (RPDMY1*ODI*NP-RPO-NW)  
//   rpods_m        3T P+diff resistor w/i Silicide  width < 1.8um  (RPDMY1*ODI*PP-RPO*NW)  
//   rnods_m        3T N+diff resistor w/i Silicide  width < 1.8um  (RPDMY1*ODI*NP-RPO-NW)  
//    
//   rppolywo_dis   3T P+poly resistor w/o Silicide                 (RPDMY1*PO*PP*RPO*RH) 
//   rnpolywo_dis   3T N+poly resistor w/o Silicide                 (RPDMY1*PO*NP*RPO*RH) 
//   rppolyl_dis    3T P+poly resistor w/i Silicide Width >= 1.8um  (RPDMY1*PO*PP-RPO) 
//   rnpolyl_dis    3T N+poly resistor w/i Silicide Width >= 1.8um  (RPDMY1*PO*NP-RPO) 
//   rppolys_dis    3T P+poly resistor w/i Silicide Width < 1.8um   (RPDMY1*PO*PP-RPO) 
//   rnpolys_dis    3T N+poly resistor w/i Silicide Width < 1.8um   (RPDMY1*PO*NP-RPO) 
// 
// 
//   mimcap_1p0_sin         1.0ff Baseband CTM capacitor      (ctm*cbm-RFDUMMY-MIM_3TDMY)  
//   mimcap_1p0_sin_3t      1.0ff Baseband CTM capacitor      (ctm*cbm-RFDUMMY*MIM_3TDMY) 
//   mimcap_1p5_sin         1.5ff Baseband CTM capacitor      (ctm*cbm-RFDUMMY-MIM_3TDMY)  
//   mimcap_1p5_sin_3t      1.5ff Baseband CTM capacitor      (ctm*cbm-RFDUMMY*MIM_3TDMY)  
//   mimcap_2p0_sin         2.0ff Baseband CTM capacitor      (ctm*cbm-RFDUMMY-MIM_3TDMY)  
//   mimcap_2p0_sin_3t      2.0ff Baseband CTM capacitor      (ctm*cbm-RFDUMMY*MIM_3TDMY) 
//   crtmom                 Baseband MOM fringe capacitor     (MOMDMY1*MOMDMY2*MOMDMY3*MOMDMY26*PO-RFDUMMY) 
//   crtmom_mx        	  Multi cross-couple rtmom          (MOMDMY1*MOMDMY2*MOMDMY3*MOMDMY26*PO-RFDUMMY*MOMDMY22) 
// 
// 
// 
// 
//   crtmom_rf              RF MOM fringe capacitor           (MOMDMY1*MOMDMY2*MOMDMY3*MOMDMY26*PO*RFDUMMY) 
//   nmos_rf                CORE Standard VT NMOS/DNW         ((NGATE-OD18-OD25-OD33-NT_N)*DNW*RFDUMMY)   
//   nmos_rf18              I/O 1.8V Standard VT NMOS/DNW     ((NGATE*OD18-OD25-OD33-NT_N)*DNW*RFDUMMY) 
//   nmos_rf25              I/O 2.5V Standard VT NMOS/DNW     ((NGATE-OD18*OD25-OD33-NT_N)*DNW*RFDUMMY)   
//   nmos_rf33              I/O 3.3V Standard VT NMOS/DNW     ((NGATE-OD18-OD25*OD33-NT_N)*DNW*RFDUMMY)   
//   pmos_rf                CORE Standard VT PMOS             (PGATE-OD18-OD25-OD33*RFDUMMY)   
//   pmos_rf18              I/O 1.8V Standard VT PMOS         (PGATE*OD18-OD25-OD33*RFDUMMY) 
//   pmos_rf25              I/O 2.5V Standard VT PMOS         (PGATE-OD18*OD25-OD33*RFDUMMY)   
//   pmos_rf33              I/O 3.3V Standard VT PMOS         (PGATE-OD18-OD25*OD33*RFDUMMY)   
// 
//   mimcap_um_2p0_sin_rf     RF CTM w/i shield capacitor     (ctm*cbm*RFDUMMYU*SHIELD)  
//   mimcap_um_1p5_sin_rf     RF CTM w/i shield capacitor     (ctm*cbm*RFDUMMYU*SHIELD)  
//   mimcap_um_1p0_sin_rf     RF CTM w/i shield capacitor     (ctm*cbm*RFDUMMYU*SHIELD)  
//   mimcap_woum_2p0_sin_rf   RF CTM w/o shield capacitor     (ctm*cbm*RFDUMMY*NW)  
//   mimcap_woum_1p5_sin_rf   RF CTM w/o shield capacitor     (ctm*cbm*RFDUMMY*NW)  
//   mimcap_woum_1p0_sin_rf   RF CTM w/o shield capacitor     (ctm*cbm*RFDUMMY*NW)  
// 
//   rppolywo_rf            RF P+Poly resistor w/o Silicide   (RPDMYi*PO*PP*RPO*RFDUMMY*RH)  
//   rppolyl_rf             RF P+Poly resistor w/i Silicide   (RPDMYi*PO*PP-RPO*RFDUMMY)  
//   rppolys_rf             RF P+Poly resistor w/i Silicide   (RPDMYi*PO*PP-RPO*RFDUMMY)     
// 
//   sbd_rf         	  RF Schottky Barrier Diode w/i DNW (NW*SBDDMY*RFDUMMY-VAR*PP*NP*DNW)  
//   sbd_rf_nw              RF Schottky Barrier Diode w/o DNW (NW*SBDDMY*RFDUMMY-VAR*PP*NP-DNW)  
// 
//   spiral_std             Standard Spiral Inductor          (IND_STDi*IND_RAD*METAL9*METAL8*NT_N)  
//   spiral_sym             Symmestry Spiral Inductor         (IND_SYMi*IND_RAD*METAL9*METAL8*NT_N)  
//   spiral_sym_ct          Central-tap Spiral Inductor       (IND_CTi*IND_RAD*METAL9*METAL8*METAL7*NT_N) 
// 
//   mimcap_2p0_sin_udc         UDC Baseband CTM capacitor        (ctm*cbm-RFDUMMY-MIM_3TDMY)  
//   mimcap_1p5_sin_udc         UDC Baseband CTM capacitor        (ctm*cbm-RFDUMMY-MIM_3TDMY)  
//   mimcap_1p0_sin_udc         UDC Baseband CTM capacitor        (ctm*cbm-RFDUMMY-MIM_3TDMY)  
//   mimcap_2p0_sin_udc_3t      UDC Baseband CTM capacitor        (ctm*cbm-RFDUMMY*MIM_3TDMY)  
//   mimcap_1p5_sin_udc_3t      UDC Baseband CTM capacitor        (ctm*cbm-RFDUMMY*MIM_3TDMY)     
//   mimcap_1p0_sin_udc_3t      UDC Baseband CTM capacitor        (ctm*cbm-RFDUMMY*MIM_3TDMY)     
//   mimcap_um_2p0_sin_udc_rf   UDC RF CTM w/i shield capacitor   (ctm*cbm*RFDUMMY*SHIELD*M9)  
//   mimcap_um_1p5_sin_udc_rf   UDC RF CTM w/i shield capacitor   (ctm*cbm*RFDUMMY*SHIELD*M9)     
//   mimcap_um_1p0_sin_udc_rf   UDC RF CTM w/i shield capacitor   (ctm*cbm*RFDUMMY*SHIELD*M9)     
//   mimcap_woum_2p0_sin_udc_rf UDC RF CTM w/o shield capacitor   (ctm*cbm*RFDUMMY*NW*DNW)  
//   mimcap_woum_1p5_sin_udc_rf UDC RF CTM w/o shield capacitor   (ctm*cbm*RFDUMMY*NW*DNW)  
//   mimcap_woum_1p0_sin_udc_rf UDC RF CTM w/o shield capacitor   (ctm*cbm*RFDUMMY*NW*DNW)  
// 
// 
//   moscap_rf        Varactor for CORE w/i DNW       (VARGT-OD18-OD25-OD33*RFDUMMY*DNW-SBDDMY)    
//   moscap_rf18      Varactor for I/O 1.8V w/i DNW   (VARGT*OD18-OD25-OD33*RFDUMMY*DNW-SBDDMY)   
//   moscap_rf25      Varactor for I/O 2.5V w/i DNW   (VARGT-OD18*OD25-OD33*RFDUMMY*DNW-SBDDMY)   
//   moscap_rf33      Varactor for I/O 3.3V w/i DNW   (VARGT-OD18-OD25*OD33*RFDUMMY*DNW-SBDDMY) 
//   moscap_rf_nw     Varactor for CORE w/o DNW       (VARGT-OD18-OD25-OD33*RFDUMMY-DNW-SBDDMY)    
//   moscap_rf18_nw   Varactor for I/O 1.8V w/o DNW   (VARGT*OD18-OD25-OD33*RFDUMMY-DNW-SBDDMY)   
//   moscap_rf25_nw   Varactor for I/O 2.5V w/o DNW   (VARGT-OD18*OD25-OD33*RFDUMMY-DNW-SBDDMY)   
//   moscap_rf33_nw   Varactor for I/O 3.3V w/o DNW   (VARGT-OD18-OD25*OD33*RFDUMMY-DNW-SBDDMY) 
//   xjvar            Junction Varactor               (JVARD*OD*PP*NP*NW*RFDUMMY*DNW-SBDDMY)    
//   xjvar_nw         Junction Varactor               (JVARD*OD*PP*NP*NW*RFDUMMY-DNW-SBDDMY)       
// 
//   ----- ----------------------------- ---------------------------------- 
//   * PSUB = BULK - NW 
//   * NGATE = ODI * POI * NP - NW 
//   * PGATE = ODI * POI * PP * NW 
//   * VARGT = ODI * POI * NP * NW * VAR 
//   * OD = ODI + DOD 
//   * PO = POI + DPO 
//   * POS = POS1 + POS2 +POS3 
//   * DNW = DNWi 
//   * INDDMY = IND_STDi 
//   * METAL1 = M1 + DUM1 
//   * METAL2 = M2 + DUM2 
//   * METAL3 = M3 + DUM3 
//   * METAL4 = M4 + DUM4 
//   * METAL5 = M5 + DUM5 
//   * METAL6 = M6 + DUM6 
//   * METAL7 = M7 + DUM7 
//   * METAL8 = M8 + DUM8 
//   * METAL9 = M9 + DUM9 
//   * METAL10 = AP + MD  
//   * RFDUMMY = RFDMY  
//   * RFDUMMYU = RFDMY + RFDMYUD 
//   * JVARD = VAR - POI 
//   * SHIELD = (M6 + M5) * ctm * RFDMY 
// 
//////////////////////////////////////////////////////////////////////////////// 
// USER NOTES : 
// 
// 0) Please read file "README" in the package and "DECK_USAGE" document in folder "TSMC_DOC_WM" to find out switch usage and LVS/LPE flow steps of N65 process. 
//  
// 1)  mnpg, mppg, ppvdd49, npvss49, floating wells are obtained in ERC rules, you can run LVS to get this information. 
// 
// 2) For Calibre "EDTEXT" file, use .INCLUDE strings.txt. 
//        LAYOUT TEXT  "text string" [x] [y]  (layer num) (cell name) 
// 
// 3) Input layer 'OD' is defined as thin oxide (OD) area which would  
//    be drawn by one generic od mask or by seperated N+OD and P+OD.  
//    Remove layers in the 'OD' entries you don't want to use at  
//    layer definition block. 
// 
// 4) Default setting for property check is 0%. Users should check with 
//    IP/Designe providers for proper tolerance. 
// 
// 5) Default property resolution for ambiguity is set to 32. It could be 
//    necessary to increase this setting to resolve serious ambiguity. 
//    Uncomment statement 'LVS PROPERTY RESOLUTION MAXIMUM' in this deck 
//    to reset the capability of property resolution. 
// 
// 6) This deck does not extract MOS AS/AD property by default. To turn on the 
//    extraction of MOS AS/AD property, please uncomment the line 
//    "#DEFINE extract_as_ad". It would cause SEED PROMOTION, and pose 
//    much overhead on layout netlist extraction, erc checks, and lvs comparison. 
// 
// 7) Thin oxide layers PDIFF (7;0) and NDIFF (8;0) are not recommended to be 
//    used as tape out layers. Please use OD (6:0) for thin oxide tape out layers. 
//    If PDIFF (7;0) and NDIFF (8;0) layers are used, be sure to check MT (tape out) 
//    form for correctness after modifying this LVS deck (to pass LVS check) 
// 
// 8) This lvs command file does not support four resistors "rrwod,rrwsti,rdnwod,rdnwsti". 
//    Spice model defines them just for providing the sheet resistance of RWELL 
//    and DNW, not for the purpose of forming devices. We can not guarantee the resistance 
//    value if these four devices are applied in customer's design. 
// 
// 9) By default, the two diodes, PWDNW and DNWPSUB, are not extracted in this command  
//     file.  Please turn on the switch, "#DEFINE extract_dnwdio", 
//     to apply the extraction of these two diode. 
// 
// 10) For LP process, please turn on the switch "#DEFINE LP" for low Vt and ultra low Vt device extraction. 
////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
// 
//lvs_gen.pl version: 1.93
//calibre.pl version: 1.130

// LVS/RC_DFM switch option
// --------------------
//#define DFM_RULE    //uncomment this line when this deck would like to include DFM rules
#define RC_DECK     //uncomment this line when this deck would be used as a RC command file
//#define ZERO_NRS_NRD    //uncomment this line when this deck would set NRS=0 and NRD=0 
//#define FILTER_DGS_TIED_MOS // uncomment this line to filter MOS with D, G and S tied together (default filter MOS with all pins tied)
#define WELL_TO_PG_CHECK 
// Default is on. Turn on to highlight if nwell connects to ground or psub connects to power.
//#define GATE_TO_PG_CHECK 
// Default is off. Turn on to highlight if a mos gate directly connects to power or ground.
//#define PATH_CHECK 
// Default is off. Turn on to highlight if
//(1) nodes have a path to power but no path to ground
//(2) nodes have a path to ground but no path to power
//(3) nodes have no path to power or ground
//(4) nodes have no path to any label net
#define DS_TO_PG_CHECK 
// Default is on. Turn on to highlight if drain connects to power and source connects to ground.
#define FLOATING_WELL_CHECK 
// Default is on. Turn on to highlight if well does not connect to power or ground. 
//The nwell of moscaps and nwell-resistor are excluded.

VARIABLE WPED 5.0
VARIABLE PRESCALE 1.0

//#define NW_RING	//uncomment this line to enable the NW ring to separate the node from BULK

// POWER and GROUND name string variable setting
VARIABLE POWER_NAME  "AHVDD"  "AHVDDB"  "AHVDDG"  "AHVDDR"  "AHVDDWELL"  "AVDD"  "AVDDB"  "AVDDBG"  "AVDDG"  "AVDDR"  "AVDWELL"  "DHVDD"  "DVDD"  "HVDDWELL"  "TACVDD"  "TAVD33"  "TAVD33PST"  "TAVDD"  "TAVDDPST"  "VD33"  "VDD"  "VDD5V"  "VDDG"  "VDDPST"  "VDDSA"  "VDWELL" 

VARIABLE GROUND_NAME  "AGND"  "AHVSS"  "AHVSSB"  "AHVSSG"  "AHVSSR"  "AHVSSUB"  "AVSS"  "AVSSB"  "AVSSBG"  "AVSSG"  "AVSSR"  "AVSSUB"  "DHVSS"  "DVSS"  "GND"  "HVSSUB"  "TAVSS"  "TAVSSPST"  "VS33"  "VSS"  "VSSG"  "VSSPST"  "VSSUB" 

//#########################################################################
//# ENVIRONMENT SETTING                              
//#########################################################################
// LVS option
// --------------------
//#define extract_as_ad
//

//  RC_BLOCKING SETTING
LAYOUT CELL LIST pcells "crtmom*" "crtmom_mx*" "crtmom_rf*" "mimcap_um*" "mimcap_um*" "mimcap_um*" "mimcap_woum*" "mimcap_woum*" "mimcap_woum*" "moscap_rf*" "moscap_rf18*" "moscap_rf18_nw*" "moscap_rf25*" "moscap_rf25_nw*" "moscap_rf33*" "moscap_rf33_nw*" "moscap_rf_nw*" "nmos_rf*" "nmos_rf18*" "nmos_rf25*" "nmos_rf33*" "pmos_rf*" "pmos_rf18*" "pmos_rf25*" "pmos_rf33*" "rppoly_rf*" "rppoly_rf*" "rppolywo_rf*" "sbd_rf*" "sbd_rf_nw*" "spiral_std*" "spiral_sym*" "spiral_sym_ct*" "xjvar*" "xjvar_nw*" 
LAYOUT PRESERVE CELL LIST pcells

#DEFINE LP  // Please turn on this switch for low Vt and ULVT device in LP process
//#DEFINE extract_dnwdio	 // To extract R-Well/DNW and DNW/PSUB diodes. 
//#DEFINE Cu_RDL        // Use copper RDL
#DEFINE WPE         // For MACRO device model
//#define CAP_1P0
//#define CAP_1P5
  
//#define STD_LIB
#IFDEF STD_LIB       // for tsmc N90 STD library , to estimate well proximity effect on STD cell.
VARIABLE	NMOS_BOT_EXT 	0.86*1e-6
VARIABLE	PMOS_TOP_EXT 	1.09*1e-6
VARIABLE	MOS_LR_EXT 	100.0*1e-6
#ELSE
VARIABLE	NMOS_BOT_EXT 	0
VARIABLE	PMOS_TOP_EXT 	0
VARIABLE	MOS_LR_EXT 	0
#ENDIF

//LVS HEAP DIRECTORY "/tmp"

LAYOUT PRIMARY "lvs_top"
LAYOUT PATH "lvs_top.gds"
LAYOUT SYSTEM GDSII
//LAYOUT PATH "layout.net"
//LAYOUT SYSTEM SPICE

SOURCE PRIMARY "lvs_top"
SOURCE PATH "lvs_top.cdl"
SOURCE SYSTEM SPICE

DRC RESULTS DATABASE "calibre_drc.db" ASCII // ASCII or GDSII
DRC SUMMARY REPORT "calibre_drc.sum"

ERC RESULTS DATABASE "calibre_erc.db" ASCII // ASCII or GDSII
ERC SUMMARY REPORT "calibre_erc.sum"

LVS REPORT "lvs.rep"
LVS REPORT MAXIMUM 1000 // ALL

#IFDEF RC_DECK
  //MASK RESULTS DATABASE NONE //"mask.db"
#ELSE
  MASK RESULTS DATABASE NONE //"mask.db"
#ENDIF

#IFDEF RC_DECK
  //MASK SVDB DIRECTORY "svdb" QUERY
#ELSE
  MASK SVDB DIRECTORY "svdb" QUERY
#ENDIF
LVS ISOLATE SHORTS YES
LVS REPORT OPTION S

PRECISION 1000
RESOLUTION 1
UNIT LENGTH U

#IFDEF RC_DECK
  //UNIT CAPACITANCE FF
#ELSE
  UNIT CAPACITANCE FF
#ENDIF

TEXT DEPTH PRIMARY
PORT DEPTH PRIMARY

FLAG SKEW YES
FLAG OFFGRID YES

LVS SPICE PREFER PINS	         YES
LVS ABORT ON SUPPLY ERROR        NO
LVS ALL CAPACITOR PINS SWAPPABLE YES
LVS RECOGNIZE GATES              NONE
LVS IGNORE PORTS                 NO
LVS CHECK PORT NAMES             YES
LVS REDUCE PARALLEL BIPOLAR      YES
LVS REDUCE PARALLEL MOS          YES
LVS REDUCE PARALLEL DIODES       YES
LVS REDUCE PARALLEL CAPACITORS   YES
LVS REDUCE PARALLEL RESISTORS    YES
LVS REDUCE SERIES RESISTORS      YES      //Smashes series resistors
LVS REDUCE SERIES CAPACITORS     YES      //Smashes series capacitors
LVS REDUCE SPLIT GATES           NO       //Smashes MOS split-gates.
//LVS FILTER UNUSED OPTION B D E O
//Strongly recommand to comment FILTER_DGS_TIED_MOS switch
//AG is to filter MOS with all pins tied together, AB is to filter MOS with D,G,S tied together
#IFNDEF FILTER_DGS_TIED_MOS
LVS FILTER UNUSED OPTION AG RC RE RG
#ELSE
LVS FILTER UNUSED OPTION AB RC RE RG
#ENDIF
LVS PROPERTY RESOLUTION MAXIMUM 65536 // ALL
LVS SPICE STRICT WL YES

//User Define Device Reduce
//==================================================================================================
LVS REDUCE rnwsti PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnwsti SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnwod PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnwod SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rppolywo PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolywo SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnpolywo PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnpolywo SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rpodwo PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rpodwo SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnodwo PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnodwo SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rppolyl PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolyl SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnpolyl PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnpolyl SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rpodl PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rpodl SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnodl PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnodl SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rppolys PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolys SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnpolys PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnpolys SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rpods PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rpods SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnods PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnods SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]

LVS REDUCE rm1 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm1 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm2 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm2 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm3 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm3 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm4 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm4 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm5 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm5 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm6 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm6 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm7 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm7 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm8 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm8 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm9 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm9 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rm10 PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rm10 SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]


LVS REDUCE rnwsti_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnwsti_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnwod_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnwod_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rpodwo_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rpodwo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnodwo_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnodwo_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rpodl_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rpodl_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnodl_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnodl_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rpods_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rpods_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]
LVS REDUCE rnods_m PARALLEL YES
[ TOLERANCE lr 0
  EFFECTIVE wr,lr
  lr = sum(lr)/count()
  wr = sum(wr)
]
LVS REDUCE rnods_m SERIES PLUS MINUS YES
[ TOLERANCE wr 0
  effective wr,lr
  wr = sum(wr)/count()
  lr = sum(lr)
]

LVS REDUCE rppolys_dis PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolys_dis SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnpolys_dis PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnpolys_dis SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rppolyl_dis PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolyl_dis SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnpolyl_dis PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnpolyl_dis SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rppolywo_dis PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rppolywo_dis SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]
LVS REDUCE rnpolywo_dis PARALLEL YES
[ TOLERANCE l 0
  EFFECTIVE w,l
  l = sum(l)/count()
  w = sum(w)
]
LVS REDUCE rnpolywo_dis SERIES PLUS MINUS YES
[ TOLERANCE w 0
  effective w,l
  w = sum(w)/count()
  l = sum(l)
]

//==================================================================================================
// should be modify
LAYOUT TOP LAYER M1 VIA1i M2 VIA2i M3 VIA3i M4 VIA4i M5 VIA5i M6 VIA6i M7 VIA7i M8 VIA8i M9 RV CB CBD VIAD AP MD

//LAYOUT TOP LAYER M1 VIA1 M2 VIA2 M3 VIA3 M4 VIA4 M5 VIA5 M6 VIA6 M7 VIA7 M8 VIA8 M9
VIRTUAL CONNECT COLON YES
LVS POWER NAME POWER_NAME 
LVS GROUND NAME GROUND_NAME 
//#############################################
//# MAPPING                                   #
//#############################################
LAYER VTD_N           66  //   lincap device (depletion NMOS)
LAYER ctm             77  //  For MIM device
LAYER cbm             88  //  For MIM device
LAYER crown           102  //    cap. bottom
LAYER CAP1TDMY        78  //    CAP1TDMY for 1TRAM CAP region
LAYER blc             101  //    BLC contact
LAYER p3              103  //    Poly for 1TRAM
LAYER OD1T            27  //   OD for 1TRAM 
#IFDEF LP
LAYER LVID           300
LAYER MAP 17 DATATYPE 51 300 //  For LP process    
 VTL_N = COPY LVID
 VTL_P = COPY LVID
#ENDIF
LAYER UHVT_N          93  //  FOR ULTRA High VT DEVICES
LAYER UHVT_P          94  //  FOR ULTRA High VT DEVICES
LAYER ULVT_N          151  //  FOR ULTRA Low VT DEVICES
LAYER ULVT_P          152  //  FOR ULTRA Low VT DEVICES
LAYER DNWi            1  //  Deep N-Well
LAYER NW              3  //  N-Well
LAYER ODI             6  7  8  //  Active area, thin oxide for device, or interconnection
LAYER DOD            301 
LAYER MAP 6 DATATYPE 1 301 //  Dummy OD 
LAYER NT_N            11  //   Native NMOS blocked implant
#IFNDEF LP
LAYER VTL_N           12  //  CORE Low VT NMOS
#ENDIF
#IFNDEF LP
LAYER VTL_P           13  //  CORE Low VT PMOS
#ENDIF
LAYER OD33            15  //  Thick Oxide (dual gate oxide) for 3.3V device
LAYER OD25           302 
LAYER MAP 41 DATATYPE 0 302 //  Thick Oxide (dual gate oxide) for 2.5V device
LAYER OD18            16  //  Thick Oxide (dual gate oxide) for 1.8V device
LAYER OD5            303 
LAYER MAP 82 DATATYPE 4 303 //  for HV process (IO5V/6V devices)
LAYER OD6            304 
LAYER MAP 82 DATATYPE 6 304 //  for HV process (IO5V/6V devices)
LAYER OVD            305 
LAYER MAP 41 DATATYPE 3 305 //  over-driven device ( 2.5V -> 3.3V )
LAYER UDD            306 
LAYER MAP 41 DATATYPE 5 306 //  under-driven device ( 2.5V -> 1.8V )
LAYER POI            307 
LAYER MAP 17 DATATYPE 0 307 //  Gate poly, poly Si
LAYER DPO            308 
LAYER MAP 17 DATATYPE 1 308 //  Dummy poly
LAYER PP              25  //  P+ S/D Implant
LAYER NP              26  //  N+ S/D Implant
LAYER RPO             29  //  Non silicided area definition
LAYER CO              30  //  Contact Window
LAYER M1              31  //  Metal1
LAYER M2              32  //  Metal2
LAYER M3              33  //  Metal3
LAYER M4              34  //  Metal4
LAYER M5              35  //  Metal5
LAYER M6              36  //  Metal6
LAYER M7              37  //  Metal7
LAYER M8              38  //  Metal8
LAYER M9              39  //  Metal9
LAYER CB              43  //  Pad window for WB
LAYER CBD             169  //  Pad window for Flip-chip
LAYER RV              85  //  For AP RDL via
LAYER AP              42  //  For AP RDL metal
LAYER MD              168  //  For Cu RDL metal
LAYER VIAD            167  //  For Cu RDL via
LAYER SRM             50  //  Use"SRM" to cover SRAM cell array to generate VTN_CELL mask.
LAYER SRAMULP        309 
LAYER MAP 50 DATATYPE 20 309 //  Use"SRMULP" to cover ULP SRAM cell array.
LAYER VIA1i           51  //  Via1
LAYER VIA2i           52  //  Via2
LAYER VIA3i           53  //  Via3
LAYER VIA4i           54  //  Via4
LAYER VIA5i           55  //  Via5
LAYER VIA6i           56  //  Via6
LAYER VIA7i           57  //  Via7
LAYER VIA8i           58  //  Via8
LAYER VTH_N           67  //  CORE High VT DEVICE
LAYER VTH_P           68  //  CORE High VT DEVICE
LAYER VAR             143  //  layer to form Varactor
LAYER RH              117  //  layer to form diffusion and poly resistor
LAYER ESD3            147  //  Cover high voltage IO designed by 3.3V NMOS
LAYER MIM_3TDMY      310 
LAYER MAP 148 DATATYPE 21 310 //  dummy layer for the base band mimcap 3 terminals using
LAYER CTMDMYUD       311 
LAYER MAP 148 DATATYPE 10 311 //  Please add CTMDMYUD to allow putting devices under w/i shield BB mimcap Devices (mimcap use only)
LAYER RODMY           49  //  dummy layer for LVS to exclude OD area
LAYER BJTDMY          110  //  BJT dummy layer for LVS
LAYER PSUB2           111  //  dummy layer for isolation power domains of PW
LAYER NWDMYi         312 
LAYER MAP 114 DATATYPE 0 312 //  dummy layer to form N-Well resistor
LAYER NWDMY1         313 
LAYER MAP 114 DATATYPE 1 313 //  dummy layer to form N-Well 3 terminals resistor
LAYER RPDMYi         314 
LAYER MAP 115 DATATYPE 0 314 //  dummy layer to form OD/POLY resistor
LAYER RPDMY1         315 
LAYER MAP 115 DATATYPE 1 315 //  dummy layer to form OD/POLY 3 terminals resistor
LAYER RHRI           316 
LAYER MAP 120 DATATYPE 0 316 //  HRI high poly resistor dummy layer
LAYER HRI             70  //  HRI high poly resistor implantation
LAYER DIODMY          119  //  dummy layer to form diode
LAYER MOMDMY0        317 
LAYER MAP 155 DATATYPE 0 317 //  dummy layer for MOM metal0 covered.
LAYER MOMDMY1        318 
LAYER MAP 155 DATATYPE 1 318 //  dummy layer for MOM metal1 covered.
LAYER MOMDMY2        319 
LAYER MAP 155 DATATYPE 2 319 //  dummy layer for MOM metal2 covered.
LAYER MOMDMY3        320 
LAYER MAP 155 DATATYPE 3 320 //  dummy layer for MOM metal3 covered.
LAYER MOMDMY4        321 
LAYER MAP 155 DATATYPE 4 321 //  dummy layer for MOM metal4 covered.
LAYER MOMDMY5        322 
LAYER MAP 155 DATATYPE 5 322 //  dummy layer for MOM metal5 covered.
LAYER MOMDMY6        323 
LAYER MAP 155 DATATYPE 6 323 //  dummy layer for MOM metal6 covered.
LAYER MOMDMY7        324 
LAYER MAP 155 DATATYPE 7 324 //  dummy layer for MOM metal7 covered.
LAYER MOMDMY21       325 
LAYER MAP 155 DATATYPE 21 325 //  dummy layer for dummy OD under MOM devices
LAYER MOMDMY22       326 
LAYER MAP 155 DATATYPE 22 326 //  dummy layer for crtmom_mx
LAYER MOMDMY23       327 
LAYER MAP 155 DATATYPE 23 327 //  dummy layer for crtmom_mx pin1 
LAYER MOMDMY24       328 
LAYER MAP 155 DATATYPE 24 328 //  dummy layer for crtmom_mx pin2
LAYER MOMDMY25       329 
LAYER MAP 155 DATATYPE 25 329 //  dummy layer for crtmom_mx plus1 & plus2
LAYER MOMDMY26       330 
LAYER MAP 155 DATATYPE 26 330 //  dummy layer for LBUS length rtmom devices
LAYER POFUSE         331 
LAYER MAP 156 DATATYPE 1 331 //  poly fuse thin part recognization
LAYER RMDMY1         332 
LAYER MAP 116 DATATYPE 1 332 //  dummy layer to form METAL-1 resistor
LAYER RMDMY2         333 
LAYER MAP 116 DATATYPE 2 333 //  dummy layer to form METAL-2 resistor
LAYER RMDMY3         334 
LAYER MAP 116 DATATYPE 3 334 //  dummy layer to form METAL-3 resistor
LAYER RMDMY4         335 
LAYER MAP 116 DATATYPE 4 335 //  dummy layer to form METAL-4 resistor
LAYER RMDMY5         336 
LAYER MAP 116 DATATYPE 5 336 //  dummy layer to form METAL-5 resistor
LAYER RMDMY6         337 
LAYER MAP 116 DATATYPE 6 337 //  dummy layer to form METAL-6 resistor
LAYER RMDMY7         338 
LAYER MAP 116 DATATYPE 7 338 //  dummy layer to form METAL-7 resistor
LAYER RMDMY8         339 
LAYER MAP 116 DATATYPE 8 339 //  dummy layer to form METAL-8 resistor
LAYER RMDMY9         340 
LAYER MAP 116 DATATYPE 9 340 //  dummy layer to form METAL-9 resistor
LAYER RMDMYh         341 
LAYER MAP 116 DATATYPE 16 341 // 
LAYER DUM1           342 
LAYER MAP 31 DATATYPE 1 342 //  dummy metal M1
LAYER DUM2           343 
LAYER MAP 32 DATATYPE 1 343 //  dummy metal M2
LAYER DUM3           344 
LAYER MAP 33 DATATYPE 1 344 //  dummy metal M3
LAYER DUM4           345 
LAYER MAP 34 DATATYPE 1 345 //  dummy metal M4
LAYER DUM5           346 
LAYER MAP 35 DATATYPE 1 346 //  dummy metal M5
LAYER DUM6           347 
LAYER MAP 36 DATATYPE 1 347 //  dummy metal M6
LAYER DUM7           348 
LAYER MAP 37 DATATYPE 1 348 //  dummy metal M7
LAYER DUM8           349 
LAYER MAP 38 DATATYPE 1 349 //  dummy metal M8
LAYER DUM9           350 
LAYER MAP 39 DATATYPE 1 350 //  dummy metal M9
LAYER DUMMD          351 
LAYER MAP 168 DATATYPE 1 351 //  dummy metal MD
LAYER TLDMY5         352 
LAYER MAP 116 DATATYPE 20 352 // 
LAYER TLDMY6         353 
LAYER MAP 116 DATATYPE 21 353 // 
LAYER TLDMY7         354 
LAYER MAP 116 DATATYPE 22 354 // 
LAYER TLDMY_TOP      355 
LAYER MAP 116 DATATYPE 31 355 // 
LAYER TLDMY_LFT      356 
LAYER MAP 116 DATATYPE 32 356 // 
LAYER SRAMPSGT       357 
LAYER MAP 186 DATATYPE 1 357 //  FOR SRAM NMOS passgate
LAYER SRAMCVSS       358 
LAYER MAP 186 DATATYPE 3 358 //  FOR CVSS SRAM
LAYER RFDMY          359 
LAYER MAP 161 DATATYPE 0 359 //  For RF Device using only ( some layout using datatype 1 )
LAYER RFDMYUD        360 
LAYER MAP 161 DATATYPE 10 360 //  Please chenage RFDMY to be RFDMYUD to allow putting devices under w/i shield RF mimcap Devices (mimcap use only)
LAYER IND_STDi       361 
LAYER MAP 144 DATATYPE 0 361 //  For RF Inductor device standard
LAYER IND_SYMi       362 
LAYER MAP 144 DATATYPE 1 362 //  For RF Inductor device symmetric
LAYER IND_CTi        363 
LAYER MAP 144 DATATYPE 2 363 //  For RF Inductor device center-tap
LAYER IND_RAD        364 
LAYER MAP 144 DATATYPE 30 364 //  For RF Inductor devices radious
LAYER DRAIN          365 
LAYER MAP 6 DATATYPE 3 365 //  For RF MOS drain side using only
LAYER SBDDMY         366 
LAYER MAP 113 DATATYPE 0 366 //  Dummy layer for schottky barrier diode RF device 
LAYER CELLM          367 
LAYER MAP 130 DATATYPE 0 367 //  For CIS process (Medium NMOS: nch_mvt25/33)
LAYER CAP_IMP        368 
LAYER MAP 130 DATATYPE 25 368 //  For CIS process (npolycap_25/33)	
LAYER POS1           369 
LAYER MAP 254 DATATYPE 1 369 //  Dummy layer to increase gate length 1 nm to both sides 
LAYER POS2           370 
LAYER MAP 254 DATATYPE 2 370 //  Dummy layer to increase gate length 2 nm to both sides
LAYER POS3           371 
LAYER MAP 254 DATATYPE 3 371 //  Dummy layer to increase gate length 3 nm to both sides
TEXT LAYER 131 ATTACH 131 metal1
PORT LAYER TEXT 131
#IFDEF Cu_RDL
  TEXT LAYER 159 ATTACH 159 metal10
  PORT LAYER TEXT 159
#ELSE
  TEXT LAYER 126 ATTACH 126 metal10
  PORT LAYER TEXT 126
#ENDIF
TEXT LAYER 132 ATTACH 132 metal2
PORT LAYER TEXT 132
TEXT LAYER 133 ATTACH 133 metal3
PORT LAYER TEXT 133
TEXT LAYER 134 ATTACH 134 metal4
PORT LAYER TEXT 134
TEXT LAYER 135 ATTACH 135 metal5
PORT LAYER TEXT 135
TEXT LAYER 136 ATTACH 136 metal6
PORT LAYER TEXT 136
TEXT LAYER 137 ATTACH 137 metal7
PORT LAYER TEXT 137
TEXT LAYER 138 ATTACH 138 metal8
PORT LAYER TEXT 138
TEXT LAYER 139 ATTACH 139 metal9
PORT LAYER TEXT 139
#IFDEF RC_DECK
TEXT LAYER 149 ATTACH 149 poly
PORT LAYER TEXT 149
#ENDIF

#IFNDEF RC_DECK

#IFNDEF DFM_RULE
LAYER MAP 149 TEXTTYPE 1 372
TEXT LAYER 372 ATTACH 372 poly
PORT LAYER TEXT 372
#ENDIF
#ENDIF
//#############################################
//# LOGIC OPERATION POOL                      #
//#############################################

//Form BULK layer
DRC:1 = EXTENT
BULK  = SIZE DRC:1 BY 0.005

//* Define device -- nmos nch
PO = POI OR DPO 
rpolywo1 = PO AND RH 
rpolywo2 = rpolywo1 AND RPO 
rpolywo3 = rpolywo2 NOT HRI 
rpolywo4 = rpolywo3 INTERACT POI 
RPDMY = RPDMYi OR RPDMY1 
OD = ODI OR DOD 
rodsrm = RODMY AND SRM 
diffa1 = OD NOT rodsrm 
diffa = diffa1 NOT MOMDMY21 
diff = diffa INTERACT CO 
rp1 = RPDMY NOT INTERACT diff 
p1rdum = rp1 INTERACT PO  //  poly1 resistor dummy
rpolywo = rpolywo4 INTERACT p1rdum 
poly1 = PO NOT rpolywo 
rpoly1 = PO AND p1rdum 
rpoly2 = rpoly1 INTERACT POI 
hripo1 = rpoly2 AND HRI 
rpoly3 = rpoly2 NOT INTERACT hripo1 
rpoly = rpoly3 NOT INTERACT RPO 
poly21 = poly1 NOT rpoly 
hripo2 = hripo1 AND RHRI 
hripo3 = hripo2 NOT NP 
hripo4 = hripo3 NOT PP 
hripo41 = hripo4 INTERACT RPO 
poly22 = poly21 NOT hripo41 
poly = poly22 NOT MOMDMY0  //  POLY interconnect
dumpo1 = poly INSIDE diff 
dumpo2 = dumpo1 NOT INTERACT CO 
realpo = poly NOT dumpo2 
rodwo1 = diff AND RH 
rodwo2 = rodwo1 AND RPO 
rodwo3 = rodwo2 INTERACT ODI 
drdum = RPDMY INTERACT diff  //  diff resistor dummy
rodwo = rodwo3 INTERACT drdum 
mdiff1 = diff NOT rodwo 
rod1 = diff AND drdum 
rod2 = rod1 INTERACT ODI 
rod = rod2 NOT INTERACT RPO 
mdiff = mdiff1 NOT rod 
gate1 = realpo AND mdiff 
gate_a_rf_1 = gate1 AND RFDMY 
gate_a_rf = gate_a_rf_1 NOT SRM 
poly_rf1 = poly INTERACT CO 
poly_rf2 = poly_rf1 INTERACT DRAIN 
poly_rf = poly_rf2 AND RFDMY 
gate_rfb = gate_a_rf AND poly_rf 
gate_rf = gate_rfb NOT VAR 
gate_1 = gate1 NOT gate_rf 
rf_mdiff = mdiff INTERACT DRAIN 
gate = gate_1 NOT INTERACT rf_mdiff 
gate_nos1 = gate NOT SRM 
NWDMY = NWDMYi OR NWDMY1 
nxwell = NW NOT NWDMY  //  define N_well region
gatennw = gate_nos1 NOT nxwell  //  gate not inside nwell
tngate1 = gatennw AND NP 
tngate1a = tngate1 NOT OD5 
tngate2 = tngate1a NOT OD25 
tngate3 = tngate2 NOT OD33 
tngate4 = tngate3 NOT OD18 
tngate5 = tngate4 NOT NT_N 
DNW = COPY DNWi 
tngate6 = tngate5 NOT DNW 
tngate7 = tngate6 NOT OD1T 
nlvgate1 = tngate7 AND VTL_N 
nlvgate_org = nlvgate1 NOT ULVT_N 
ngate1 = tngate7 NOT nlvgate_org 
nhvgate_org = tngate7 AND VTH_N 
ngate2 = ngate1 NOT nhvgate_org 
nuvhgate_bz = tngate7 AND UHVT_N 
ngate3 = ngate2 NOT nuvhgate_bz 
#IFDEF LP
nuvlgate1 = tngate7 AND VTL_N
#ELSE
nuvlgate1 = COPY tngate7
#ENDIF
nuvlgate_bz = nuvlgate1 AND ULVT_N 
ngate_org = ngate3 NOT nuvlgate_bz 
#IFDEF WPE 
MAC = COPY OD
#ELSE
MAC = OD NOT (SIZE OD BY 0.005)
#ENDIF
ngate_bz = ngate_org NOT MAC 
POSall1 = POS1 OR POS2 
POSall = POSall1 OR POS3 
ngate = ngate_bz NOT POSall  //  CORE SVT NMOS

//***** Define connectivity/via layer -- tndiff ****
nthin1 = mdiff AND NP 
ydio_a = ESD3 AND OD 
ydio_c = SIZE ydio_a BY -0.2 
ydio_d = ydio_c AND NP 
ydio_e = ydio_d AND RPO 
ydio_f = ydio_e NOT NW 
ydio_g = ESD3 AND PO 
ydio_h = SIZE ydio_g BY 0.2 
ydio_i = ydio_f NOT ydio_h 
ydio_j = SIZE ydio_i BY -0.8 
ydio = SIZE ydio_j BY 0.6 
nthin = nthin1 NOT ydio  //  define N+ thin oxide
tndiff = nthin NOT gate1  //  define N+ diffusion region

//***** Define connectivity/via layer -- psub ****
ppsub = BULK NOT NW 
psub2s = SIZE PSUB2 BY 0.01 
psubband = psub2s NOT PSUB2 
psub = ppsub NOT psubband  //  psub= [(bulk-nwell)-size(psub2)]+[(bulk-nwell)*psub2]

//* Define device -- nmos nchpg_hvtsr
gate_s1 = gate AND SRM 
gatennw_s = gate_s1 NOT nxwell  //  gate not inside nwell
ngate_s1 = gatennw_s AND NP 
ngate_s2 = ngate_s1 NOT OD25 
ngate_s3 = ngate_s2 NOT OD33 
ngate_s4 = ngate_s3 NOT OD18 
ngate_s5 = ngate_s4 NOT OD5 
ngate_s6 = ngate_s5 NOT VTL_N 
ngate_s7 = ngate_s6 NOT UHVT_N 
ngate_hvs1 = ngate_s7 AND VTH_N 
ngate_hvs = ngate_hvs1 NOT SRAMULP 
ngate_hvspg = ngate_hvs AND SRAMPSGT  //  SRAM High VT NMOS passgate

//* Define device -- nmos nchpd_hvtsr
ngate_hvspd = ngate_hvs NOT SRAMPSGT  //  SRAM High VT NMOS pulldown

//* Define device -- nmos nch_lvt
nlvgate_bz = nlvgate_org NOT MAC 
nlvgate = nlvgate_bz NOT POSall  //  CORE LOW_VT NMOS

//* Define device -- nmos nch_dnw
tdgate1a = tngate5 AND DNW 
tdgate1 = tdgate1a NOT OD1T 
n1lvgate1 = tdgate1 AND VTL_N 
n1lvgate_org = n1lvgate1 NOT ULVT_N 
nrgate1 = tdgate1 NOT n1lvgate_org 
n1hvgate_org = tdgate1 AND VTH_N 
nrgate2 = nrgate1 NOT n1hvgate_org 
n1uvhgate_bz = tdgate1 AND UHVT_N 
nrgate3 = nrgate2 NOT n1uvhgate_bz 
#IFDEF LP
n1uvlgate1 = tdgate1 AND VTL_N
#ELSE
n1uvlgate1 = COPY tdgate1
#ENDIF
n1uvlgate_bz = n1uvlgate1 AND ULVT_N 
nrgate_org = nrgate3 NOT n1uvlgate_bz 
nrgate_bz = nrgate_org NOT MAC 
nrgate = nrgate_bz NOT POSall  //  CORE NMOS on DNW

//* Define device -- nmos nchpg_sr
ngate_s8 = ngate_s7 NOT ULVT_N 
ngate_s = ngate_s8 NOT VTH_N 
ngate_spg = ngate_s AND SRAMPSGT  //  SRAM NMOS passgate

//* Define device -- nmos nchpd_sr
ngate_spd = ngate_s NOT SRAMPSGT  //  SRAM NMOS pulldown

//* Define device -- nmos nchpg_ulpsr
ngate_ulp = ngate_hvs1 AND SRAMULP 
ngate_ulppg = ngate_ulp AND SRAMPSGT  //  ULP SRAM NMOS passgate

//* Define device -- nmos nchpd_ulpsr
ngate_ulppd = ngate_ulp NOT SRAMPSGT  //  ULP SRAM NMOS pulldown

//* Define device -- nmos nch_hvt
nhvgate_bz = nhvgate_org NOT MAC 
nhvgate = nhvgate_bz NOT POSall  //  CORE HIGH_VT NMOS

//* Define device -- nmos nch_uthvt
nuvhgate = nuvhgate_bz NOT POSall  //  CORE ULTRA High VT NMOS

//* Define device -- nmos nch_ulvt
nuvlgate = nuvlgate_bz NOT POSall  //  CORE ULTRA Low VT NMOS

//* Define device -- nmos nch_lvt_dnw
n1lvgate_bz = n1lvgate_org NOT MAC 
n1lvgate = n1lvgate_bz NOT POSall  //  CORE LOW_VT NMOS on DNW

//* Define device -- nmos nch_hvt_dnw
n1hvgate_bz = n1hvgate_org NOT MAC 
n1hvgate = n1hvgate_bz NOT POSall  //  CORE HIGH_VT NMOS on DNW

//* Define device -- nmos nch_uthvt_dnw
n1uvhgate = n1uvhgate_bz NOT POSall  //  CORE ULTRA VT NMOS on DNW

//* Define device -- nmos nch_ulvt_dnw
n1uvlgate = n1uvlgate_bz NOT POSall  //  CORE ULTRA VT NMOS on DNW

//* Define device -- nmos nch_w
ngate_1ta = tngate5 AND OD1T 
ngate_1tb = ngate_1ta NOT VTL_N 
ngate_1tc = ngate_1tb NOT VTH_N 
ngate_1td = ngate_1tc NOT UHVT_N 
ngate_1te = ngate_1td NOT ULVT_N 
ngate_1tf = ngate_1te NOT CAP1TDMY 
ngate_1tg = ngate_1tf NOT INTERACT p3 
ngate_w = ngate_1tg NOT DNW  //  1T-RAM nch_w device

//* Define device -- nmos nch_dnw_w
ngate_dnw_w = ngate_1tg AND DNW  //  1T-RAM nch_dnw_w device

//* Define device -- nmos nch_18
ngate_18a = tngate1 AND OD18 
ngate_18b = ngate_18a NOT NT_N 
ngate_18c = ngate_18b NOT DNW 
ngate_18_org = ngate_18c NOT VTL_N 
ngate_18 = ngate_18_org NOT MAC  //  I/O 1.8v NMOS

//* Define device -- nmos nch_18_dnw
dngate_18a = ngate_18b AND DNW 
dngate_18_org = dngate_18a NOT VTL_N 
dngate_18 = dngate_18_org NOT MAC  //  I/O 1.8v NMOS on DNW

//* Define device -- nmos nch_25
tngate1_nocis = tngate1 NOT CELLM 
ngate_2533s = tngate1_nocis NOT CAP_IMP  //  for nocis 2d5 & 3d3 MOS
ngate_25a = ngate_2533s AND OD25 
ngate_25b = ngate_25a NOT NT_N 
ngate_25c = ngate_25b NOT DNW 
ngate_25d = ngate_25c NOT VTL_N 
ngate_25e = ngate_25d NOT OVD 
ngate_25_org = ngate_25e NOT UDD 
ngate_25 = ngate_25_org NOT MAC  //  I/O 2.5v NMOS

//* Define device -- nmos nch_25_dnw
dngate_25a = ngate_25b AND DNW 
dngate_25b = dngate_25a NOT VTL_N 
dngate_25c = dngate_25b NOT OVD 
dngate_25_org = dngate_25c NOT UDD 
dngate_25 = dngate_25_org NOT MAC  //  I/O 2.5v NMOS on DNW

//* Define device -- nmos nch_25od
ngate_25od1 = ngate_25d AND OVD 
ngate_25od_org = ngate_25od1 NOT UDD 
ngate_25od = ngate_25od_org NOT MAC  //   overdriven 3.3V NMOS

//* Define device -- nmos nch_25od_dnw
dngate_25od1 = dngate_25b AND OVD 
dngate_25od_org = dngate_25od1 NOT UDD 
dngate_25od = dngate_25od_org NOT MAC  //   overdrived 3.3V NMOS on DNW

//* Define device -- nmos nch_33
ngate_33a = ngate_2533s AND OD33 
ngate_33b = ngate_33a NOT NT_N 
ngate_33c = ngate_33b NOT DNW 
ngate_33_org = ngate_33c NOT VTL_N 
ngate_33 = ngate_33_org NOT MAC  //  I/O 3.3v NMOS

//* Define device -- nmos nch_33_dnw
dngate_33a = ngate_33b AND DNW 
dngate_33_org = dngate_33a NOT VTL_N 
dngate_33 = dngate_33_org NOT MAC  //  I/O 3.3v NMOS on DNW

//* Define device -- nmos nch_na
nlgate1 = tngate4 AND NT_N 
nlgate2 = nlgate1 NOT VTL_N 
nlgate3 = nlgate2 NOT VTH_N 
nlgate4 = nlgate3 NOT UHVT_N 
nlgate5 = nlgate4 NOT ULVT_N 
nlgate_org = nlgate5 NOT DNW 
nlgate = nlgate_org NOT MAC  //  CORE Native Devies

//* Define device -- nmos nch_na18
ngate_18na1 = ngate_18a AND NT_N 
ngate_18na2 = ngate_18na1 NOT VTL_N 
ngate_18na_org = ngate_18na2 NOT DNW 
ngate_18na = ngate_18na_org NOT MAC  //  I/O 1.8v Native NMOS

//* Define device -- nmos nch_na25
ngate_25na1 = ngate_25a AND NT_N 
ngate_25na2 = ngate_25na1 NOT VTL_N 
ngate_25na_org = ngate_25na2 NOT DNW 
ngate_25na = ngate_25na_org NOT MAC  //  I/O 2.5v Native NMOS

//* Define device -- nmos nch_na33
ngate_33na1 = ngate_33a AND NT_N 
ngate_33na2 = ngate_33na1 NOT VTL_N 
ngate_33na_org = ngate_33na2 NOT DNW 
ngate_33na = ngate_33na_org NOT MAC  //  I/O 3.3v Native NMOS

//* Define device -- nmos nch_mac
ngate_mac_bz = ngate_org AND MAC 
ngate_mac = ngate_mac_bz NOT POSall  //  CORE SVT NMOS MACRO device

//* Define device -- nmos nch_dnw_mac
nrgate_mac_bz = nrgate_org AND MAC 
nrgate_mac = nrgate_mac_bz NOT POSall  //  CORE NMOS on DNW MACRO device

//* Define device -- nmos nch_lvt_mac
nlvgate_mac_bz = nlvgate_org AND MAC 
nlvgate_mac = nlvgate_mac_bz NOT POSall  //  CORE LOW_VT NMOS MACRO device

//* Define device -- nmos nch_lvt_dnw_mac
n1lvgate_mac_bz = n1lvgate_org AND MAC 
n1lvgate_mac = n1lvgate_mac_bz NOT POSall  //  CORE LOW_VT NMOS on DNW MACRO device

//* Define device -- nmos nch_hvt_mac
nhvgate_mac_bz = nhvgate_org AND MAC 
nhvgate_mac = nhvgate_mac_bz NOT POSall  //  CORE HIGH_VT NMOS MACRO device

//* Define device -- nmos nch_hvt_dnw_mac
n1hvgate_mac_bz = n1hvgate_org AND MAC 
n1hvgate_mac = n1hvgate_mac_bz NOT POSall  //  CORE HIGH_VT NMOS on DNW MACRO device

//* Define device -- nmos nch_18_mac
ngate_18_mac = ngate_18_org AND MAC  //  I/O 1.8v NMOS MACRO device

//* Define device -- nmos nch_18_dnw_mac
dngate_18_mac = dngate_18_org AND MAC  //  I/O 1.8v NMOS on DNW MACRO device

//* Define device -- nmos nch_25_mac
ngate_25_mac = ngate_25_org AND MAC  //  I/O 2.5v NMOS MACRO device

//* Define device -- nmos nch_25_dnw_mac
dngate_25_mac = dngate_25_org AND MAC  //  I/O 2.5v NMOS on DNW MACRO device

//* Define device -- nmos nch_25od_mac
ngate_25od_mac = ngate_25od_org AND MAC  //   overdriven 3.3V NMOS MAC

//* Define device -- nmos nch_25od_dnw_mac
dngate_25od_mac = dngate_25od_org AND MAC  //   overdrived 3.3V NMOS on DNW MAC

//* Define device -- nmos nch_33_mac
ngate_33_mac = ngate_33_org AND MAC  //  I/O 3.3v NMOS MACRO device

//* Define device -- nmos nch_33_dnw_mac
dngate_33_mac = dngate_33_org AND MAC  //  I/O 3.3v NMOS on DNW MACRO device

//* Define device -- nmos nch_na_mac
nlgate_mac = nlgate_org AND MAC  //  CORE Native Devies MACRO device

//* Define device -- nmos nch_na18_mac
ngate_18na_mac = ngate_18na_org AND MAC  //  I/O 1.8v Native NMOS MACRO device

//* Define device -- nmos nch_na25_mac
ngate_25na_mac = ngate_25na_org AND MAC  //  I/O 2.5v Native NMOS MACRO device

//* Define device -- nmos nch_na33_mac
ngate_33na_mac = ngate_33na_org AND MAC  //  I/O 3.3v Native NMOS MACRO device

//* Define device -- pmos pch
gatenw = gate_nos1 AND nxwell  //  gate inside nwell
tpgate1 = gatenw AND PP 
tpgate1a = tpgate1 NOT OD5 
tpgate2 = tpgate1a NOT OD25 
tpgate3 = tpgate2 NOT OD33 
tpgate4 = tpgate3 NOT OD18 
tpgate5 = tpgate4 NOT OD1T 
plvgate1 = tpgate5 AND VTL_P 
plvgate_org = plvgate1 NOT ULVT_P 
pgate1 = tpgate5 NOT plvgate_org 
phvgate_org = tpgate5 AND VTH_P 
pgate2 = pgate1 NOT phvgate_org 
puvhgate_bz = tpgate5 AND UHVT_P 
pgate3 = pgate2 NOT puvhgate_bz 
#IFDEF LP
puvlgate1 = tpgate5 AND VTL_P
#ELSE
puvlgate1 = COPY tpgate5
#ENDIF
puvlgate_bz = puvlgate1 AND ULVT_P 
pgate_org = pgate3 NOT puvlgate_bz 
pgate_bz = pgate_org NOT MAC 
pgate = pgate_bz NOT POSall  //  CORE SVT PMOS

//***** Define connectivity/via layer -- tpdiff ****
pthin = mdiff AND PP  //  define P+ thin oxide
tpdiff = pthin NOT gate1  //  define P+ diffusion region

//* Define device -- pmos pchpu_hvtsr
gatenw_s = gate_s1 AND nxwell  //  gate inside nwell
pgate_s1 = gatenw_s AND PP 
pgate_s2 = pgate_s1 NOT OD25 
pgate_s3 = pgate_s2 NOT OD33 
pgate_s4 = pgate_s3 NOT OD18 
pgate_s5 = pgate_s4 NOT OD5 
pgate_s6 = pgate_s5 NOT VTL_P 
pgate_s7 = pgate_s6 NOT UHVT_P 
pgate_hvs1 = pgate_s7 AND VTH_P 
pgate_hvs = pgate_hvs1 NOT SRAMULP  //  SRAM High VT PMOS

//* Define device -- pmos pch_lvt
plvgate_bz = plvgate_org NOT MAC 
plvgate = plvgate_bz NOT POSall  //  CORE LOW_VT PMOS

//* Define device -- pmos pch_mac
pgate_mac_bz = pgate_org AND MAC 
pgate_mac = pgate_mac_bz NOT POSall  //  CORE SVT PMOS MACRO device

//* Define device -- pmos pchpu_sr
pgate_s8 = pgate_s7 NOT ULVT_P 
pgate_s = pgate_s8 NOT VTH_P  //  SRAM PMOS

//* Define device -- pmos pchpu_ulpsr
pgate_ulp = pgate_hvs1 AND SRAMULP  //  ULP SRAM High VT PMOS

//* Define device -- pmos pch_hvt
phvgate_bz = phvgate_org NOT MAC 
phvgate = phvgate_bz NOT POSall  //  CORE HIGH_VT PMOS

//* Define device -- pmos pch_uthvt
puvhgate = puvhgate_bz NOT POSall  //  CORE ULTRA High VT PMOS

//* Define device -- pmos pch_ulvt
puvlgate = puvlgate_bz NOT POSall  //  CORE ULTRA Low VT PMOS

//* Define device -- pmos pch_w
pgate_1ta = tpgate4 AND OD1T 
pgate_1tb = pgate_1ta NOT VTL_P 
pgate_1tc = pgate_1tb NOT VTH_P 
pgate_1td = pgate_1tc NOT UHVT_P 
pgate_1te = pgate_1td NOT ULVT_P 
pgate_1tf = pgate_1te NOT CAP1TDMY 
pgate_w = pgate_1tf NOT INTERACT p3  //  1T-RAM pch_w   device

//* Define device -- pmos pch_1tr
pgate_1tr = pgate_1tf INTERACT p3  //  1T-RAM pch_1tr device

//* Define device -- pmos pch_18
pgate_18a = tpgate1 AND OD18 
pgate_18_org = pgate_18a NOT VTL_P 
pgate_18 = pgate_18_org NOT MAC  //  I/O 1.8v PMOS

//* Define device -- pmos pch_25
pgate_25a = tpgate1 AND OD25 
pgate_25b = pgate_25a NOT VTL_P 
pgate_25c = pgate_25b NOT OVD 
pgate_25_org = pgate_25c NOT UDD 
pgate_25 = pgate_25_org NOT MAC  //  I/O 2.5v PMOS

//* Define device -- pmos pch_25od
pgate_25od1 = pgate_25b AND OVD 
pgate_25od_org = pgate_25od1 NOT UDD 
pgate_25od = pgate_25od_org NOT MAC  //   overdriven 3.3V PMOS

//* Define device -- pmos pch_33
pgate_33a = tpgate1 AND OD33 
pgate_33_org = pgate_33a NOT VTL_P 
pgate_33 = pgate_33_org NOT MAC  //  I/O 3.3v PMOS

//* Define device -- pmos pch_lvt_mac
plvgate_mac_bz = plvgate_org AND MAC 
plvgate_mac = plvgate_mac_bz NOT POSall  //  CORE LOW_VT PMOS MACRO device

//* Define device -- pmos pch_hvt_mac
phvgate_mac_bz = phvgate_org AND MAC 
phvgate_mac = phvgate_mac_bz NOT POSall  //  CORE HIGH_VT PMOS MACRO device

//* Define device -- pmos pch_18_mac
pgate_18_mac = pgate_18_org AND MAC  //  I/O 1.8v PMOS MACRO device

//* Define device -- pmos pch_25_mac
pgate_25_mac = pgate_25_org AND MAC  //  I/O 2.5v PMOS MACRO device

//* Define device -- pmos pch_25od_mac
pgate_25od_mac = pgate_25od_org AND MAC  //   overdriven 3.3V PMOS MAC

//* Define device -- pmos pch_33_mac
pgate_33_mac = pgate_33_org AND MAC  //  I/O 3.3v PMOS MACRO device

//* Define device -- diode pdio
pdio1 = tpdiff AND DIODMY 
pdio2 = pdio1 AND nxwell 
pdio3a = pdio2 NOT OD5 
pdio3 = pdio3a NOT OD25 
pdio4 = pdio3 NOT OD33 
pdio5 = pdio4 NOT OD18 
pdio6 = pdio5 NOT VTL_P 
pdio7 = pdio6 NOT UHVT_P 
pdio8 = pdio7 NOT ULVT_P 
pdio9 = pdio8 NOT VTH_P  //  CORE P+/NW DIODE
cpdio = pdio9 NOT OD1T  //  CORE P+/NW DIODE

//* Define device -- diode nwdio
DIONW = DIODMY OUTSIDE tpdiff 
nwdio1 = nxwell AND DIONW 
cnwdio1a = nwdio1 NOT OD5 
cnwdio1 = cnwdio1a NOT OD25 
cnwdio2 = cnwdio1 NOT OD33 
cnwdio3 = cnwdio2 NOT OD18 
cnwdio = cnwdio3 NOT OD1T  //  CORE NW/PW diode

//* Define device -- diode ndio
ndio1 = tndiff AND DIODMY 
ndio2 = ndio1 AND psub 
ndio3a = ndio2 NOT OD5 
ndio3 = ndio3a NOT OD25 
ndio4 = ndio3 NOT OD33 
ndio5 = ndio4 NOT OD18 
ndio6 = ndio5 NOT NT_N 
ndio7 = ndio6 NOT VTL_N 
ndio8 = ndio7 NOT UHVT_N 
ndio9 = ndio8 NOT ULVT_N 
ndio10 = ndio9 NOT VTH_N  //  CORE N+/PW DIODE
cndio = ndio10 NOT OD1T  //  CORE N+/PW DIODE

//* Define device -- diode pdio_lvt
pdiol1 = pdio5 AND VTL_P 
pdiol = pdiol1 NOT ULVT_P  //  CORE P+/NW LOW_VT DIODE

//* Define device -- diode ndio_lvt
ndiol1 = ndio6 AND VTL_N 
ndiol = ndiol1 NOT ULVT_N  //  CORE N+/PW LOW_VT DIODE

//* Define device -- diode pdio_w
cpdio_w = pdio9 AND OD1T  //  1T-RAM P+/NW DIODE

//* Define device -- diode ndio_w
cndio_w = ndio10 AND OD1T  //  1T-RAM N+/PW DIODE

//* Define device -- diode nwdio_w
cnwdio_w = cnwdio3 AND OD1T  //  1T_MIM NW/PW diode

//* Define device -- diode pdio_hvt
pdioh = pdio5 AND VTH_P  //  CORE P+/NW HIGH_VT DIODE

//* Define device -- diode ndio_hvt
ndioh = ndio6 AND VTH_N  //  CORE N+/PW HIGH_VT DIODE

//* Define device -- diode pdio_uthvt
pdiouh = pdio5 AND UHVT_P  //  CORE P+/NW ULTRA High VT DIODE

//* Define device -- diode ndio_uthvt
ndiouh = ndio6 AND UHVT_N  //  CORE N+/PW ULTRA High VT DIODE

//* Define device -- diode pdio_ulvt
#IFDEF LP
pdioul1 = pdio5 AND VTL_P
#ELSE
pdioul1 = COPY pdio5
#ENDIF
pdioul = pdioul1 AND ULVT_P  //  CORE P+/NW ULTRA Low VT DIODE

//* Define device -- diode ndio_ulvt
#IFDEF LP
ndioul1 = ndio6 AND VTL_N
#ELSE
ndioul1 = COPY ndio6
#ENDIF
ndioul = ndioul1 AND ULVT_N  //  CORE N+/PW ULTRA Low VT DIODE

//* Define device -- diode pdio_18
ipdio_18 = pdio2 AND OD18  //  1.8v P+/NW DIODE

//* Define device -- diode ndio_18
ndio_18a = ndio2 AND OD18 
indio_18 = ndio_18a NOT NT_N  //  1.8v N+/PW diode

//* Define device -- diode pdio_25
ipdio_25a = pdio2 AND OD25  //  2.5v P+/NW DIODE
ipdio_25 = ipdio_25a NOT OVD  //   2.5v P+/NW DIODE

//* Define device -- diode ndio_25
ndio_25a = ndio2 AND OD25 
indio_25a = ndio_25a NOT NT_N  //  2.5v N+/PW diode
indio_25 = indio_25a NOT OVD  //   2.5v N+/PW diode

//* Define device -- diode pdio_25od
ipdio_25od = ipdio_25a AND OVD  //   overdriven P+/NW DIODE

//* Define device -- diode ndio_25od
indio_25od = indio_25a AND OVD  //   overdriven N+/PW diode

//* Define device -- diode pdio_33
ipdio_33 = pdio2 AND OD33  //  3.3v P+/NW DIODE

//* Define device -- diode ndio_33
ndio_33a = ndio2 AND OD33 
indio_33 = ndio_33a NOT NT_N  //  3.3v N+/PW diode

//* Define device -- diode nwdio_33
inwdio_33 = nwdio1 AND OD33  //  3.3v NW/PW diode

//* Define device -- diode nwdio_25
inwdio_25 = nwdio1 AND OD25  //  2.5v NW/PW diode

//* Define device -- diode nwdio_18
inwdio_18 = nwdio1 AND OD18  //  1.8v NW/PW diode

//* Define device -- diode ndio_na
nndio1 = ndio5 AND NT_N 
cndion1 = nndio1 NOT VTH_N 
cndion2 = cndion1 NOT VTL_N 
cndion3 = cndion2 NOT UHVT_N  //  CORE N+/PW Native DIODE
cndion = cndion3 NOT ULVT_N  //  CORE N+/PW Native DIODE

//* Define device -- diode ndio_na18
ndio_18na = ndio_18a AND NT_N  //  1.8v N+/PW native diode

//* Define device -- diode ndio_na25
ndio_25na = ndio_25a AND NT_N  //  2.5v N+/PW native diode

//* Define device -- diode ndio_na33
ndio_33na = ndio_33a AND NT_N  //  3.3v N+/PW native diode

//***** Define connectivity/via layer -- ydio_hole ****
ydio_hole = HOLES ydio 

//* Define device -- bjt pnp10
ttdiff1 = tpdiff AND BJTDMY 
ttdiff = ttdiff1 INTERACT RPO 
pre_nbase = nxwell AND BJTDMY 
nbase1 = pre_nbase NOT INTERACT DNW 
cnbase1a = nbase1 NOT OD25 
cnbase1 = cnbase1a NOT OD5  //  define CORE BJT[PV] base terminal
cemit1 = ttdiff AND cnbase1  //  define CORE BJT[PV] emitter
cemit10 = AREA cemit1  > 99.999  < 100.001 

//***** Define connectivity/via layer -- coll1 ****
collsur = psub TOUCH nbase1 
coll1a = collsur OR nbase1  //  define both BJTs collector
npnrg = DNW AND BJTDMY  //  define NPN region
nndiff1 = tndiff AND npnrg 
nndiff = nndiff1 INTERACT RPO 
pbase1 = psub AND npnrg 
cpbase1a = pbase1 NOT OD25 
cpbase1 = cpbase1a NOT OD5  //  define CORE BJT[NV] base terminal
cnemit1 = nndiff AND cpbase1  //  define CORE BJT[NV] emitter
collsura = collsur INTERACT cnemit1 
inbase1a = nbase1 AND OD25 
inbase1 = inbase1a NOT OD5  //  define I/O  BJT[P1] base terminal
inemit1 = nndiff AND inbase1  //  define I/O  BJT[N1] emitter
collsurb = collsur INTERACT inemit1 
collsurall = collsura OR collsurb 
coll1b = coll1a NOT collsurall 
coll1 = coll1b NOT cemit1  //   define pnp collector

//* Define device -- bjt pnp5
cemit5 = AREA cemit1  > 24.999  < 25.001 

//* Define device -- bjt pnp2
cemit2 = AREA cemit1  > 3.999  < 4.001 

//* Define device -- bjt npn10
cnemit10 = AREA cnemit1  > 99.999  < 100.001 

//***** Define connectivity/via layer -- ncoll1 ****
ncollrg = nxwell AND npnrg 
ncolls = ncollrg TOUCH pbase1 
ncoll1 = ncolls OR pbase1  //  define npn collector

//* Define device -- bjt npn5
cnemit5 = AREA cnemit1  > 24.999  < 25.001 

//* Define device -- bjt npn2
cnemit2 = AREA cnemit1  > 3.999  < 4.001 

//* Define device -- c CM
mim_r1 = crown AND p3 
mim_r2 = mim_r1 AND ODI 
mim_r3 = mim_r2 NOT INTERACT RPO 
mim_r = mim_r3 INTERACT blc 

//* Define device -- xdev dnwpsub
dnwdio_b = nxwell INTERACT DNW 
dnwdio_a = nxwell INSIDE DNW 
dnwdio_k = dnwdio_b NOT dnwdio_a 
dnwdio = DNW INTERACT dnwdio_k 

//***** Define connectivity/via layer -- psub_term ****
psub_term_a = psub2s NOT PSUB2 
psub_term_b = BULK NOT psub_term_a 
psub_term_c = BULK AND DNW 
psub_term_d = BULK NOT psub_term_c 
psub_term_e = psub_term_b AND psub_term_d 
psub_term = psub_term_e INTERACT DNW 

//* Define device -- xdev pwdnw
rwdio1 = DNW NOT nxwell 
rwdio = rwdio1 NOT BJTDMY 

//***** Define connectivity/via layer -- vargt ****
vargt1 = gatenw AND NP 
VAR_noRF = VAR NOT INTERACT RFDMY 
vargt2 = vargt1 AND VAR_noRF 
vargt3 = vargt2 NOT OD18 
vargt4 = vargt3 NOT OD25 
vargt5 = vargt4 NOT OD33 
vargt_tp = vargt5 NOT OD5 
vargt = vargt_tp NOT VTH_P  //  Varactor on thin oxide

//***** Define connectivity/via layer -- vargt_25 ****
vargt_25 = vargt2 AND OD25  //  Varactor on 2.5v thick oxide

//***** Define connectivity/via layer -- vargt_18 ****
vargt_18 = vargt2 AND OD18  //  Varactor on 1.8v thick oxide

//***** Define connectivity/via layer -- vargt_33 ****
vargt_33 = vargt2 AND OD33  //  Varactor on 3.3v thick oxide

//* Define device -- xdev rnwsti
trwell = NWDMY AND NW  //  N-well resistor layer
drpo1 = diff AND RPO 
drpo = drpo1 INTERACT ODI 
nwsti_r1 = trwell NOT drpo  //  NWDMY*NW-RPO-diff --> nwsti
nwsti_r = nwsti_r1 INTERACT NWDMYi  //  NWDMY*NW --> nwsti

//* Define device -- xdev rnwod
nwod_r1 = trwell AND drpo 
nwod_r = nwod_r1 INTERACT NWDMYi  //  NWDMY*NW*RPO*diff --> nwod

//* Define device -- xdev rppolywo
rppolywo_r1 = rpolywo AND PP  //  P+POLY resistor w/o silicide
RPDMYi_noRF = RPDMYi NOT INTERACT RFDMY 
rppolywo_r = rppolywo_r1 INTERACT RPDMYi_noRF  //  P+POLY resistor w/o silicide 

//* Define device -- xdev rnpolywo
rnpolywo_r1 = rpolywo AND NP  //  N+POLY resistor w/o silicide
rnpolywo_r = rnpolywo_r1 INTERACT RPDMYi_noRF  //  N+POLY resistor w/o silicide 

//* Define device -- xdev rpodwo
rpodwo_r11 = rodwo AND PP 
rpodwo_r1 = rpodwo_r11 AND NW 
rpodwo_r = rpodwo_r1 INTERACT RPDMYi  //  P+OD resistor w/o silicide

//* Define device -- xdev rnodwo
rnodwo_r11 = rodwo AND NP 
rnodwo_r1 = rnodwo_r11 NOT NW 
rnodwo_r = rnodwo_r1 INTERACT RPDMYi  //  N+OD resistor w/o silicide

//* Define device -- xdev rppolyl
rppoly = rpoly AND PP  //  ALL P+POLY resistor w/i silicide
rppoly_edge = rppoly INSIDE EDGE POI 
l_rppoly_eg = LENGTH rppoly_edge  >= 2  < 99999999 
l_rppoly = rppoly WITH EDGE l_rppoly_eg 
rppolyl_r = l_rppoly INTERACT RPDMYi_noRF  //  P+POLY resistor w/i silicide >= 2

//* Define device -- xdev rnpolyl
rnpoly = rpoly AND NP  //  ALL N+POLY resistor w/i silicide
rnpoly_edge = rnpoly INSIDE EDGE POI 
l_rnpoly_eg = LENGTH rnpoly_edge  >= 2  < 99999999 
l_rnpoly = rnpoly WITH EDGE l_rnpoly_eg 
rnpolyl_r = l_rnpoly INTERACT RPDMYi  //  N+POLY resistor w/i silicide >= 2

//* Define device -- xdev rpodl
rpod1 = rod AND PP  //  P+OD resistor w/i silicide
rpod = rpod1 AND NW  //  P+OD resistor w/i silicide
rpod_edge = rpod INSIDE EDGE diff 
l_rpod = LENGTH rpod_edge  >= 2  < 99999999 
rpodl_r1 = rpod WITH EDGE l_rpod 
rpodl_r = rpodl_r1 INTERACT RPDMYi  //  P+OD resistor w/i silicide >= 2

//* Define device -- xdev rnodl
rnod1 = rod AND NP  //  ALL N+OD resistor w/i silicide
rnod = rnod1 NOT NW  //  ALL N+OD resistor w/i silicide
rnod_edge = rnod INSIDE EDGE diff 
l_rnod = LENGTH rnod_edge  >= 2  < 99999999 
rnodl_r1 = rnod WITH EDGE l_rnod 
rnodl_r = rnodl_r1 INTERACT RPDMYi  //  N+OD resistor w/i silicide >= 2

//* Define device -- xdev rppolys
s_rppoly = rppoly NOT l_rppoly 
rppolys_r = s_rppoly INTERACT RPDMYi_noRF  //  P+POLY resistor w/i silicide <2

//* Define device -- xdev rnpolys
s_rnpoly = rnpoly NOT l_rnpoly 
rnpolys_r = s_rnpoly INTERACT RPDMYi  //  N+POLY resistor w/i silicide <2

//* Define device -- xdev rpods
rpods_r1 = rpod NOT rpodl_r1 
rpods_r = rpods_r1 INTERACT RPDMYi  //  P+OD resistor w/i silicide < 2

//* Define device -- xdev rnods
rnods_r1 = rnod NOT rnodl_r1 
rnods_r = rnods_r1 INTERACT RPDMYi  //  N+OD resistor w/i silicide < 2

//* Define device -- xdev rnwod_m
nwod_mr = nwod_r1 INTERACT NWDMY1  //  NWDMY*NW*RPO*diff --> nwod (3-terminals)

//* Define device -- xdev rnwsti_m
nwsti_mr = nwsti_r1 INTERACT NWDMY1  //  NWDMY*NW --> nwsti (3-terminals)

//* Define device -- xdev rpodwo_m
rpodwo_mr = rpodwo_r1 INTERACT RPDMY1  //  P+OD resistor w/o silicide (3-terminals).

//* Define device -- xdev rnodwo_m
rnodwo_mr = rnodwo_r1 INTERACT RPDMY1  //  N+OD resistor w/o silicide (3-terminals)

//* Define device -- xdev rpodl_m
rpodl_mr = rpodl_r1 INTERACT RPDMY1  //  P+OD resistor w/i silicide >= 2 (3-terminals)

//* Define device -- xdev rnodl_m
rnodl_mr = rnodl_r1 INTERACT RPDMY1  //  N+OD resistor w/i silicide >= 2 (3-terminals)

//* Define device -- xdev rpods_m
rpods_mr = rpods_r1 INTERACT RPDMY1  //  P+OD resistor w/i silicide < 2 (3-terminals) 

//* Define device -- xdev rnods_m
rnods_mr = rnods_r1 INTERACT RPDMY1  //  N+OD resistor w/i silicide < 2 (3-terminals)

//* Define device -- xdev rppolywo_dis
RPDMY1_noRF = RPDMY1 NOT INTERACT RFDMY 
rppolywo_d = rppolywo_r1 INTERACT RPDMY1_noRF  //  P+POLY resistor w/o silicide (3-terminals dis)

//***** Define connectivity/via layer -- poly_term ****
poly_term1 = PO AND RPDMY1 
poly_term2 = poly_term1 INTERACT POI 
poly_term3 = SIZE poly_term2 BY 0.005 
poly_term = poly_term3 NOT poly_term2 

//* Define device -- xdev rnpolywo_dis
rnpolywo_d = rnpolywo_r1 INTERACT RPDMY1_noRF  //  N+POLY resistor w/o silicide (3-terminals dis)

//* Define device -- xdev rppolyl_dis
rppolyl_d1 = l_rppoly NOT rppolyl_r 
rppolyl_d = rppolyl_d1 INTERACT RPDMY1_noRF  //  P+POLY resistor w/i silicide (3-terminal dis w >=   2um)

//* Define device -- xdev rnpolyl_dis
rnpolyl_d1 = l_rnpoly NOT rnpolyl_r 
rnpolyl_d = rnpolyl_d1 INTERACT RPDMY1  //  N+POLY resistor w/i silicide (3-terminal dis w >=   2um)

//* Define device -- xdev rppolys_dis
rppolys_d1 = s_rppoly NOT rppolys_r 
rppolys_d = rppolys_d1 INTERACT RPDMY1_noRF  //  P+POLY resistor w/i silicide (3-terminal dis w <  2um)

//* Define device -- xdev rnpolys_dis
rnpolys_d1 = s_rnpoly NOT rnpolys_r 
rnpolys_d = rnpolys_d1 INTERACT RPDMY1  //  N+POLY resistor w/i silicide (3-terminal dis w <  2um)

//* Define device -- xdev rm1
M1X = M1 OR DUM1 
M1Xc = M1X OR CO 
mt1res1 = M1Xc AND RMDMY1 
mt1res = mt1res1 INTERACT M1  //  metal1 resistor

//***** Define connectivity/via layer -- metal1 ****
metal1a = M1Xc NOT mt1res 
metal1 = metal1a NOT MOMDMY1  //  metal1 interconnect

//* Define device -- xdev rm2
M2X = M2 OR DUM2 
mt2res1 = M2X AND RMDMY2 
mt2res = mt2res1 INTERACT M2  //  metal2 resistor

//***** Define connectivity/via layer -- metal2 ****
metal2 = M2X NOT mt2res 

//* Define device -- xdev rm3
M3X = M3 OR DUM3 
mt3res1 = M3X AND RMDMY3 
mt3res = mt3res1 INTERACT M3  //  metal3 resistor

//***** Define connectivity/via layer -- metal3 ****
metal3 = M3X NOT mt3res 

//* Define device -- xdev rm4
M4X = M4 OR DUM4 
mt4res1 = M4X AND RMDMY4 
mt4res = mt4res1 INTERACT M4  //  metal4 resistor

//***** Define connectivity/via layer -- metal4 ****
metal4 = M4X NOT mt4res 

//* Define device -- xdev rm5
M5X = M5 OR DUM5 
mt5res1 = M5X AND RMDMY5 
mt5res = mt5res1 INTERACT M5  //  metal5 resistor

//***** Define connectivity/via layer -- metal5 ****
metal5 = M5X NOT mt5res 

//* Define device -- xdev rm6
M6X = M6 OR DUM6 
mt6res1 = M6X AND RMDMY6 
mt6res = mt6res1 INTERACT M6  //  metal6 resistor

//***** Define connectivity/via layer -- metal6 ****
metal6 = M6X NOT mt6res 

//* Define device -- xdev rm7
M7X = M7 OR DUM7 
IND_CT1 = SIZE IND_CTi BY -0.005 
IND_CT = IND_CT1 AND NT_N 
M7Y = M7X NOT IND_CT 
M7Z = M7Y NOT MOMDMY7 
mt7res1 = M7Z AND RMDMY7 
mt7res = mt7res1 INTERACT M7  //  metal7 resistor 

//***** Define connectivity/via layer -- metal7 ****
metal7 = M7Z NOT mt7res  //  metal7 interconnect

//* Define device -- xdev rm8
M8X = M8 OR DUM8 
IND_STD = IND_STDi AND NT_N 
IND_SYM = IND_SYMi AND NT_N 
inddmy1 = IND_STD OR IND_SYM 
INDDMY = inddmy1 OR IND_CT 
M8Y = M8X NOT INDDMY 
mt8res1 = M8Y AND RMDMY8 
mt8res = mt8res1 INTERACT M8  //  metal8 resistor

//***** Define connectivity/via layer -- metal8 ****
metal8 = M8Y NOT mt8res 

//* Define device -- xdev rm9
M9X = M9 OR DUM9 
M9Y = M9X NOT INDDMY 
mt9res1 = M9Y AND RMDMY9 
mt9res = mt9res1 INTERACT M9  //  metal9 resistor 

//***** Define connectivity/via layer -- metal9 ****
metal9 = M9Y NOT mt9res 

//* Define device -- xdev rm10
MDX = DUMMD OR MD 
#IFDEF Cu_RDL 
  M10Y = MDX NOT (SIZE MDX BY 0.005)
#ELSE
  M10Y = COPY AP
#ENDIF
#IFDEF Cu_RDL 
  mt10res_1 = MDX AND RMDMYh
  mt10res = mt10res_1 INTERACT MD  
#ELSE
  mt10res = M10Y AND RMDMYh
#ENDIF

//***** Define connectivity/via layer -- metal10 ****
#IFDEF Cu_RDL 
  metal10 = MDX NOT mt10res
#ELSE
  metal10 = M10Y NOT mt10res
#ENDIF

//* Define device -- xdev spiral_std
std_ind1 = M9X AND IND_STD 
std_ind2 = M8X AND IND_STD 
std_ind3 = std_ind1 OR std_ind2 
std_ind = std_ind3 INTERACT IND_RAD 
std_ind_m = std_ind1 AND std_ind2 

//* Define device -- xdev spiral_sym
sym_ind1 = M9X AND IND_SYM 
sym_ind2 = M8X AND IND_SYM 
sym_ind3 = sym_ind1 OR sym_ind2 
sym_ind = sym_ind3 INTERACT IND_RAD 
sym_ind_m = sym_ind1 AND sym_ind2 
ind_btm1 = sym_ind2 AND sym_ind1 
ind_btm2 = ind_btm1 INTERACT VIA8i 
ind_btm = ind_btm2 OR IND_RAD 

//* Define device -- xdev spiral_sym_ct
ct_ind1 = M9X AND IND_CT 
ct_ind2 = M8X AND IND_CT 
ct_ind4 = ct_ind1 OR ct_ind2 
ct_inda = ct_ind4 INTERACT IND_RAD 
ct_ind3 = M7X AND IND_CT 
ct_ind6 = ct_inda OR ct_ind3 
ct_ind = ct_ind6 INTERACT IND_RAD 
ct_ind_m = ct_ind1 AND ct_ind2 
ind_btm1_ct = ct_ind2 AND ct_ind1 
ind_btm2_ct = ind_btm1_ct INTERACT VIA8i 
ind_btm_ct = ind_btm2_ct OR IND_RAD 

//* Define device -- xdev nmos_rf
ngate_rf1 = gate_rf AND NP 
ngate_rf2 = ngate_rf1 NOT NT_N 
ngate_rf3 = ngate_rf2 NOT VTL_N 
ngate_rf4 = ngate_rf3 NOT VTH_N 
ngate_rf5 = ngate_rf4 INSIDE DNW 
OD2a = OD25 OR OD33 
OD2b = OD2a OR OD18 
OD2 = OD2b OR OD5 
ngate_rf = ngate_rf5 NOT OD2  //  normal RF nmos
ngate_nthin = nthin INTERACT ngate_rf 

//***** Define connectivity/via layer -- d_tndiff ****
d_tndiff = tndiff AND DRAIN 

//***** Define connectivity/via layer -- s_tndiff ****
s_tndiff1 = tndiff NOT DRAIN 
s_tndiff = s_tndiff1 INTERACT gate_rf 

//* Define device -- xdev nmos_rf18
ngate_rf_io123 = ngate_rf5 NOT ngate_rf 
ngate_nthin_io = nthin INTERACT ngate_rf_io123 
ngate_nthin_io18 = ngate_nthin_io AND OD18 
ngate_rf_18 = ngate_rf_io123 AND OD18  //  RF nmos_v1.8 

//* Define device -- xdev nmos_rf25
ngate_nthin_io25 = ngate_nthin_io AND OD25 
ngate_rf_25 = ngate_rf_io123 AND OD25  //  RF nmos_v2.5

//* Define device -- xdev nmos_rf33
ngate_nthin_io33 = ngate_nthin_io AND OD33 
ngate_rf_33 = ngate_rf_io123 AND OD33  //  RF nmos_v3.3

//* Define device -- xdev pmos_rf
pgate_rf1 = gate_rf AND PP 
pgate_rf2 = pgate_rf1 NOT NT_N 
pgate_rf3 = pgate_rf2 NOT VTL_P 
pgate_rf4 = pgate_rf3 NOT VTH_P 
pgate_rf = pgate_rf4 NOT OD2  //  normal RF pmos 
pgate_pthin = pthin INTERACT pgate_rf 

//***** Define connectivity/via layer -- d_tpdiff ****
d_tpdiff = tpdiff AND DRAIN 

//***** Define connectivity/via layer -- s_tpdiff ****
s_tpdiff1 = tpdiff NOT DRAIN 
s_tpdiff = s_tpdiff1 INTERACT gate_rf 

//* Define device -- xdev pmos_rf18
pgate_rf_io123 = pgate_rf4 NOT pgate_rf 
pgate_pthin_io = pthin INTERACT pgate_rf_io123 
pgate_pthin_io18 = pgate_pthin_io AND OD18 
pgate_rf_18 = pgate_rf_io123 AND OD18  //  RF nmos_v1.8

//* Define device -- xdev pmos_rf25
pgate_pthin_io25 = pgate_pthin_io AND OD25 
pgate_rf_25 = pgate_rf_io123 AND OD25  //  RF nmos_v2.5

//* Define device -- xdev pmos_rf33
pgate_pthin_io33 = pgate_pthin_io AND OD33 
pgate_rf_33 = pgate_rf_io123 AND OD33  //  RF nmos_v3.3

//* Define device -- xdev rppolyl_rf
rppolyl_rf1 = rppolyl_d1 NOT rppolyl_d 
rppolyl_rf = rppolyl_rf1 AND RFDMY  //  RF P+POLY resistor w/i silicide (3-terminal w >=   2um)

//* Define device -- xdev rppolys_rf
rppolys_rf1 = rppolys_d1 NOT rppolyl_d 
rppolys_rf = rppolys_rf1 AND RFDMY  //  RF P+POLY resistor w/i silicide (3-terminal w <  2um) 

//* Define device -- xdev rppolywo_rf
rppolywo_rf = rppolywo_r1 AND RFDMY  //  RF P+POLY resistor w/o silicide (3-terminals)

//* Define device -- xdev sbd_rf
SBD_RF1 = SBDDMY AND RFDMY 
SBD_RF = SBD_RF1 NOT VAR 
sbd_nw = nxwell AND SBD_RF 
schottky_n = nthin1 AND sbd_nw 
sbd_rfnw_org1 = sbd_nw INTERACT schottky_n 
pthin1 = mdiff CUT PP 
schottky_p = pthin1 AND sbd_nw 
sbd_rfnw_org = sbd_rfnw_org1 INTERACT schottky_p 
sbd_rfdnw = sbd_rfnw_org INTERACT DNW 

//* Define device -- xdev sbd_rf_nw
sbd_rfnw = sbd_rfnw_org NOT INTERACT DNW 

//* Define device -- xdev xjvar
VAR_RF1 = VAR AND RFDMY 
VAR_RF2 = VAR_RF1 NOT SBDDMY 
VAR_RF = VAR_RF2 INTERACT gate1 
XJ_RF = VAR_RF2 NOT VAR_RF 
jvar1_rf = nxwell AND XJ_RF 
jvar2_rf = jvar1_rf INTERACT tpdiff 
jvar_rf1 = jvar2_rf INTERACT tndiff 
jvar_rfdnw = jvar_rf1 AND DNW  //  xjvar for normal

//* Define device -- xdev xjvar_nw
jvar3_rf = jvar_rf1 AND tpdiff 
jvar_rf = jvar_rf1 NOT DNW  //  xjvar_nw for normal

//* Define device -- xdev moscap_rf
var_nw_rf = nxwell AND VAR_RF 
var_nw1_rf = var_nw_rf NOT OD18 
var_nw2_rf = var_nw1_rf NOT OD25 
var_nw3_rf1 = var_nw2_rf NOT OD33 
var_nw3_rf2 = var_nw3_rf1 NOT INTERACT VTH_P 
var_nw3_rf = var_nw3_rf2 AND DNW 

//* Define device -- xdev moscap_rf_nw
vargt2_rf = gate_a_rf AND VAR_RF 
vargt_rf1 = vargt2_rf NOT OD2 
vargt_rf = vargt_rf1 NOT VTH_P  //  RF Varactor on thin oxide

//* Define device -- xdev moscap_rf33_nw
poly_vargt = poly INTERACT vargt2_rf 

//* Define device -- xdev moscap_rf25
var_nw_rf25a = var_nw_rf AND OD25 
var_nw_rf25 = var_nw_rf25a AND DNW 

//* Define device -- xdev moscap_rf25_nw
vargt_rf25 = vargt2_rf AND OD25  //  RF Varactor on 2.5v thick oxide

//* Define device -- xdev moscap_rf18
var_nw_rf18a = var_nw_rf AND OD18 
var_nw_rf18 = var_nw_rf18a AND DNW 

//* Define device -- xdev moscap_rf18_nw
vargt_rf18 = vargt2_rf AND OD18  //  RF Varactor on 1.8v thick oxide

//* Define device -- xdev moscap_rf33
var_nw_rf33a = var_nw_rf AND OD33 
var_nw_rf33 = var_nw_rf33a AND DNW 
vargt_rf33 = vargt2_rf AND OD33  //  RF Varactor on 3.3v thick oxide
var_nw3_rf_nw = var_nw3_rf2 NOT DNW 
var_nw_rf25_nw = var_nw_rf25a NOT DNW 
var_nw_rf18_nw = var_nw_rf18a NOT DNW 
var_nw_rf33_nw = var_nw_rf33a NOT DNW 

//***** Define connectivity/via layer -- ydio_ass ****
ydio_ass = COPY ydio 

//***** Define connectivity/via layer -- polyCont ****
polyCont = CO INTERACT PO 

//***** Define connectivity/via layer -- mom3p1 ****
mom3p11 = metal3 AND MOMDMY23 
mom3p1 = mom3p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- MOM_field2 ****
MOM_field2 = M2 AND MOMDMY2 

//***** Define connectivity/via layer -- VIA1 ****
VIA1 = COPY VIA1i  //  VIA1

//***** Define connectivity/via layer -- MOM_field7 ****
MOM_field7 = M7 AND MOMDMY7 

//***** Define connectivity/via layer -- nxwell_npn ****
ncollsa = ncolls TOUCH cemit1 
iemit1 = ttdiff AND inbase1  //  define I/O  BJT[P1] emitter
ncollsb = ncolls TOUCH iemit1 
ncollall = ncollsa OR ncollsb 
nxwell_npn = ncolls NOT ncollall 

//***** Define connectivity/via layer -- ipbase1 ****
ipbase1a = pbase1 AND OD25 
ipbase1 = ipbase1a NOT OD5  //  define I/O  BJT[N1] base terminal

//***** Define connectivity/via layer -- mom6p1 ****
mom6p11 = metal6 AND MOMDMY23 
mom6p1 = mom6p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- odCont ****
odCont1 = CO INTERACT OD 
p3Cont = CO INTERACT p3 
odCont = odCont1 NOT p3Cont 

//***** Define connectivity/via layer -- diff_mom ****
diff_mom = OD AND MOMDMY21 

//***** Define connectivity/via layer -- nplug ****
nplug1 = tndiff AND nxwell  //  define N_well contact
nplug3 = nplug1 INTERACT CO 
tpdiffco = tpdiff INTERACT CO 
nplug2 = nplug1 INTERACT tpdiffco 
nplug = nplug3 OR nplug2  //   define N_well contact

//***** Define connectivity/via layer -- mom5m1 ****
mom5p11 = metal5 AND MOMDMY23 
mom5m1 = mom5p11 NOT INTERACT MOMDMY25 

//* Define ERC or other layers
erc_pmos_gates = tpgate1 NOT VAR 

//***** Define connectivity/via layer -- mom7p1 ****
mom7p11 = metal7 AND MOMDMY23 
mom7p1 = mom7p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom5p2 ****
mom5p21 = metal5 AND MOMDMY24 
mom5p2 = mom5p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- ntap ****
xwell = NW OUTSIDE NWDMY 
ntapx = tndiff AND xwell 
ntap1 = ntapx NOT BJTDMY 
ntap2 = ntap1 INTERACT CO 
ntap3 = ntap1 INTERACT tpdiffco 
ntap = ntap2 OR ntap3 

//***** Define connectivity/via layer -- poly_nw_via ****
poly_nw_via = poly_term AND nxwell 

//***** Define connectivity/via layer -- mom6m1 ****
mom6m1 = mom6p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- MOM_field3 ****
MOM_field3 = M3 AND MOMDMY3 
c_pmall1 = NW NOT NT_N  //   Dopping implant region of core pmo	
c_pmcore = COPY c_pmall1 
M191_1 = NW OR NT_N 
c_nmIO = OD2 NOT M191_1  //   Dopping implant region of I/O nmos
nxwell_float1 = nxwell NOT INTERACT VAR  //  exclude nwell under VAR for floating nwell check
nxwell_float = nxwell_float1 NOT INTERACT trwell  //  exclude nwell resistor for floating nwell check

//***** Define connectivity/via layer -- VIA2 ****
VIA2 = COPY VIA2i  //  VIA2

//***** Define connectivity/via layer -- MOM_field6 ****
MOM_field6 = M6 AND MOMDMY6 

//***** Define connectivity/via layer -- gate_erc ****
gate_erc1 = gate1 NOT OD25 
gate_erc2 = gate_erc1 NOT OD33 
gate_erc = gate_erc2 NOT OD5 

//***** Define connectivity/via layer -- mom5m2 ****
mom5m2 = mom5p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom7m2 ****
mom7p21 = metal7 AND MOMDMY24 
mom7m2 = mom7p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom7m1 ****
mom7m1 = mom7p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- dnwc ****
dnwc = DNW AND nxwell 

//***** Define connectivity/via layer -- tiod ****
tioda = diff NOT tpdiff 
tiodb = tioda NOT tndiff 
tiod1 = tiodb NOT PO 
tiod2 = tiod1 NOT RPO 
tiod3 = tiod2 NOT RPDMY 
tiod = tiod3 NOT NWDMY  //  RPO, RPDMY, NWDMY cut ti-od

//***** Define connectivity/via layer -- n_psub ****
rwel = psub INSIDE DNW 
nw_dnw = NW INTERACT rwel 
n_ppsub = BULK NOT nw_dnw 
n_psub = n_ppsub NOT psubband 

//***** Define connectivity/via layer -- mom4p2 ****
mom4p21 = metal4 AND MOMDMY24 
mom4p2 = mom4p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA5 ****
VIA5 = COPY VIA5i  //  VIA5
c_pmIO = c_pmall1 AND OD2  //   Dopping implant region of IO pmos

//***** Define connectivity/via layer -- mom6m2 ****
mom6p21 = metal6 AND MOMDMY24 
mom6m2 = mom6p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom7p2 ****
mom7p2 = mom7p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom4m2 ****
mom4m2 = mom4p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA3 ****
VIA3 = COPY VIA3i  //  VIA3

//***** Define connectivity/via layer -- pplug ****
pplug1 = tpdiff AND psub  //  define p_sub contact
pplug3 = pplug1 INTERACT CO 
tndiffco = tndiff INTERACT CO 
pplug2 = pplug1 INTERACT tndiffco 
pplug = pplug3 OR pplug2  //  define p_sub contact

//***** Define connectivity/via layer -- MOM_field4 ****
MOM_field4 = M4 AND MOMDMY4 

//***** Define connectivity/via layer -- mom3m2 ****
mom3p21 = metal3 AND MOMDMY24 
mom3m2 = mom3p21 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom4m1 ****
mom4p11 = metal4 AND MOMDMY23 
mom4m1 = mom4p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA4 ****
VIA4 = COPY VIA4i  //  VIA4

//***** Define connectivity/via layer -- MOM_field5 ****
MOM_field5 = M5 AND MOMDMY5 

//***** Define connectivity/via layer -- mom4p1 ****
mom4p1 = mom4p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- mom3p2 ****
mom3p2 = mom3p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA6 ****
VIA6 = COPY VIA6i  //  VIA6

//***** Define connectivity/via layer -- mom6p2 ****
mom6p2 = mom6p21 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- n_pplug ****
n_pplug1 = mdiff INTERACT CO 
n_pplug2 = n_pplug1 AND PP 
n_pplug3 = n_pplug2 NOT nxwell 
n_pplug = n_pplug3 AND n_psub 

//***** Define connectivity/via layer -- mom5p1 ****
mom5p1 = mom5p11 INTERACT MOMDMY25 

//***** Define connectivity/via layer -- poly_psub_via ****
poly_psub_via = poly_term AND psub 

//***** Define connectivity/via layer -- mom3m1 ****
mom3m1 = mom3p11 NOT INTERACT MOMDMY25 

//***** Define connectivity/via layer -- VIA9 ****
#IFDEF Cu_RDL
   VIA9 = COPY VIAD
#ELSE
   RVCBD1 = RV OR CBD
   VIA9 = RVCBD1 OR CB
#ENDIF

//***** Define connectivity/via layer -- ptap ****
ptap1 = tpdiff AND psub 
ptap2 = ptap1 INTERACT CO 
ptap3 = ptap1 INTERACT tndiffco 
ptap = ptap2 OR ptap3 

//***** Define connectivity/via layer -- MOM_field1 ****
MOM_field1 = M1 AND MOMDMY1 

//***** Define connectivity/via layer -- poly2 ****
poly2 = poly22 AND MOMDMY0 
erc_nmos_gates = tngate1 NOT VAR 
M191_dark = OD33 OR M191_1 
c_nmcore = BULK NOT M191_dark  //   Dopping implant region of core nmos
//#############################################
//# CONNECTION                                #
//#############################################
CONNECT MOM_field1 diff_mom BY odCont
CONNECT MOM_field1 metal1
CONNECT MOM_field1 poly2 BY polyCont
CONNECT MOM_field2 MOM_field1 BY VIA1
CONNECT MOM_field2 metal2
CONNECT MOM_field3 MOM_field2 BY VIA2
CONNECT MOM_field3 metal3
CONNECT MOM_field4 MOM_field3 BY VIA3
CONNECT MOM_field4 metal4
CONNECT MOM_field5 MOM_field4 BY VIA4
CONNECT MOM_field5 metal5
CONNECT MOM_field6 MOM_field5 BY VIA5
CONNECT MOM_field6 metal6
CONNECT MOM_field7 MOM_field6 BY VIA6
CONNECT MOM_field7 metal7
CONNECT cemit1 tpdiff
CONNECT cnbase1 tndiff BY nplug
CONNECT cnemit1 tndiff
CONNECT cpbase1 tpdiff BY pplug
CONNECT gate_erc poly
CONNECT iemit1 tpdiff
CONNECT inbase1 tndiff BY nplug
CONNECT inemit1 tndiff
CONNECT ipbase1 tpdiff BY pplug
CONNECT metal1 d_tndiff BY odCont
CONNECT metal1 d_tpdiff BY odCont
CONNECT metal1 p3 BY p3Cont
CONNECT metal1 poly BY polyCont
CONNECT metal1 poly2 BY polyCont
CONNECT metal1 s_tndiff BY odCont
CONNECT metal1 s_tpdiff BY odCont
CONNECT metal1 schottky_n BY odCont
CONNECT metal1 schottky_p BY odCont
CONNECT metal1 tndiff BY odCont
CONNECT metal1 tpdiff BY odCont
CONNECT metal10 metal9 BY VIA9
CONNECT metal2 metal1 BY VIA1
CONNECT metal3 metal2 BY VIA2
CONNECT metal3 mom3m1
CONNECT metal3 mom3m2
CONNECT metal3 mom3p1
CONNECT metal3 mom3p2
CONNECT metal4 metal3 BY VIA3
CONNECT metal4 mom4m1
CONNECT metal4 mom4m2
CONNECT metal4 mom4p1
CONNECT metal4 mom4p2
CONNECT metal5 metal4 BY VIA4
CONNECT metal5 mom5m1
CONNECT metal5 mom5m2
CONNECT metal5 mom5p1
CONNECT metal5 mom5p2
CONNECT metal6 metal5 BY VIA5
CONNECT metal6 mom6m1
CONNECT metal6 mom6m2
CONNECT metal6 mom6p1
CONNECT metal6 mom6p2
CONNECT metal7 metal6 BY VIA6
CONNECT metal7 mom7m1
CONNECT metal7 mom7m2
CONNECT metal7 mom7p1
CONNECT metal7 mom7p2
CONNECT metal8 metal7 BY VIA7
CONNECT n_pplug tpdiff
CONNECT ncoll1 nxwell_npn
CONNECT nplug tndiff
CONNECT ntap tndiff
CONNECT poly poly2
CONNECT poly vargt
CONNECT poly vargt_18
CONNECT poly vargt_25
CONNECT poly vargt_33
CONNECT poly_rf poly
CONNECT pplug tpdiff
CONNECT ptap tpdiff
CONNECT tiod tndiff
CONNECT tiod tpdiff
CONNECT tndiff crown BY blc
CONNECT tndiff nxwell_npn BY nplug
CONNECT tndiff tpdiff
CONNECT tndiff ydio_ass
CONNECT tndiff ydio_hole
CONNECT tpdiff crown BY blc

#IFDEF RC_DECK
CONNECT  poly gate
CONNECT  nxwell poly_term BY poly_nw_via
CONNECT  nxwell DNW BY dnwc
CONNECT  psub poly_term BY poly_psub_via
CONNECT  tpdiff psub_term BY pplug
CONNECT  tpdiff psub BY pplug
CONNECT  tpdiff coll1 BY pplug
CONNECT  tndiff nxwell BY nplug
#ELSE
SCONNECT nxwell poly_term BY poly_nw_via
SCONNECT nxwell DNW BY dnwc
SCONNECT psub poly_term BY poly_psub_via
#IFNDEF NW_RING
  SCONNECT tpdiff n_psub BY n_pplug
#ENDIF
SCONNECT tpdiff psub_term BY pplug
SCONNECT tpdiff psub BY pplug
SCONNECT tpdiff coll1 BY pplug
SCONNECT tndiff nxwell BY nplug
#ENDIF
//#############################################
//# FORM DEVICE                               #
//#############################################

#IFDEF RC_DECK

#IFDEF DFM_RULE
INCLUDE ./DFM/dfm_device

ngatez1 = SIZE ngate BY 0.005
ngatez = ngatez1 AND nthin1
DEVICE MN(nch) ngatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch BY SHAPE CMACRO dfm_nmos_core

ngate_18_aux = ( SIZE ngate_18 BY WPED ) AND c_nmIO
DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18_aux> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2
   L=area(ngate_18) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18,ngate_18_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18,ngate_18_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_18_aux = ( SIZE dngate_18 BY WPED ) AND c_nmIO
DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_18_aux> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2
   L=area(dngate_18) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_18,dngate_18_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_18,dngate_18_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_18_mac_aux = ( SIZE dngate_18_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_18_mac_aux> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2
   L=area(dngate_18_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_18_mac,dngate_18_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_18_mac,dngate_18_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_18_mac_aux = ( SIZE ngate_18_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18_mac_aux> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2
   L=area(ngate_18_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18_mac,ngate_18_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18_mac,ngate_18_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25_aux = ( SIZE ngate_25 BY WPED ) AND c_nmIO
DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_25_aux> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2
   L=area(ngate_25) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25,ngate_25_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25,ngate_25_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25_aux = ( SIZE dngate_25 BY WPED ) AND c_nmIO
DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25_aux> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2
   L=area(dngate_25) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25,dngate_25_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25,dngate_25_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25_mac_aux = ( SIZE dngate_25_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25_mac_aux> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2
   L=area(dngate_25_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25_mac,dngate_25_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25_mac,dngate_25_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25_mac_aux = ( SIZE ngate_25_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_25_mac_aux> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2
   L=area(ngate_25_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25_mac,ngate_25_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25_mac,ngate_25_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25od_aux = ( SIZE ngate_25od BY WPED ) AND c_nmIO
DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25od_aux> netlist model nch_25od [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2
   L=area(ngate_25od) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25od,ngate_25od_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25od,ngate_25od_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25od_aux = ( SIZE dngate_25od BY WPED ) AND c_nmIO
DEVICE MN(nch_25od_dnw) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25od_aux> netlist model nch_25od [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2
   L=area(dngate_25od) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25od,dngate_25od_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25od,dngate_25od_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25od_mac_aux = ( SIZE dngate_25od_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_25od_dnw) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25od_mac_aux> netlist model nch_25od_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2
   L=area(dngate_25od_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25od_mac,dngate_25od_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25od_mac,dngate_25od_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25od_mac_aux = ( SIZE ngate_25od_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25od_mac_aux> netlist model nch_25od_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2
   L=area(ngate_25od_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25od_mac,ngate_25od_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25od_mac,ngate_25od_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33_aux = ( SIZE ngate_33 BY WPED ) AND c_nmIO
DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33_aux> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2
   L=area(ngate_33) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33,ngate_33_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33,ngate_33_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_33_aux = ( SIZE dngate_33 BY WPED ) AND c_nmIO
DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_33_aux> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2
   L=area(dngate_33) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_33,dngate_33_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_33,dngate_33_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_33_mac_aux = ( SIZE dngate_33_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_33_mac_aux> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2
   L=area(dngate_33_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_33_mac,dngate_33_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_33_mac,dngate_33_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33_mac_aux = ( SIZE ngate_33_mac BY WPED ) AND c_nmIO
DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33_mac_aux> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2
   L=area(ngate_33_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33_mac,ngate_33_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33_mac,ngate_33_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nrgatez1 = SIZE nrgate BY 0.005
nrgatez = nrgatez1 AND nthin1
DEVICE MN(nch_dnw) nrgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch BY SHAPE CMACRO dfm_nmos_core

nrgate_macz1 = SIZE nrgate_mac BY 0.005
nrgate_macz = nrgate_macz1 AND nthin1
DEVICE MN(nch_dnw) nrgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mac BY SHAPE netlist element "X" CMACRO dfm_nmos_core

ngate_dnw_w_aux = ( SIZE ngate_dnw_w BY WPED ) AND c_nmcore
DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_dnw_w_aux> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2
   L=area(ngate_dnw_w) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_dnw_w,ngate_dnw_w_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_dnw_w,ngate_dnw_w_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nhvgatez1 = SIZE nhvgate BY 0.005
nhvgatez = nhvgatez1 AND nthin1
DEVICE MN(nch_hvt) nhvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt BY SHAPE CMACRO dfm_nmos_core

n1hvgatez1 = SIZE n1hvgate BY 0.005
n1hvgatez = n1hvgatez1 AND nthin1
DEVICE MN(nch_hvt_dnw) n1hvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt BY SHAPE CMACRO dfm_nmos_core

n1hvgate_macz1 = SIZE n1hvgate_mac BY 0.005
n1hvgate_macz = n1hvgate_macz1 AND nthin1
DEVICE MN(nch_hvt_dnw) n1hvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt_mac BY SHAPE netlist element "X" CMACRO dfm_nmos_core

nhvgate_macz1 = SIZE nhvgate_mac BY 0.005
nhvgate_macz = nhvgate_macz1 AND nthin1
DEVICE MN(nch_hvt) nhvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_hvt_mac BY SHAPE netlist element "X" CMACRO dfm_nmos_core

nlvgatez1 = SIZE nlvgate BY 0.005
nlvgatez = nlvgatez1 AND nthin1
DEVICE MN(nch_lvt) nlvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt BY SHAPE CMACRO dfm_nmos_core

n1lvgatez1 = SIZE n1lvgate BY 0.005
n1lvgatez = n1lvgatez1 AND nthin1
DEVICE MN(nch_lvt_dnw) n1lvgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt BY SHAPE CMACRO dfm_nmos_core

n1lvgate_macz1 = SIZE n1lvgate_mac BY 0.005
n1lvgate_macz = n1lvgate_macz1 AND nthin1
DEVICE MN(nch_lvt_dnw) n1lvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt_mac BY SHAPE netlist element "X" CMACRO dfm_nmos_core

nlvgate_macz1 = SIZE nlvgate_mac BY 0.005
nlvgate_macz = nlvgate_macz1 AND nthin1
DEVICE MN(nch_lvt) nlvgate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_lvt_mac BY SHAPE netlist element "X" CMACRO dfm_nmos_core

ngate_macz1 = SIZE ngate_mac BY 0.005
ngate_macz = ngate_macz1 AND nthin1
DEVICE MN(nch) ngate_macz poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_mac BY SHAPE netlist element "X" CMACRO dfm_nmos_core

nlgate_aux = ( SIZE nlgate BY WPED ) AND NT_N
DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nlgate_aux> netlist model nch_na [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L=area(nlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlgate,nlgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlgate,nlgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_18na_aux = ( SIZE ngate_18na BY WPED ) AND NT_N
DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18na_aux> netlist model nch_na18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2
   L=area(ngate_18na) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18na,ngate_18na_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18na,ngate_18na_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_18na_mac_aux = ( SIZE ngate_18na_mac BY WPED ) AND NT_N
DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18na_mac_aux> netlist model nch_na18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2
   L=area(ngate_18na_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18na_mac,ngate_18na_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18na_mac,ngate_18na_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25na_aux = ( SIZE ngate_25na BY WPED ) AND NT_N
DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25na_aux> netlist model nch_na25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2
   L=area(ngate_25na) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25na,ngate_25na_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25na,ngate_25na_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25na_mac_aux = ( SIZE ngate_25na_mac BY WPED ) AND NT_N
DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25na_mac_aux> netlist model nch_na25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2
   L=area(ngate_25na_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25na_mac,ngate_25na_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25na_mac,ngate_25na_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33na_aux = ( SIZE ngate_33na BY WPED ) AND NT_N
DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33na_aux> netlist model nch_na33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2
   L=area(ngate_33na) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33na,ngate_33na_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33na,ngate_33na_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33na_mac_aux = ( SIZE ngate_33na_mac BY WPED ) AND NT_N
DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33na_mac_aux> netlist model nch_na33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2
   L=area(ngate_33na_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33na_mac,ngate_33na_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33na_mac,ngate_33na_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nlgate_mac_aux = ( SIZE nlgate_mac BY WPED ) AND NT_N
DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nlgate_mac_aux> netlist model nch_na_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L=area(nlgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlgate_mac,nlgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlgate_mac,nlgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nuvlgatez1 = SIZE nuvlgate BY 0.005
nuvlgatez = nuvlgatez1 AND nthin1
DEVICE MN(nch_ulvt) nuvlgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_ulvt BY SHAPE CMACRO dfm_nmos_core

n1uvlgatez1 = SIZE n1uvlgate BY 0.005
n1uvlgatez = n1uvlgatez1 AND nthin1
DEVICE MN(nch_ulvt_dnw) n1uvlgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_ulvt BY SHAPE CMACRO dfm_nmos_core

nuvhgatez1 = SIZE nuvhgate BY 0.005
nuvhgatez = nuvhgatez1 AND nthin1
DEVICE MN(nch_uthvt) nuvhgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_uthvt BY SHAPE CMACRO dfm_nmos_core

n1uvhgatez1 = SIZE n1uvhgate BY 0.005
n1uvhgatez = n1uvhgatez1 AND nthin1
DEVICE MN(nch_uthvt_dnw) n1uvhgatez poly(G) tndiff(S) tndiff(D) psub(B) netlist model nch_uthvt BY SHAPE CMACRO dfm_nmos_core

ngate_w_aux = ( SIZE ngate_w BY WPED ) AND c_nmcore
DEVICE MN(nch_w) ngate_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_w_aux> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_w, tndiff ) + perimeter_inside(ngate_w, tndiff)) / 2
   L=area(ngate_w) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_w,ngate_w_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_w,ngate_w_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2
   L=area(ngate_hvspd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2
   L=area(ngate_spd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_ulpsr) ngate_ulppd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_ulppd, tndiff ) + perimeter_inside(ngate_ulppd, tndiff)) / 2
   L=area(ngate_ulppd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2
   L=area(ngate_hvspg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2
   L=area(ngate_spg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_ulpsr) ngate_ulppg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(ngate_ulppg, tndiff ) + perimeter_inside(ngate_ulppg, tndiff)) / 2
   L=area(ngate_ulppg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

pgatez1 = SIZE pgate BY 0.005
pgatez = pgatez1 AND pthin
DEVICE MP(pch) pgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch BY SHAPE CMACRO dfm_pmos

pgate_18_aux = ( SIZE pgate_18 BY WPED ) AND c_pmIO
DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_18_aux> netlist model pch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2
   L=area(pgate_18) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_18,pgate_18_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_18,pgate_18_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_18_mac_aux = ( SIZE pgate_18_mac BY WPED ) AND c_pmIO
DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_18_mac_aux> netlist model pch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2
   L=area(pgate_18_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_18_mac,pgate_18_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_18_mac,pgate_18_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_1tr_aux = ( SIZE pgate_1tr BY WPED ) AND c_pmcore
DEVICE MP(pch_1tr) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_1tr_aux> netlist model pch_1tr [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2
   L=area(pgate_1tr) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_1tr,pgate_1tr_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_1tr,pgate_1tr_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25_aux = ( SIZE pgate_25 BY WPED ) AND c_pmIO
DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25_aux> netlist model pch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2
   L=area(pgate_25) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25,pgate_25_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25,pgate_25_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25_mac_aux = ( SIZE pgate_25_mac BY WPED ) AND c_pmIO
DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25_mac_aux> netlist model pch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2
   L=area(pgate_25_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25_mac,pgate_25_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25_mac,pgate_25_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25od_aux = ( SIZE pgate_25od BY WPED ) AND c_pmIO
DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25od_aux> netlist model pch_25od [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2
   L=area(pgate_25od) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25od,pgate_25od_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25od,pgate_25od_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25od_mac_aux = ( SIZE pgate_25od_mac BY WPED ) AND c_pmIO
DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25od_mac_aux> netlist model pch_25od_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2
   L=area(pgate_25od_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25od_mac,pgate_25od_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25od_mac,pgate_25od_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_33_aux = ( SIZE pgate_33 BY WPED ) AND c_pmIO
DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_33_aux> netlist model pch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2
   L=area(pgate_33) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_33,pgate_33_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_33,pgate_33_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_33_mac_aux = ( SIZE pgate_33_mac BY WPED ) AND c_pmIO
DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_33_mac_aux> netlist model pch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2
   L=area(pgate_33_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_33_mac,pgate_33_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_33_mac,pgate_33_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

phvgatez1 = SIZE phvgate BY 0.005
phvgatez = phvgatez1 AND pthin
DEVICE MP(pch_hvt) phvgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_hvt BY SHAPE CMACRO dfm_pmos

phvgate_macz1 = SIZE phvgate_mac BY 0.005
phvgate_macz = phvgate_macz1 AND pthin
DEVICE MP(pch_hvt) phvgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_hvt_mac BY SHAPE netlist element "X" CMACRO dfm_pmos

plvgatez1 = SIZE plvgate BY 0.005
plvgatez = plvgatez1 AND pthin
DEVICE MP(pch_lvt) plvgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_lvt BY SHAPE CMACRO dfm_pmos

plvgate_macz1 = SIZE plvgate_mac BY 0.005
plvgate_macz = plvgate_macz1 AND pthin
DEVICE MP(pch_lvt) plvgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_lvt_mac BY SHAPE netlist element "X" CMACRO dfm_pmos

pgate_macz1 = SIZE pgate_mac BY 0.005
pgate_macz = pgate_macz1 AND pthin
DEVICE MP(pch) pgate_macz poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_mac BY SHAPE netlist element "X" CMACRO dfm_pmos

puvlgatez1 = SIZE puvlgate BY 0.005
puvlgatez = puvlgatez1 AND pthin
DEVICE MP(pch_ulvt) puvlgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_ulvt BY SHAPE CMACRO dfm_pmos

puvhgatez1 = SIZE puvhgate BY 0.005
puvhgatez = puvhgatez1 AND pthin
DEVICE MP(pch_uthvt) puvhgatez poly(G) tpdiff(S) tpdiff(D) nxwell(B) netlist model pch_uthvt BY SHAPE CMACRO dfm_pmos

pgate_w_aux = ( SIZE pgate_w BY WPED ) AND c_pmcore
DEVICE MP(pch_w) pgate_w poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_w_aux> netlist model pch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT  = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_w, tpdiff ) + perimeter_inside(pgate_w, tpdiff)) / 2
   L=area(pgate_w) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_w,pgate_w_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_w,pgate_w_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2
   L=area(pgate_hvs) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2
   L=area(pgate_s) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_ulpsr) pgate_ulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W=(perimeter_coincide(pgate_ulp, tpdiff ) + perimeter_inside(pgate_ulp, tpdiff)) / 2
   L=area(pgate_ulp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]


#ELSE
ngate_aux = (SIZE ngate BY WPED) AND c_nmcore
DEVICE MN(nch) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_aux> netlist model nch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L = area(ngate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate,ngate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate,ngate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_18_aux = (SIZE ngate_18 BY WPED) AND c_nmIO
DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18_aux> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2
   L = area(ngate_18) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18,ngate_18_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18,ngate_18_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_18_aux = (SIZE dngate_18 BY WPED) AND c_nmIO
DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_18_aux> netlist model nch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2
   L = area(dngate_18) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_18,dngate_18_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_18,dngate_18_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_18_mac_aux = (SIZE dngate_18_mac BY WPED) AND c_nmIO
DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_18_mac_aux> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2
   L = area(dngate_18_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_18_mac,dngate_18_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_18_mac,dngate_18_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_18_mac_aux = (SIZE ngate_18_mac BY WPED) AND c_nmIO
DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18_mac_aux> netlist model nch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2
   L = area(ngate_18_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18_mac,ngate_18_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18_mac,ngate_18_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25_aux = (SIZE ngate_25 BY WPED) AND c_nmIO
DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_25_aux> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2
   L = area(ngate_25) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25,ngate_25_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25,ngate_25_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25_aux = (SIZE dngate_25 BY WPED) AND c_nmIO
DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25_aux> netlist model nch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2
   L = area(dngate_25) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25,dngate_25_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25,dngate_25_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25_mac_aux = (SIZE dngate_25_mac BY WPED) AND c_nmIO
DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25_mac_aux> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2
   L = area(dngate_25_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25_mac,dngate_25_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25_mac,dngate_25_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25_mac_aux = (SIZE ngate_25_mac BY WPED) AND c_nmIO
DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> <OD> <ngate_25_mac_aux> netlist model nch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2
   L = area(ngate_25_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin)
   PI_D_OD = perimeter_inside(D,nthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25_mac,ngate_25_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25_mac,ngate_25_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25od_aux = (SIZE ngate_25od BY WPED) AND c_nmIO
DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25od_aux> netlist model nch_25od [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2
   L = area(ngate_25od) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25od,ngate_25od_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25od,ngate_25od_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25od_aux = (SIZE dngate_25od BY WPED) AND c_nmIO
DEVICE MN(nch_25od_dnw) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25od_aux> netlist model nch_25od [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2
   L = area(dngate_25od) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25od,dngate_25od_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25od,dngate_25od_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_25od_mac_aux = (SIZE dngate_25od_mac BY WPED) AND c_nmIO
DEVICE MN(nch_25od_dnw) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_25od_mac_aux> netlist model nch_25od_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2
   L = area(dngate_25od_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_25od_mac,dngate_25od_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_25od_mac,dngate_25od_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25od_mac_aux = (SIZE ngate_25od_mac BY WPED) AND c_nmIO
DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25od_mac_aux> netlist model nch_25od_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2
   L = area(ngate_25od_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25od_mac,ngate_25od_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25od_mac,ngate_25od_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33_aux = (SIZE ngate_33 BY WPED) AND c_nmIO
DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33_aux> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2
   L = area(ngate_33) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33,ngate_33_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33,ngate_33_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_33_aux = (SIZE dngate_33 BY WPED) AND c_nmIO
DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_33_aux> netlist model nch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2
   L = area(dngate_33) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_33,dngate_33_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_33,dngate_33_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

dngate_33_mac_aux = (SIZE dngate_33_mac BY WPED) AND c_nmIO
DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <dngate_33_mac_aux> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2
   L = area(dngate_33_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(dngate_33_mac,dngate_33_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(dngate_33_mac,dngate_33_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33_mac_aux = (SIZE ngate_33_mac BY WPED) AND c_nmIO
DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33_mac_aux> netlist model nch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2
   L = area(ngate_33_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33_mac,ngate_33_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33_mac,ngate_33_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nrgate_aux = (SIZE nrgate BY WPED) AND c_nmcore
DEVICE MN(nch_dnw) nrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nrgate_aux> netlist model nch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2
   L = area(nrgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nrgate,nrgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nrgate,nrgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nrgate_mac_aux = (SIZE nrgate_mac BY WPED) AND c_nmcore
DEVICE MN(nch_dnw) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nrgate_mac_aux> netlist model nch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2
   L = area(nrgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nrgate_mac,nrgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nrgate_mac,nrgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_dnw_w_aux = (SIZE ngate_dnw_w BY WPED) AND c_nmcore
DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_dnw_w_aux> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2
   L = area(ngate_dnw_w) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_dnw_w,ngate_dnw_w_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_dnw_w,ngate_dnw_w_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nhvgate_aux = (SIZE nhvgate BY WPED) AND c_nmcore
DEVICE MN(nch_hvt) nhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nhvgate_aux> netlist model nch_hvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nhvgate, tndiff ) + perimeter_inside(nhvgate, tndiff)) / 2
   L = area(nhvgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nhvgate,nhvgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nhvgate,nhvgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

n1hvgate_aux = (SIZE n1hvgate BY WPED) AND c_nmcore
DEVICE MN(nch_hvt_dnw) n1hvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <n1hvgate_aux> netlist model nch_hvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1hvgate, tndiff ) + perimeter_inside(n1hvgate, tndiff)) / 2
   L = area(n1hvgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(n1hvgate,n1hvgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(n1hvgate,n1hvgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

n1hvgate_mac_aux = (SIZE n1hvgate_mac BY WPED) AND c_nmcore
DEVICE MN(nch_hvt_dnw) n1hvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <n1hvgate_mac_aux> netlist model nch_hvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1hvgate_mac, tndiff ) + perimeter_inside(n1hvgate_mac, tndiff)) / 2
   L = area(n1hvgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(n1hvgate_mac,n1hvgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(n1hvgate_mac,n1hvgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nhvgate_mac_aux = (SIZE nhvgate_mac BY WPED) AND c_nmcore
DEVICE MN(nch_hvt) nhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nhvgate_mac_aux> netlist model nch_hvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nhvgate_mac, tndiff ) + perimeter_inside(nhvgate_mac, tndiff)) / 2
   L = area(nhvgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nhvgate_mac,nhvgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nhvgate_mac,nhvgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nlvgate_aux = (SIZE nlvgate BY WPED) AND c_nmcore
DEVICE MN(nch_lvt) nlvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nlvgate_aux> netlist model nch_lvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlvgate, tndiff ) + perimeter_inside(nlvgate, tndiff)) / 2
   L = area(nlvgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlvgate,nlvgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlvgate,nlvgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

n1lvgate_aux = (SIZE n1lvgate BY WPED) AND c_nmcore
DEVICE MN(nch_lvt_dnw) n1lvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <n1lvgate_aux> netlist model nch_lvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1lvgate, tndiff ) + perimeter_inside(n1lvgate, tndiff)) / 2
   L = area(n1lvgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(n1lvgate,n1lvgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(n1lvgate,n1lvgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

n1lvgate_mac_aux = (SIZE n1lvgate_mac BY WPED) AND c_nmcore
DEVICE MN(nch_lvt_dnw) n1lvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <n1lvgate_mac_aux> netlist model nch_lvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1lvgate_mac, tndiff ) + perimeter_inside(n1lvgate_mac, tndiff)) / 2
   L = area(n1lvgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(n1lvgate_mac,n1lvgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(n1lvgate_mac,n1lvgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nlvgate_mac_aux = (SIZE nlvgate_mac BY WPED) AND c_nmcore
DEVICE MN(nch_lvt) nlvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nlvgate_mac_aux> netlist model nch_lvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlvgate_mac, tndiff ) + perimeter_inside(nlvgate_mac, tndiff)) / 2
   L = area(nlvgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlvgate_mac,nlvgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlvgate_mac,nlvgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_mac_aux = (SIZE ngate_mac BY WPED) AND c_nmcore
DEVICE MN(nch) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_mac_aux> netlist model nch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2
   L = area(ngate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_mac,ngate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_mac,ngate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nlgate_aux = (SIZE nlgate BY WPED) AND NT_N
DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nlgate_aux> netlist model nch_na [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L = area(nlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlgate,nlgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlgate,nlgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_18na_aux = (SIZE ngate_18na BY WPED) AND NT_N
DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18na_aux> netlist model nch_na18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2
   L = area(ngate_18na) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18na,ngate_18na_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18na,ngate_18na_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_18na_mac_aux = (SIZE ngate_18na_mac BY WPED) AND NT_N
DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_18na_mac_aux> netlist model nch_na18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2
   L = area(ngate_18na_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_18na_mac,ngate_18na_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_18na_mac,ngate_18na_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25na_aux = (SIZE ngate_25na BY WPED) AND NT_N
DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25na_aux> netlist model nch_na25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2
   L = area(ngate_25na) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25na,ngate_25na_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25na,ngate_25na_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_25na_mac_aux = (SIZE ngate_25na_mac BY WPED) AND NT_N
DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_25na_mac_aux> netlist model nch_na25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2
   L = area(ngate_25na_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_25na_mac,ngate_25na_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_25na_mac,ngate_25na_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33na_aux = (SIZE ngate_33na BY WPED) AND NT_N
DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33na_aux> netlist model nch_na33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2
   L = area(ngate_33na) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33na,ngate_33na_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33na,ngate_33na_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_33na_mac_aux = (SIZE ngate_33na_mac BY WPED) AND NT_N
DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_33na_mac_aux> netlist model nch_na33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2
   L = area(ngate_33na_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_33na_mac,ngate_33na_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_33na_mac,ngate_33na_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nlgate_mac_aux = (SIZE nlgate_mac BY WPED) AND NT_N
DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nlgate_mac_aux> netlist model nch_na_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L = area(nlgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nlgate_mac,nlgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nlgate_mac,nlgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nuvlgate_aux = (SIZE nuvlgate BY WPED) AND c_nmcore
DEVICE MN(nch_ulvt) nuvlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nuvlgate_aux> netlist model nch_ulvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nuvlgate, tndiff ) + perimeter_inside(nuvlgate, tndiff)) / 2
   L = area(nuvlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nuvlgate,nuvlgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nuvlgate,nuvlgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

n1uvlgate_aux = (SIZE n1uvlgate BY WPED) AND c_nmcore
DEVICE MN(nch_ulvt_dnw) n1uvlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <n1uvlgate_aux> netlist model nch_ulvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1uvlgate, tndiff ) + perimeter_inside(n1uvlgate, tndiff)) / 2
   L = area(n1uvlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(n1uvlgate,n1uvlgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(n1uvlgate,n1uvlgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

nuvhgate_aux = (SIZE nuvhgate BY WPED) AND c_nmcore
DEVICE MN(nch_uthvt) nuvhgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <nuvhgate_aux> netlist model nch_uthvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(nuvhgate, tndiff ) + perimeter_inside(nuvhgate, tndiff)) / 2
   L = area(nuvhgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(nuvhgate,nuvhgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(nuvhgate,nuvhgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

n1uvhgate_aux = (SIZE n1uvhgate BY WPED) AND c_nmcore
DEVICE MN(nch_uthvt_dnw) n1uvhgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <n1uvhgate_aux> netlist model nch_uthvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(n1uvhgate, tndiff ) + perimeter_inside(n1uvhgate, tndiff)) / 2
   L = area(n1uvhgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(n1uvhgate,n1uvhgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(n1uvhgate,n1uvhgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

ngate_w_aux = (SIZE ngate_w BY WPED) AND c_nmcore
DEVICE MN(nch_w) ngate_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> <OD> <ngate_w_aux> netlist model nch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = 0
   BOT_EXT = NMOS_BOT_EXT
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_w, tndiff ) + perimeter_inside(ngate_w, tndiff)) / 2
   L = area(ngate_w) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(ngate_w,ngate_w_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(ngate_w,ngate_w_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2
   L = area(ngate_hvspd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2
   L = area(ngate_spd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpd_ulpsr) ngate_ulppd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpd_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_ulppd, tndiff ) + perimeter_inside(ngate_ulppd, tndiff)) / 2
   L = area(ngate_ulppd) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2
   L = area(ngate_hvspg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2
   L = area(ngate_spg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MN(nchpg_ulpsr) ngate_ulppg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> netlist model nchpg_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(ngate_ulppg, tndiff ) + perimeter_inside(ngate_ulppg, tndiff)) / 2
   L = area(ngate_ulppg) / W
   PI_S_OD = perimeter_inside(S,nthin1)
   PI_D_OD = perimeter_inside(D,nthin1)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

pgate_aux = (SIZE pgate BY WPED) AND c_pmcore
DEVICE MP(pch) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_aux> netlist model pch [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2
   L = area(pgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate,pgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate,pgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_18_aux = (SIZE pgate_18 BY WPED) AND c_pmIO
DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_18_aux> netlist model pch_18 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2
   L = area(pgate_18) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_18,pgate_18_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_18,pgate_18_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_18_mac_aux = (SIZE pgate_18_mac BY WPED) AND c_pmIO
DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_18_mac_aux> netlist model pch_18_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2
   L = area(pgate_18_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_18_mac,pgate_18_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_18_mac,pgate_18_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_1tr_aux = (SIZE pgate_1tr BY WPED) AND c_pmcore
DEVICE MP(pch_1tr) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_1tr_aux> netlist model pch_1tr [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2
   L = area(pgate_1tr) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_1tr,pgate_1tr_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_1tr,pgate_1tr_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25_aux = (SIZE pgate_25 BY WPED) AND c_pmIO
DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25_aux> netlist model pch_25 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2
   L = area(pgate_25) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25,pgate_25_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25,pgate_25_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25_mac_aux = (SIZE pgate_25_mac BY WPED) AND c_pmIO
DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25_mac_aux> netlist model pch_25_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2
   L = area(pgate_25_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25_mac,pgate_25_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25_mac,pgate_25_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25od_aux = (SIZE pgate_25od BY WPED) AND c_pmIO
DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25od_aux> netlist model pch_25od [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2
   L = area(pgate_25od) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25od,pgate_25od_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25od,pgate_25od_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_25od_mac_aux = (SIZE pgate_25od_mac BY WPED) AND c_pmIO
DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_25od_mac_aux> netlist model pch_25od_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2
   L = area(pgate_25od_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_25od_mac,pgate_25od_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_25od_mac,pgate_25od_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_33_aux = (SIZE pgate_33 BY WPED) AND c_pmIO
DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_33_aux> netlist model pch_33 [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2
   L = area(pgate_33) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_33,pgate_33_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_33,pgate_33_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_33_mac_aux = (SIZE pgate_33_mac BY WPED) AND c_pmIO
DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_33_mac_aux> netlist model pch_33_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2
   L = area(pgate_33_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_33_mac,pgate_33_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_33_mac,pgate_33_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

phvgate_aux = (SIZE phvgate BY WPED) AND c_pmcore
DEVICE MP(pch_hvt) phvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <phvgate_aux> netlist model pch_hvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(phvgate, tpdiff ) + perimeter_inside(phvgate, tpdiff)) / 2
   L = area(phvgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(phvgate,phvgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(phvgate,phvgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

phvgate_mac_aux = (SIZE phvgate_mac BY WPED) AND c_pmcore
DEVICE MP(pch_hvt) phvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <phvgate_mac_aux> netlist model pch_hvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(phvgate_mac, tpdiff ) + perimeter_inside(phvgate_mac, tpdiff)) / 2
   L = area(phvgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(phvgate_mac,phvgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(phvgate_mac,phvgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

plvgate_aux = (SIZE plvgate BY WPED) AND c_pmcore
DEVICE MP(pch_lvt) plvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <plvgate_aux> netlist model pch_lvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(plvgate, tpdiff ) + perimeter_inside(plvgate, tpdiff)) / 2
   L = area(plvgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(plvgate,plvgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(plvgate,plvgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

plvgate_mac_aux = (SIZE plvgate_mac BY WPED) AND c_pmcore
DEVICE MP(pch_lvt) plvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <plvgate_mac_aux> netlist model pch_lvt_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(plvgate_mac, tpdiff ) + perimeter_inside(plvgate_mac, tpdiff)) / 2
   L = area(plvgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(plvgate_mac,plvgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(plvgate_mac,plvgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_mac_aux = (SIZE pgate_mac BY WPED) AND c_pmcore
DEVICE MP(pch) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_mac_aux> netlist model pch_mac netlist element "X" [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2
   L = area(pgate_mac) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_mac,pgate_mac_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_mac,pgate_mac_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

puvlgate_aux = (SIZE puvlgate BY WPED) AND c_pmcore
DEVICE MP(pch_ulvt) puvlgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <puvlgate_aux> netlist model pch_ulvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(puvlgate, tpdiff ) + perimeter_inside(puvlgate, tpdiff)) / 2
   L = area(puvlgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(puvlgate,puvlgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(puvlgate,puvlgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

puvhgate_aux = (SIZE puvhgate BY WPED) AND c_pmcore
DEVICE MP(pch_uthvt) puvhgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <puvhgate_aux> netlist model pch_uthvt [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(puvhgate, tpdiff ) + perimeter_inside(puvhgate, tpdiff)) / 2
   L = area(puvhgate) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(puvhgate,puvhgate_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(puvhgate,puvhgate_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

pgate_w_aux = (SIZE pgate_w BY WPED) AND c_pmcore
DEVICE MP(pch_w) pgate_w poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> <OD> <pgate_w_aux> netlist model pch_w [
   property sa,sb,sca,scb,scc,W,L,AS,AD,PD,PS,NRD,NRS
   LR_EXT = MOS_LR_EXT
   TOP_EXT = PMOS_TOP_EXT
   BOT_EXT = 0
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_w, tpdiff ) + perimeter_inside(pgate_w, tpdiff)) / 2
   L = area(pgate_w) / W
   s = enclosure_vector( OD, 60 )
   sa = W/sum(s::W/(s::a + 0.5 *L)) - 0.5*L
   sb = W/sum(s::W/(s::b + 0.5 *L)) - 0.5*L
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
// Well proximity.
   SCH = ENCLOSURE_PERPENDICULAR(pgate_w,pgate_w_aux, S, 5.0 )  // "Horizontal" direction.
   SCV = ENCLOSURE_PARALLEL(pgate_w,pgate_w_aux, S, 5.0 )       // "Vertical" direction.
   SCA = TVF_NUM_FUN ( "calc_sca", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCB = TVF_NUM_FUN ( "calc_scb", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
   SCC = TVF_NUM_FUN ( "calc_scc", "device_function", SCH, SCV, W, L , LR_EXT, TOP_EXT, BOT_EXT, SCALE )
]

DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_hvtsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2
   L = area(pgate_hvs) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_sr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2
   L = area(pgate_s) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]

DEVICE MP(pchpu_ulpsr) pgate_ulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> netlist model pchpu_ulpsr [
  property W,L,AS,AD,PD,PS,NRD,NRS
   SCALE = PRESCALE
   W = (perimeter_coincide(pgate_ulp, tpdiff ) + perimeter_inside(pgate_ulp, tpdiff)) / 2
   L = area(pgate_ulp) / W
   PI_S_OD = perimeter_inside(S,pthin)
   PI_D_OD = perimeter_inside(D,pthin)
   IF(PI_S_OD == 0) {
    AD = area(D) * W / PI_D_OD
    AS = AD
    PD = perimeter(D) * W /PI_D_OD
    PS = PD } 
   ELSE IF(PI_D_OD == 0) {
    AS = area(S) * W / PI_S_OD
    AD = AS
    PS = perimeter(S) * W /PI_S_OD
    PD = PS } 
   ELSE {
    AS = area(S) * W / PI_S_OD
    AD = area(D) * W / PI_D_OD
    PS = perimeter(S) * W /PI_S_OD
    PD = perimeter(D) * W /PI_D_OD }
 #IFDEF ZERO_NRS_NRD 
   NRS = 0
   NRD = 0
 #ELSE 
   NRS = AS / W / W
   NRD = AD / W / W
 #ENDIF 
]


#ENDIF
#ELSE

#IFDEF extract_as_ad
DEVICE MN(nch) ngate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2
   L=area(ngate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2
   L=area(ngate_18) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2
   L=area(dngate_18) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2
   L=area(dngate_18_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2
   L=area(ngate_18_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2
   L=area(ngate_25) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2
   L=area(dngate_25) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2
   L=area(dngate_25_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2
   L=area(ngate_25_mac) / W
  PI_S_OD = perimeter_inside(S,nthin)
  PI_D_OD = perimeter_inside(D,nthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin)
  AD = area(D) * W /perimeter_inside(D,nthin)
  }
  ]
DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2
   L=area(ngate_25od) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od_dnw) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2
   L=area(dngate_25od) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od_dnw) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2
   L=area(dngate_25od_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2
   L=area(ngate_25od_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2
   L=area(ngate_33) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2
   L=area(dngate_33) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2
   L=area(dngate_33_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2
   L=area(ngate_33_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw) nrgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2
   L=area(nrgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2
   L=area(nrgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2
   L=area(ngate_dnw_w) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt) nhvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nhvgate, tndiff ) + perimeter_inside(nhvgate, tndiff)) / 2
   L=area(nhvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt_dnw) n1hvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1hvgate, tndiff ) + perimeter_inside(n1hvgate, tndiff)) / 2
   L=area(n1hvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt_dnw) n1hvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1hvgate_mac, tndiff ) + perimeter_inside(n1hvgate_mac, tndiff)) / 2
   L=area(n1hvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_hvt) nhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nhvgate_mac, tndiff ) + perimeter_inside(nhvgate_mac, tndiff)) / 2
   L=area(nhvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt) nlvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlvgate, tndiff ) + perimeter_inside(nlvgate, tndiff)) / 2
   L=area(nlvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt_dnw) n1lvgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1lvgate, tndiff ) + perimeter_inside(n1lvgate, tndiff)) / 2
   L=area(n1lvgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt_dnw) n1lvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1lvgate_mac, tndiff ) + perimeter_inside(n1lvgate_mac, tndiff)) / 2
   L=area(n1lvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_lvt) nlvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlvgate_mac, tndiff ) + perimeter_inside(nlvgate_mac, tndiff)) / 2
   L=area(nlvgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2
   L=area(ngate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2
   L=area(nlgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2
   L=area(ngate_18na) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2
   L=area(ngate_18na_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2
   L=area(ngate_25na) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2
   L=area(ngate_25na_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2
   L=area(ngate_33na) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2
   L=area(ngate_33na_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2
   L=area(nlgate_mac) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_ulvt) nuvlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nuvlgate, tndiff ) + perimeter_inside(nuvlgate, tndiff)) / 2
   L=area(nuvlgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_ulvt_dnw) n1uvlgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1uvlgate, tndiff ) + perimeter_inside(n1uvlgate, tndiff)) / 2
   L=area(n1uvlgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_uthvt) nuvhgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(nuvhgate, tndiff ) + perimeter_inside(nuvhgate, tndiff)) / 2
   L=area(nuvhgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_uthvt_dnw) n1uvhgate poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(n1uvhgate, tndiff ) + perimeter_inside(n1uvhgate, tndiff)) / 2
   L=area(n1uvhgate) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nch_w) ngate_w poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_w, tndiff ) + perimeter_inside(ngate_w, tndiff)) / 2
   L=area(ngate_w) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2
   L=area(ngate_hvspd) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2
   L=area(ngate_spd) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpd_ulpsr) ngate_ulppd poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_ulppd, tndiff ) + perimeter_inside(ngate_ulppd, tndiff)) / 2
   L=area(ngate_ulppd) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2
   L=area(ngate_hvspg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2
   L=area(ngate_spg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MN(nchpg_ulpsr) ngate_ulppg poly(G) tndiff(S) tndiff(D) psub(B) <nthin1> [
  property W,L,AS,AD
   W=(perimeter_coincide(ngate_ulppg, tndiff ) + perimeter_inside(ngate_ulppg, tndiff)) / 2
   L=area(ngate_ulppg) / W
  PI_S_OD = perimeter_inside(S,nthin1)
  PI_D_OD = perimeter_inside(D,nthin1)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
  }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS  }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,nthin1)
  AD = area(D) * W /perimeter_inside(D,nthin1)
  }
  ]
DEVICE MP(pch) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2 
   L=area(pgate_18) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2 
   L=area(pgate_18_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_1tr) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2 
   L=area(pgate_1tr) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2 
   L=area(pgate_25) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2 
   L=area(pgate_25_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2 
   L=area(pgate_25od) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2 
   L=area(pgate_25od_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2 
   L=area(pgate_33) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2 
   L=area(pgate_33_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_hvt) phvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(phvgate, tpdiff ) + perimeter_inside(phvgate, tpdiff)) / 2 
   L=area(phvgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_hvt) phvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(phvgate_mac, tpdiff ) + perimeter_inside(phvgate_mac, tpdiff)) / 2 
   L=area(phvgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_lvt) plvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(plvgate, tpdiff ) + perimeter_inside(plvgate, tpdiff)) / 2 
   L=area(plvgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_lvt) plvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(plvgate_mac, tpdiff ) + perimeter_inside(plvgate_mac, tpdiff)) / 2 
   L=area(plvgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2 
   L=area(pgate_mac) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_ulvt) puvlgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(puvlgate, tpdiff ) + perimeter_inside(puvlgate, tpdiff)) / 2 
   L=area(puvlgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_uthvt) puvhgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(puvhgate, tpdiff ) + perimeter_inside(puvhgate, tpdiff)) / 2 
   L=area(puvhgate) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pch_w) pgate_w poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_w, tpdiff ) + perimeter_inside(pgate_w, tpdiff)) / 2 
   L=area(pgate_w) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2 
   L=area(pgate_hvs) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2 
   L=area(pgate_s) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]
DEVICE MP(pchpu_ulpsr) pgate_ulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) <pthin> [
  property W,L,AS,AD
   W=(perimeter_coincide(pgate_ulp, tpdiff ) + perimeter_inside(pgate_ulp, tpdiff)) / 2 
   L=area(pgate_ulp) / W
  PI_S_OD = perimeter_inside(S,pthin)
  PI_D_OD = perimeter_inside(D,pthin)
  IF(PI_S_OD ==0) {
    AD = area(D) * W /PI_D_OD
    AS = AD
    }
  ELSE IF(PI_D_OD==0) {
    AS = area(S) * W /PI_S_OD
    AD = AS
    }
  ELSE {
  AS = area(S) * W /perimeter_inside(S,pthin)
  AD = area(D) * W /perimeter_inside(D,pthin)
  }
  ]


#ELSE
DEVICE MN(nch) ngate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate, tndiff ) + perimeter_inside(ngate, tndiff)) / 2 
   L=area(ngate) / W
]
DEVICE MN(nch_18) ngate_18 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18, tndiff ) + perimeter_inside(ngate_18, tndiff)) / 2 
   L=area(ngate_18) / W
]
DEVICE MN(nch_18_dnw) dngate_18 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_18, tndiff ) + perimeter_inside(dngate_18, tndiff)) / 2 
   L=area(dngate_18) / W
]
DEVICE MN(nch_18_dnw) dngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_18_mac, tndiff ) + perimeter_inside(dngate_18_mac, tndiff)) / 2 
   L=area(dngate_18_mac) / W
]
DEVICE MN(nch_18) ngate_18_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18_mac, tndiff ) + perimeter_inside(ngate_18_mac, tndiff)) / 2 
   L=area(ngate_18_mac) / W
]
DEVICE MN(nch_25) ngate_25 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25, tndiff ) + perimeter_inside(ngate_25, tndiff)) / 2 
   L=area(ngate_25) / W
]
DEVICE MN(nch_25_dnw) dngate_25 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25, tndiff ) + perimeter_inside(dngate_25, tndiff)) / 2 
   L=area(dngate_25) / W
]
DEVICE MN(nch_25_dnw) dngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25_mac, tndiff ) + perimeter_inside(dngate_25_mac, tndiff)) / 2 
   L=area(dngate_25_mac) / W
]
DEVICE MN(nch_25) ngate_25_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25_mac, tndiff ) + perimeter_inside(ngate_25_mac, tndiff)) / 2 
   L=area(ngate_25_mac) / W
]
DEVICE MN(nch_25od) ngate_25od poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25od, tndiff ) + perimeter_inside(ngate_25od, tndiff)) / 2 
   L=area(ngate_25od) / W
]
DEVICE MN(nch_25od_dnw) dngate_25od poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25od, tndiff ) + perimeter_inside(dngate_25od, tndiff)) / 2 
   L=area(dngate_25od) / W
]
DEVICE MN(nch_25od_dnw) dngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_25od_mac, tndiff ) + perimeter_inside(dngate_25od_mac, tndiff)) / 2 
   L=area(dngate_25od_mac) / W
]
DEVICE MN(nch_25od) ngate_25od_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25od_mac, tndiff ) + perimeter_inside(ngate_25od_mac, tndiff)) / 2 
   L=area(ngate_25od_mac) / W
]
DEVICE MN(nch_33) ngate_33 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33, tndiff ) + perimeter_inside(ngate_33, tndiff)) / 2 
   L=area(ngate_33) / W
]
DEVICE MN(nch_33_dnw) dngate_33 poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_33, tndiff ) + perimeter_inside(dngate_33, tndiff)) / 2 
   L=area(dngate_33) / W
]
DEVICE MN(nch_33_dnw) dngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(dngate_33_mac, tndiff ) + perimeter_inside(dngate_33_mac, tndiff)) / 2 
   L=area(dngate_33_mac) / W
]
DEVICE MN(nch_33) ngate_33_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33_mac, tndiff ) + perimeter_inside(ngate_33_mac, tndiff)) / 2 
   L=area(ngate_33_mac) / W
]
DEVICE MN(nch_dnw) nrgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nrgate, tndiff ) + perimeter_inside(nrgate, tndiff)) / 2 
   L=area(nrgate) / W
]
DEVICE MN(nch_dnw) nrgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nrgate_mac, tndiff ) + perimeter_inside(nrgate_mac, tndiff)) / 2 
   L=area(nrgate_mac) / W
]
DEVICE MN(nch_dnw_w) ngate_dnw_w poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_dnw_w, tndiff ) + perimeter_inside(ngate_dnw_w, tndiff)) / 2 
   L=area(ngate_dnw_w) / W
]
DEVICE MN(nch_hvt) nhvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nhvgate, tndiff ) + perimeter_inside(nhvgate, tndiff)) / 2 
   L=area(nhvgate) / W
]
DEVICE MN(nch_hvt_dnw) n1hvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1hvgate, tndiff ) + perimeter_inside(n1hvgate, tndiff)) / 2 
   L=area(n1hvgate) / W
]
DEVICE MN(nch_hvt_dnw) n1hvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1hvgate_mac, tndiff ) + perimeter_inside(n1hvgate_mac, tndiff)) / 2 
   L=area(n1hvgate_mac) / W
]
DEVICE MN(nch_hvt) nhvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nhvgate_mac, tndiff ) + perimeter_inside(nhvgate_mac, tndiff)) / 2 
   L=area(nhvgate_mac) / W
]
DEVICE MN(nch_lvt) nlvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlvgate, tndiff ) + perimeter_inside(nlvgate, tndiff)) / 2 
   L=area(nlvgate) / W
]
DEVICE MN(nch_lvt_dnw) n1lvgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1lvgate, tndiff ) + perimeter_inside(n1lvgate, tndiff)) / 2 
   L=area(n1lvgate) / W
]
DEVICE MN(nch_lvt_dnw) n1lvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1lvgate_mac, tndiff ) + perimeter_inside(n1lvgate_mac, tndiff)) / 2 
   L=area(n1lvgate_mac) / W
]
DEVICE MN(nch_lvt) nlvgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlvgate_mac, tndiff ) + perimeter_inside(nlvgate_mac, tndiff)) / 2 
   L=area(nlvgate_mac) / W
]
DEVICE MN(nch) ngate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_mac, tndiff ) + perimeter_inside(ngate_mac, tndiff)) / 2 
   L=area(ngate_mac) / W
]
DEVICE MN(nch_na) nlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate, tndiff ) + perimeter_inside(nlgate, tndiff)) / 2 
   L=area(nlgate) / W
]
DEVICE MN(nch_na18) ngate_18na poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18na, tndiff ) + perimeter_inside(ngate_18na, tndiff)) / 2 
   L=area(ngate_18na) / W
]
DEVICE MN(nch_na18) ngate_18na_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_18na_mac, tndiff ) + perimeter_inside(ngate_18na_mac, tndiff)) / 2 
   L=area(ngate_18na_mac) / W
]
DEVICE MN(nch_na25) ngate_25na poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25na, tndiff ) + perimeter_inside(ngate_25na, tndiff)) / 2 
   L=area(ngate_25na) / W
]
DEVICE MN(nch_na25) ngate_25na_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_25na_mac, tndiff ) + perimeter_inside(ngate_25na_mac, tndiff)) / 2 
   L=area(ngate_25na_mac) / W
]
DEVICE MN(nch_na33) ngate_33na poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33na, tndiff ) + perimeter_inside(ngate_33na, tndiff)) / 2 
   L=area(ngate_33na) / W
]
DEVICE MN(nch_na33) ngate_33na_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_33na_mac, tndiff ) + perimeter_inside(ngate_33na_mac, tndiff)) / 2 
   L=area(ngate_33na_mac) / W
]
DEVICE MN(nch_na) nlgate_mac poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nlgate_mac, tndiff ) + perimeter_inside(nlgate_mac, tndiff)) / 2 
   L=area(nlgate_mac) / W
]
DEVICE MN(nch_ulvt) nuvlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nuvlgate, tndiff ) + perimeter_inside(nuvlgate, tndiff)) / 2 
   L=area(nuvlgate) / W
]
DEVICE MN(nch_ulvt_dnw) n1uvlgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1uvlgate, tndiff ) + perimeter_inside(n1uvlgate, tndiff)) / 2 
   L=area(n1uvlgate) / W
]
DEVICE MN(nch_uthvt) nuvhgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(nuvhgate, tndiff ) + perimeter_inside(nuvhgate, tndiff)) / 2 
   L=area(nuvhgate) / W
]
DEVICE MN(nch_uthvt_dnw) n1uvhgate poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(n1uvhgate, tndiff ) + perimeter_inside(n1uvhgate, tndiff)) / 2 
   L=area(n1uvhgate) / W
]
DEVICE MN(nch_w) ngate_w poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_w, tndiff ) + perimeter_inside(ngate_w, tndiff)) / 2 
   L=area(ngate_w) / W
]
DEVICE MN(nchpd_hvtsr) ngate_hvspd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspd, tndiff ) + perimeter_inside(ngate_hvspd, tndiff)) / 2 
   L=area(ngate_hvspd) / W
]
DEVICE MN(nchpd_sr) ngate_spd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spd, tndiff ) + perimeter_inside(ngate_spd, tndiff)) / 2 
   L=area(ngate_spd) / W
]
DEVICE MN(nchpd_ulpsr) ngate_ulppd poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_ulppd, tndiff ) + perimeter_inside(ngate_ulppd, tndiff)) / 2 
   L=area(ngate_ulppd) / W
]
DEVICE MN(nchpg_hvtsr) ngate_hvspg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_hvspg, tndiff ) + perimeter_inside(ngate_hvspg, tndiff)) / 2 
   L=area(ngate_hvspg) / W
]
DEVICE MN(nchpg_sr) ngate_spg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_spg, tndiff ) + perimeter_inside(ngate_spg, tndiff)) / 2 
   L=area(ngate_spg) / W
]
DEVICE MN(nchpg_ulpsr) ngate_ulppg poly(G) tndiff(S) tndiff(D) psub(B) [
   property W,L
   W=(perimeter_coincide(ngate_ulppg, tndiff ) + perimeter_inside(ngate_ulppg, tndiff)) / 2 
   L=area(ngate_ulppg) / W
]
DEVICE MP(pch) pgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate, tpdiff ) + perimeter_inside(pgate, tpdiff)) / 2 
   L=area(pgate) / W
]
DEVICE MP(pch_18) pgate_18 poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_18, tpdiff ) + perimeter_inside(pgate_18, tpdiff)) / 2 
   L=area(pgate_18) / W
]
DEVICE MP(pch_18) pgate_18_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_18_mac, tpdiff ) + perimeter_inside(pgate_18_mac, tpdiff)) / 2 
   L=area(pgate_18_mac) / W
]
DEVICE MP(pch_1tr) pgate_1tr poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_1tr, tpdiff ) + perimeter_inside(pgate_1tr, tpdiff)) / 2 
   L=area(pgate_1tr) / W
]
DEVICE MP(pch_25) pgate_25 poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25, tpdiff ) + perimeter_inside(pgate_25, tpdiff)) / 2 
   L=area(pgate_25) / W
]
DEVICE MP(pch_25) pgate_25_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25_mac, tpdiff ) + perimeter_inside(pgate_25_mac, tpdiff)) / 2 
   L=area(pgate_25_mac) / W
]
DEVICE MP(pch_25od) pgate_25od poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25od, tpdiff ) + perimeter_inside(pgate_25od, tpdiff)) / 2 
   L=area(pgate_25od) / W
]
DEVICE MP(pch_25od) pgate_25od_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_25od_mac, tpdiff ) + perimeter_inside(pgate_25od_mac, tpdiff)) / 2 
   L=area(pgate_25od_mac) / W
]
DEVICE MP(pch_33) pgate_33 poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_33, tpdiff ) + perimeter_inside(pgate_33, tpdiff)) / 2 
   L=area(pgate_33) / W
]
DEVICE MP(pch_33) pgate_33_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_33_mac, tpdiff ) + perimeter_inside(pgate_33_mac, tpdiff)) / 2 
   L=area(pgate_33_mac) / W
]
DEVICE MP(pch_hvt) phvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(phvgate, tpdiff ) + perimeter_inside(phvgate, tpdiff)) / 2 
   L=area(phvgate) / W
]
DEVICE MP(pch_hvt) phvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(phvgate_mac, tpdiff ) + perimeter_inside(phvgate_mac, tpdiff)) / 2 
   L=area(phvgate_mac) / W
]
DEVICE MP(pch_lvt) plvgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(plvgate, tpdiff ) + perimeter_inside(plvgate, tpdiff)) / 2 
   L=area(plvgate) / W
]
DEVICE MP(pch_lvt) plvgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(plvgate_mac, tpdiff ) + perimeter_inside(plvgate_mac, tpdiff)) / 2 
   L=area(plvgate_mac) / W
]
DEVICE MP(pch) pgate_mac poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_mac, tpdiff ) + perimeter_inside(pgate_mac, tpdiff)) / 2 
   L=area(pgate_mac) / W
]
DEVICE MP(pch_ulvt) puvlgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(puvlgate, tpdiff ) + perimeter_inside(puvlgate, tpdiff)) / 2 
   L=area(puvlgate) / W
]
DEVICE MP(pch_uthvt) puvhgate poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(puvhgate, tpdiff ) + perimeter_inside(puvhgate, tpdiff)) / 2 
   L=area(puvhgate) / W
]
DEVICE MP(pch_w) pgate_w poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_w, tpdiff ) + perimeter_inside(pgate_w, tpdiff)) / 2 
   L=area(pgate_w) / W
]
DEVICE MP(pchpu_hvtsr) pgate_hvs poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_hvs, tpdiff ) + perimeter_inside(pgate_hvs, tpdiff)) / 2 
   L=area(pgate_hvs) / W
]
DEVICE MP(pchpu_sr) pgate_s poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_s, tpdiff ) + perimeter_inside(pgate_s, tpdiff)) / 2 
   L=area(pgate_s) / W
]
DEVICE MP(pchpu_ulpsr) pgate_ulp poly(G) tpdiff(S) tpdiff(D) nxwell(B) [
   property W,L
   W=(perimeter_coincide(pgate_ulp, tpdiff ) + perimeter_inside(pgate_ulp, tpdiff)) / 2 
   L=area(pgate_ulp) / W
]


#ENDIF

#ENDIF


#IFNDEF RC_DECK
TRACE PROPERTY MN(nch) L L 0
TRACE PROPERTY MN(nch) W W 0
TRACE PROPERTY MN(nch_18) L L 0
TRACE PROPERTY MN(nch_18) W W 0
TRACE PROPERTY MN(nch_18_dnw) L L 0
TRACE PROPERTY MN(nch_18_dnw) W W 0
TRACE PROPERTY MN(nch_25) L L 0
TRACE PROPERTY MN(nch_25) W W 0
TRACE PROPERTY MN(nch_25_dnw) L L 0
TRACE PROPERTY MN(nch_25_dnw) W W 0
TRACE PROPERTY MN(nch_25od) L L 0
TRACE PROPERTY MN(nch_25od) W W 0
TRACE PROPERTY MN(nch_25od_dnw) L L 0
TRACE PROPERTY MN(nch_25od_dnw) W W 0
TRACE PROPERTY MN(nch_33) L L 0
TRACE PROPERTY MN(nch_33) W W 0
TRACE PROPERTY MN(nch_33_dnw) L L 0
TRACE PROPERTY MN(nch_33_dnw) W W 0
TRACE PROPERTY MN(nch_dnw) L L 0
TRACE PROPERTY MN(nch_dnw) W W 0
TRACE PROPERTY MN(nch_dnw_w) L L 0
TRACE PROPERTY MN(nch_dnw_w) W W 0
TRACE PROPERTY MN(nch_hvt) L L 0
TRACE PROPERTY MN(nch_hvt) W W 0
TRACE PROPERTY MN(nch_hvt_dnw) L L 0
TRACE PROPERTY MN(nch_hvt_dnw) W W 0
TRACE PROPERTY MN(nch_lvt) L L 0
TRACE PROPERTY MN(nch_lvt) W W 0
TRACE PROPERTY MN(nch_lvt_dnw) L L 0
TRACE PROPERTY MN(nch_lvt_dnw) W W 0
TRACE PROPERTY MN(nch_na) L L 0
TRACE PROPERTY MN(nch_na) W W 0
TRACE PROPERTY MN(nch_na18) L L 0
TRACE PROPERTY MN(nch_na18) W W 0
TRACE PROPERTY MN(nch_na25) L L 0
TRACE PROPERTY MN(nch_na25) W W 0
TRACE PROPERTY MN(nch_na33) L L 0
TRACE PROPERTY MN(nch_na33) W W 0
TRACE PROPERTY MN(nch_ulvt) L L 0
TRACE PROPERTY MN(nch_ulvt) W W 0
TRACE PROPERTY MN(nch_ulvt_dnw) L L 0
TRACE PROPERTY MN(nch_ulvt_dnw) W W 0
TRACE PROPERTY MN(nch_uthvt) L L 0
TRACE PROPERTY MN(nch_uthvt) W W 0
TRACE PROPERTY MN(nch_uthvt_dnw) L L 0
TRACE PROPERTY MN(nch_uthvt_dnw) W W 0
TRACE PROPERTY MN(nch_w) L L 0
TRACE PROPERTY MN(nch_w) W W 0
TRACE PROPERTY MN(nchpd_hvtsr) L L 0
TRACE PROPERTY MN(nchpd_hvtsr) W W 0
TRACE PROPERTY MN(nchpd_sr) L L 0
TRACE PROPERTY MN(nchpd_sr) W W 0
TRACE PROPERTY MN(nchpd_ulpsr) L L 0
TRACE PROPERTY MN(nchpd_ulpsr) W W 0
TRACE PROPERTY MN(nchpg_hvtsr) L L 0
TRACE PROPERTY MN(nchpg_hvtsr) W W 0
TRACE PROPERTY MN(nchpg_sr) L L 0
TRACE PROPERTY MN(nchpg_sr) W W 0
TRACE PROPERTY MN(nchpg_ulpsr) L L 0
TRACE PROPERTY MN(nchpg_ulpsr) W W 0
TRACE PROPERTY MP(pch) L L 0
TRACE PROPERTY MP(pch) W W 0
TRACE PROPERTY MP(pch_18) L L 0
TRACE PROPERTY MP(pch_18) W W 0
TRACE PROPERTY MP(pch_1tr) L L 0
TRACE PROPERTY MP(pch_1tr) W W 0
TRACE PROPERTY MP(pch_25) L L 0
TRACE PROPERTY MP(pch_25) W W 0
TRACE PROPERTY MP(pch_25od) L L 0
TRACE PROPERTY MP(pch_25od) W W 0
TRACE PROPERTY MP(pch_33) L L 0
TRACE PROPERTY MP(pch_33) W W 0
TRACE PROPERTY MP(pch_hvt) L L 0
TRACE PROPERTY MP(pch_hvt) W W 0
TRACE PROPERTY MP(pch_lvt) L L 0
TRACE PROPERTY MP(pch_lvt) W W 0
TRACE PROPERTY MP(pch_ulvt) L L 0
TRACE PROPERTY MP(pch_ulvt) W W 0
TRACE PROPERTY MP(pch_uthvt) L L 0
TRACE PROPERTY MP(pch_uthvt) W W 0
TRACE PROPERTY MP(pch_w) L L 0
TRACE PROPERTY MP(pch_w) W W 0
TRACE PROPERTY MP(pchpu_hvtsr) L L 0
TRACE PROPERTY MP(pchpu_hvtsr) W W 0
TRACE PROPERTY MP(pchpu_sr) L L 0
TRACE PROPERTY MP(pchpu_sr) W W 0
TRACE PROPERTY MP(pchpu_ulpsr) L L 0
TRACE PROPERTY MP(pchpu_ulpsr) W W 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn10) cnemit10 ncoll1 cpbase1 cnemit1 netlist model npn10
#ELSE
  DEVICE Q(npn10) cnemit10 ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn10) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn2) cnemit2 ncoll1 cpbase1 cnemit1 netlist model npn2
#ELSE
  DEVICE Q(npn2) cnemit2 ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn2) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(npn5) cnemit5 ncoll1 cpbase1 cnemit1 netlist model npn5
#ELSE
  DEVICE Q(npn5) cnemit5 ncoll1 cpbase1 cnemit1 [
		property A
		A = area(cnemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(npn5) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp10) cemit10 coll1 cnbase1 cemit1 netlist model pnp10
#ELSE
  DEVICE Q(pnp10) cemit10 coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp10) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp2) cemit2 coll1 cnbase1 cemit1 netlist model pnp2
#ELSE
  DEVICE Q(pnp2) cemit2 coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp2) A A 0
#ENDIF

#IFDEF RC_DECK
DEVICE Q(pnp5) cemit5 coll1 cnbase1 cemit1 netlist model pnp5
#ELSE
  DEVICE Q(pnp5) cemit5 coll1 cnbase1 cemit1 [
		property A
		A = area(cemit1)
  ]
#ENDIF

#IFNDEF RC_DECK
  TRACE PROPERTY Q(pnp5) A A 0
#ENDIF

DEVICE D(ndio) cndio psub tndiff netlist model ndio
  TRACE PROPERTY D(ndio) A A 0
DEVICE D(ndio_18) indio_18 psub tndiff netlist model ndio_18
  TRACE PROPERTY D(ndio_18) A A 0
DEVICE D(ndio_25) indio_25 psub tndiff netlist model ndio_25
  TRACE PROPERTY D(ndio_25) A A 0
DEVICE D(ndio_25od) indio_25od psub tndiff netlist model ndio_25od
  TRACE PROPERTY D(ndio_25od) A A 0
DEVICE D(ndio_33) indio_33 psub tndiff netlist model ndio_33
  TRACE PROPERTY D(ndio_33) A A 0
DEVICE D(ndio_esd) ydio psub tndiff netlist model ndio_esd
  TRACE PROPERTY D(ndio_esd) A A 0
DEVICE D(ndio_hvt) ndioh psub tndiff netlist model ndio_hvt
  TRACE PROPERTY D(ndio_hvt) A A 0
DEVICE D(ndio_lvt) ndiol psub tndiff netlist model ndio_lvt
  TRACE PROPERTY D(ndio_lvt) A A 0
DEVICE D(ndio_na) cndion psub tndiff netlist model ndio_na
  TRACE PROPERTY D(ndio_na) A A 0
DEVICE D(ndio_na18) ndio_18na psub tndiff netlist model ndio_na18
  TRACE PROPERTY D(ndio_na18) A A 0
DEVICE D(ndio_na25) ndio_25na psub tndiff netlist model ndio_na25
  TRACE PROPERTY D(ndio_na25) A A 0
DEVICE D(ndio_na33) ndio_33na psub tndiff netlist model ndio_na33
  TRACE PROPERTY D(ndio_na33) A A 0
DEVICE D(ndio_ulvt) ndioul psub tndiff netlist model ndio_ulvt
  TRACE PROPERTY D(ndio_ulvt) A A 0
DEVICE D(ndio_uthvt) ndiouh psub tndiff netlist model ndio_uthvt
  TRACE PROPERTY D(ndio_uthvt) A A 0
DEVICE D(ndio_w) cndio_w psub tndiff netlist model ndio_w
  TRACE PROPERTY D(ndio_w) A A 0
DEVICE D(nwdio) cnwdio psub nxwell netlist model nwdio
  TRACE PROPERTY D(nwdio) A A 0
DEVICE D(nwdio_18) inwdio_18 psub nxwell netlist model nwdio_18
  TRACE PROPERTY D(nwdio_18) A A 0
DEVICE D(nwdio_25) inwdio_25 psub nxwell netlist model nwdio_25
  TRACE PROPERTY D(nwdio_25) A A 0
DEVICE D(nwdio_33) inwdio_33 psub nxwell netlist model nwdio_33
  TRACE PROPERTY D(nwdio_33) A A 0
DEVICE D(nwdio_w) cnwdio_w psub nxwell netlist model nwdio_w
  TRACE PROPERTY D(nwdio_w) A A 0
DEVICE D(pdio) cpdio tpdiff nxwell netlist model pdio
  TRACE PROPERTY D(pdio) A A 0
DEVICE D(pdio_18) ipdio_18 tpdiff nxwell netlist model pdio_18
  TRACE PROPERTY D(pdio_18) A A 0
DEVICE D(pdio_25) ipdio_25 tpdiff nxwell netlist model pdio_25
  TRACE PROPERTY D(pdio_25) A A 0
DEVICE D(pdio_25od) ipdio_25od tpdiff nxwell netlist model pdio_25od
  TRACE PROPERTY D(pdio_25od) A A 0
DEVICE D(pdio_33) ipdio_33 tpdiff nxwell netlist model pdio_33
  TRACE PROPERTY D(pdio_33) A A 0
DEVICE D(pdio_hvt) pdioh tpdiff nxwell netlist model pdio_hvt
  TRACE PROPERTY D(pdio_hvt) A A 0
DEVICE D(pdio_lvt) pdiol tpdiff nxwell netlist model pdio_lvt
  TRACE PROPERTY D(pdio_lvt) A A 0
DEVICE D(pdio_ulvt) pdioul tpdiff nxwell netlist model pdio_ulvt
  TRACE PROPERTY D(pdio_ulvt) A A 0
DEVICE D(pdio_uthvt) pdiouh tpdiff nxwell netlist model pdio_uthvt
  TRACE PROPERTY D(pdio_uthvt) A A 0
DEVICE D(pdio_w) cpdio_w tpdiff nxwell netlist model pdio_w
  TRACE PROPERTY D(pdio_w) A A 0
DEVICE C(CM) mim_r p3 crown

// User define devices 

F_reg1a = EXT MOM_field1 < 0.41 OPPOSITE REGION 
F_reg1  = ( F_reg1a AND MOMDMY1 ) NOT M1

F_reg2a = EXT MOM_field2 < 0.41 OPPOSITE REGION 
F_reg2  = ( F_reg2a AND MOMDMY2 ) NOT M2

F_reg3a = EXT MOM_field3 < 0.41 OPPOSITE REGION 
F_reg3  = ( F_reg3a AND MOMDMY3 ) NOT M3

F_reg4a = EXT MOM_field4 < 0.41 OPPOSITE REGION 
F_reg4  = ( F_reg4a AND MOMDMY4 ) NOT M4

F_reg5a = EXT MOM_field5 < 0.41 OPPOSITE REGION 
F_reg5  = ( F_reg5a AND MOMDMY5 ) NOT M5

F_reg6a = EXT MOM_field6 < 0.41 OPPOSITE REGION 
F_reg6  = ( F_reg6a AND MOMDMY6 ) NOT M6






mom13_1 = MOMDMY3 INTERACT MOM_field1

mom13_2 = mom13_1 INTERACT MOM_field2

mom13_3 = mom13_2 INTERACT MOM_field3


mom13_Left4 = mom13_3 NOT INTERACT MOM_field4
mom13_Left5 = mom13_Left4 NOT INTERACT MOM_field5
mom13_Left6 = mom13_Left5 NOT INTERACT MOM_field6
mom13_Left7 = mom13_Left6 NOT INTERACT MOM_field7

mom13_reg1 = mom13_Left7 NOT INTERACT RFDMY
mom13_reg = mom13_reg1 NOT MOMDMY22

mom13_reg_rf1 = mom13_Left7 INTERACT RFDMY
mom13_reg_rf =  mom13_reg_rf1 NOT MOMDMY22 

mom13_mx_reg = MOMDMY22 INTERACT mom13_Left7
mom13_mx_aux = mom13_Left7 AND MOMDMY22


DEVICE crtmom mom13_reg metal3(PLUS) metal3(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom13_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom13_mx_reg mom3p1(PLUS1) mom3m1(MINUS1) mom3p2(PLUS2) mom3m2(MINUS2) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom13_mx_aux> <metal3> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal3)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom13_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 3
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom13_reg_rf metal3(PLUS) metal3(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom13_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 3
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom14_1 = MOMDMY4 INTERACT MOM_field1

mom14_2 = mom14_1 INTERACT MOM_field2

mom14_3 = mom14_2 INTERACT MOM_field3

mom14_4 = mom14_3 INTERACT MOM_field4


mom14_Left5 = mom14_4 NOT INTERACT MOM_field5
mom14_Left6 = mom14_Left5 NOT INTERACT MOM_field6
mom14_Left7 = mom14_Left6 NOT INTERACT MOM_field7

mom14_reg1 = mom14_Left7 NOT INTERACT RFDMY
mom14_reg = mom14_reg1 NOT MOMDMY22

mom14_reg_rf1 = mom14_Left7 INTERACT RFDMY
mom14_reg_rf =  mom14_reg_rf1 NOT MOMDMY22 

mom14_mx_reg = MOMDMY22 INTERACT mom14_Left7
mom14_mx_aux = mom14_Left7 AND MOMDMY22


DEVICE crtmom mom14_reg metal4(PLUS) metal4(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom14_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom14_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom14_mx_aux> <metal4> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal4)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom14_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 4
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom14_reg_rf metal4(PLUS) metal4(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom14_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 4
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom15_1 = MOMDMY5 INTERACT MOM_field1

mom15_2 = mom15_1 INTERACT MOM_field2

mom15_3 = mom15_2 INTERACT MOM_field3

mom15_4 = mom15_3 INTERACT MOM_field4

mom15_5 = mom15_4 INTERACT MOM_field5


mom15_Left6 = mom15_5 NOT INTERACT MOM_field6
mom15_Left7 = mom15_Left6 NOT INTERACT MOM_field7

mom15_reg1 = mom15_Left7 NOT INTERACT RFDMY
mom15_reg = mom15_reg1 NOT MOMDMY22

mom15_reg_rf1 = mom15_Left7 INTERACT RFDMY
mom15_reg_rf =  mom15_reg_rf1 NOT MOMDMY22 

mom15_mx_reg = MOMDMY22 INTERACT mom15_Left7
mom15_mx_aux = mom15_Left7 AND MOMDMY22


DEVICE crtmom mom15_reg metal5(PLUS) metal5(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom15_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom15_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom15_mx_aux> <metal5> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal5)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom15_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom15_reg_rf metal5(PLUS) metal5(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom15_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom16_1 = MOMDMY6 INTERACT MOM_field1

mom16_2 = mom16_1 INTERACT MOM_field2

mom16_3 = mom16_2 INTERACT MOM_field3

mom16_4 = mom16_3 INTERACT MOM_field4

mom16_5 = mom16_4 INTERACT MOM_field5

mom16_6 = mom16_5 INTERACT MOM_field6


mom16_Left7 = mom16_6 NOT INTERACT MOM_field7

mom16_reg1 = mom16_Left7 NOT INTERACT RFDMY
mom16_reg = mom16_reg1 NOT MOMDMY22

mom16_reg_rf1 = mom16_Left7 INTERACT RFDMY
mom16_reg_rf =  mom16_reg_rf1 NOT MOMDMY22 

mom16_mx_reg = MOMDMY22 INTERACT mom16_Left7
mom16_mx_aux = mom16_Left7 AND MOMDMY22


DEVICE crtmom mom16_reg metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom16_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom16_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom16_mx_aux> <metal6> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom16_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom16_reg_rf metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom16_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom17_1 = MOMDMY7 INTERACT MOM_field1

mom17_2 = mom17_1 INTERACT MOM_field2

mom17_3 = mom17_2 INTERACT MOM_field3

mom17_4 = mom17_3 INTERACT MOM_field4

mom17_5 = mom17_4 INTERACT MOM_field5

mom17_6 = mom17_5 INTERACT MOM_field6

mom17_7 = mom17_6 INTERACT MOM_field7



mom17_reg1 = mom17_7 NOT INTERACT RFDMY
mom17_reg = mom17_reg1 NOT MOMDMY22

mom17_reg_rf1 = mom17_7 INTERACT RFDMY
mom17_reg_rf =  mom17_reg_rf1 NOT MOMDMY22 

mom17_mx_reg = MOMDMY22 INTERACT mom17_7
mom17_mx_aux = mom17_7 AND MOMDMY22


DEVICE crtmom mom17_reg metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom17_reg)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom17_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <mom17_mx_aux> <metal7> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field1)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom17_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(mf1*(nv-1))
    stm = 1
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom17_reg_rf metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field1> <MOM_field2> <F_reg1> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field1)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom17_reg_rf)/ nh
    s =  ((perimeter(F_reg1)-perimeter_coincide(F_reg1,MOM_field1))/2)/(nv-1)
    stm = 1
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom24_1 = MOMDMY4 NOT INTERACT MOM_field1


mom24_2 = mom24_1 INTERACT MOM_field2

mom24_3 = mom24_2 INTERACT MOM_field3

mom24_4 = mom24_3 INTERACT MOM_field4


mom24_Left5 = mom24_4 NOT INTERACT MOM_field5
mom24_Left6 = mom24_Left5 NOT INTERACT MOM_field6
mom24_Left7 = mom24_Left6 NOT INTERACT MOM_field7

mom24_reg1 = mom24_Left7 NOT INTERACT RFDMY
mom24_reg = mom24_reg1 NOT MOMDMY22

mom24_reg_rf1 = mom24_Left7 INTERACT RFDMY
mom24_reg_rf =  mom24_reg_rf1 NOT MOMDMY22 

mom24_mx_reg = MOMDMY22 INTERACT mom24_Left7
mom24_mx_aux = mom24_Left7 AND MOMDMY22


DEVICE crtmom mom24_reg metal4(PLUS) metal4(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom24_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom24_mx_reg mom4p1(PLUS1) mom4m1(MINUS1) mom4p2(PLUS2) mom4m2(MINUS2) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom24_mx_aux> <metal4> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal4)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom24_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 4
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom24_reg_rf metal4(PLUS) metal4(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom24_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 4
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]




mom25_1 = MOMDMY5 NOT INTERACT MOM_field1


mom25_2 = mom25_1 INTERACT MOM_field2

mom25_3 = mom25_2 INTERACT MOM_field3

mom25_4 = mom25_3 INTERACT MOM_field4

mom25_5 = mom25_4 INTERACT MOM_field5


mom25_Left6 = mom25_5 NOT INTERACT MOM_field6
mom25_Left7 = mom25_Left6 NOT INTERACT MOM_field7

mom25_reg1 = mom25_Left7 NOT INTERACT RFDMY
mom25_reg = mom25_reg1 NOT MOMDMY22

mom25_reg_rf1 = mom25_Left7 INTERACT RFDMY
mom25_reg_rf =  mom25_reg_rf1 NOT MOMDMY22 

mom25_mx_reg = MOMDMY22 INTERACT mom25_Left7
mom25_mx_aux = mom25_Left7 AND MOMDMY22


DEVICE crtmom mom25_reg metal5(PLUS) metal5(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom25_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom25_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom25_mx_aux> <metal5> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal5)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom25_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom25_reg_rf metal5(PLUS) metal5(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom25_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]




mom26_1 = MOMDMY6 NOT INTERACT MOM_field1


mom26_2 = mom26_1 INTERACT MOM_field2

mom26_3 = mom26_2 INTERACT MOM_field3

mom26_4 = mom26_3 INTERACT MOM_field4

mom26_5 = mom26_4 INTERACT MOM_field5

mom26_6 = mom26_5 INTERACT MOM_field6


mom26_Left7 = mom26_6 NOT INTERACT MOM_field7

mom26_reg1 = mom26_Left7 NOT INTERACT RFDMY
mom26_reg = mom26_reg1 NOT MOMDMY22

mom26_reg_rf1 = mom26_Left7 INTERACT RFDMY
mom26_reg_rf =  mom26_reg_rf1 NOT MOMDMY22 

mom26_mx_reg = MOMDMY22 INTERACT mom26_Left7
mom26_mx_aux = mom26_Left7 AND MOMDMY22


DEVICE crtmom mom26_reg metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom26_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom26_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom26_mx_aux> <metal6> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom26_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom26_reg_rf metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom26_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]




mom27_1 = MOMDMY7 NOT INTERACT MOM_field1


mom27_2 = mom27_1 INTERACT MOM_field2

mom27_3 = mom27_2 INTERACT MOM_field3

mom27_4 = mom27_3 INTERACT MOM_field4

mom27_5 = mom27_4 INTERACT MOM_field5

mom27_6 = mom27_5 INTERACT MOM_field6

mom27_7 = mom27_6 INTERACT MOM_field7



mom27_reg1 = mom27_7 NOT INTERACT RFDMY
mom27_reg = mom27_reg1 NOT MOMDMY22

mom27_reg_rf1 = mom27_7 INTERACT RFDMY
mom27_reg_rf =  mom27_reg_rf1 NOT MOMDMY22 

mom27_mx_reg = MOMDMY22 INTERACT mom27_7
mom27_mx_aux = mom27_7 AND MOMDMY22


DEVICE crtmom mom27_reg metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom27_reg)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom27_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <mom27_mx_aux> <metal7> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field2)/mf1
    w =  perimeter_coincide(MOM_field2,mom27_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(mf1*(nh-1))
    stm = 2
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom27_reg_rf metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field3> <MOM_field2> <F_reg2> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field2)
    w =  perimeter_coincide(MOM_field2,mom27_reg_rf)/ nh
    s =  ((perimeter(F_reg2)-perimeter_coincide(F_reg2,MOM_field2))/2)/(nh-1)
    stm = 2
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom35_1 = MOMDMY5 NOT INTERACT MOM_field1
mom35_2 = mom35_1 NOT INTERACT MOM_field2


mom35_3 = mom35_2 INTERACT MOM_field3

mom35_4 = mom35_3 INTERACT MOM_field4

mom35_5 = mom35_4 INTERACT MOM_field5


mom35_Left6 = mom35_5 NOT INTERACT MOM_field6
mom35_Left7 = mom35_Left6 NOT INTERACT MOM_field7

mom35_reg1 = mom35_Left7 NOT INTERACT RFDMY
mom35_reg = mom35_reg1 NOT MOMDMY22

mom35_reg_rf1 = mom35_Left7 INTERACT RFDMY
mom35_reg_rf =  mom35_reg_rf1 NOT MOMDMY22 

mom35_mx_reg = MOMDMY22 INTERACT mom35_Left7
mom35_mx_aux = mom35_Left7 AND MOMDMY22


DEVICE crtmom mom35_reg metal5(PLUS) metal5(MINUS) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom35_reg)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom35_mx_reg mom5p1(PLUS1) mom5m1(MINUS1) mom5p2(PLUS2) mom5m2(MINUS2) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom35_mx_aux> <metal5> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal5)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom35_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nv-1))
    stm = 3
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom35_reg_rf metal5(PLUS) metal5(MINUS) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom35_reg_rf)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 5
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]




mom36_1 = MOMDMY6 NOT INTERACT MOM_field1
mom36_2 = mom36_1 NOT INTERACT MOM_field2


mom36_3 = mom36_2 INTERACT MOM_field3

mom36_4 = mom36_3 INTERACT MOM_field4

mom36_5 = mom36_4 INTERACT MOM_field5

mom36_6 = mom36_5 INTERACT MOM_field6


mom36_Left7 = mom36_6 NOT INTERACT MOM_field7

mom36_reg1 = mom36_Left7 NOT INTERACT RFDMY
mom36_reg = mom36_reg1 NOT MOMDMY22

mom36_reg_rf1 = mom36_Left7 INTERACT RFDMY
mom36_reg_rf =  mom36_reg_rf1 NOT MOMDMY22 

mom36_mx_reg = MOMDMY22 INTERACT mom36_Left7
mom36_mx_aux = mom36_Left7 AND MOMDMY22


DEVICE crtmom mom36_reg metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom36_reg)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom36_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom36_mx_aux> <metal6> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom36_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nv-1))
    stm = 3
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom36_reg_rf metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom36_reg_rf)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]




mom37_1 = MOMDMY7 NOT INTERACT MOM_field1
mom37_2 = mom37_1 NOT INTERACT MOM_field2


mom37_3 = mom37_2 INTERACT MOM_field3

mom37_4 = mom37_3 INTERACT MOM_field4

mom37_5 = mom37_4 INTERACT MOM_field5

mom37_6 = mom37_5 INTERACT MOM_field6

mom37_7 = mom37_6 INTERACT MOM_field7



mom37_reg1 = mom37_7 NOT INTERACT RFDMY
mom37_reg = mom37_reg1 NOT MOMDMY22

mom37_reg_rf1 = mom37_7 INTERACT RFDMY
mom37_reg_rf =  mom37_reg_rf1 NOT MOMDMY22 

mom37_mx_reg = MOMDMY22 INTERACT mom37_7
mom37_mx_aux = mom37_7 AND MOMDMY22


DEVICE crtmom mom37_reg metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom37_reg)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom37_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <mom37_mx_aux> <metal7> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field3)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom37_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(mf1*(nv-1))
    stm = 3
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom37_reg_rf metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field3> <MOM_field4> <F_reg3> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field3)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom37_reg_rf)/ nh
    s =  ((perimeter(F_reg3)-perimeter_coincide(F_reg3,MOM_field3))/2)/(nv-1)
    stm = 3
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom46_1 = MOMDMY6 NOT INTERACT MOM_field1
mom46_2 = mom46_1 NOT INTERACT MOM_field2
mom46_3 = mom46_2 NOT INTERACT MOM_field3


mom46_4 = mom46_3 INTERACT MOM_field4

mom46_5 = mom46_4 INTERACT MOM_field5

mom46_6 = mom46_5 INTERACT MOM_field6


mom46_Left7 = mom46_6 NOT INTERACT MOM_field7

mom46_reg1 = mom46_Left7 NOT INTERACT RFDMY
mom46_reg = mom46_reg1 NOT MOMDMY22

mom46_reg_rf1 = mom46_Left7 INTERACT RFDMY
mom46_reg_rf =  mom46_reg_rf1 NOT MOMDMY22 

mom46_mx_reg = MOMDMY22 INTERACT mom46_Left7
mom46_mx_aux = mom46_Left7 AND MOMDMY22


DEVICE crtmom mom46_reg metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field5> <MOM_field4> <F_reg4> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom46_reg)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom46_mx_reg mom6p1(PLUS1) mom6m1(MINUS1) mom6p2(PLUS2) mom6m2(MINUS2) poly2(BULK) <MOM_field5> <MOM_field4> <F_reg4> <mom46_mx_aux> <metal6> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal6)-2
    mf = mf1/2
    nv = count(MOM_field5)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom46_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(mf1*(nh-1))
    stm = 4
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom46_reg_rf metal6(PLUS) metal6(MINUS) poly2(BULK) <MOM_field5> <MOM_field4> <F_reg4> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom46_reg_rf)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 6
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]




mom47_1 = MOMDMY7 NOT INTERACT MOM_field1
mom47_2 = mom47_1 NOT INTERACT MOM_field2
mom47_3 = mom47_2 NOT INTERACT MOM_field3


mom47_4 = mom47_3 INTERACT MOM_field4

mom47_5 = mom47_4 INTERACT MOM_field5

mom47_6 = mom47_5 INTERACT MOM_field6

mom47_7 = mom47_6 INTERACT MOM_field7



mom47_reg1 = mom47_7 NOT INTERACT RFDMY
mom47_reg = mom47_reg1 NOT MOMDMY22

mom47_reg_rf1 = mom47_7 INTERACT RFDMY
mom47_reg_rf =  mom47_reg_rf1 NOT MOMDMY22 

mom47_mx_reg = MOMDMY22 INTERACT mom47_7
mom47_mx_aux = mom47_7 AND MOMDMY22


DEVICE crtmom mom47_reg metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field5> <MOM_field4> <F_reg4> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom47_reg)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom47_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly2(BULK) <MOM_field5> <MOM_field4> <F_reg4> <mom47_mx_aux> <metal7> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field5)/mf1
    nh = count(MOM_field4)/mf1
    w =  perimeter_coincide(MOM_field4,mom47_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(mf1*(nh-1))
    stm = 4
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom47_reg_rf metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field5> <MOM_field4> <F_reg4> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field5)
    nh = count(MOM_field4)
    w =  perimeter_coincide(MOM_field4,mom47_reg_rf)/ nh
    s =  ((perimeter(F_reg4)-perimeter_coincide(F_reg4,MOM_field4))/2)/(nh-1)
    stm = 4
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]





mom57_1 = MOMDMY7 NOT INTERACT MOM_field1
mom57_2 = mom57_1 NOT INTERACT MOM_field2
mom57_3 = mom57_2 NOT INTERACT MOM_field3
mom57_4 = mom57_3 NOT INTERACT MOM_field4


mom57_5 = mom57_4 INTERACT MOM_field5

mom57_6 = mom57_5 INTERACT MOM_field6

mom57_7 = mom57_6 INTERACT MOM_field7



mom57_reg1 = mom57_7 NOT INTERACT RFDMY
mom57_reg = mom57_reg1 NOT MOMDMY22

mom57_reg_rf1 = mom57_7 INTERACT RFDMY
mom57_reg_rf =  mom57_reg_rf1 NOT MOMDMY22 

mom57_mx_reg = MOMDMY22 INTERACT mom57_7
mom57_mx_aux = mom57_7 AND MOMDMY22


DEVICE crtmom mom57_reg metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field5> <MOM_field6> <F_reg5> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field5)
    nh = count(MOM_field6)
    w =  perimeter_coincide(MOM_field6,mom57_reg)/ nh
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(nv-1)
    stm = 5
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]


DEVICE crtmom_mx mom57_mx_reg mom7p1(PLUS1) mom7m1(MINUS1) mom7p2(PLUS2) mom7m2(MINUS2) poly2(BULK) <MOM_field5> <MOM_field6> <F_reg5> <mom57_mx_aux> <metal7> <MOMDMY26> [
    property w,s,nv,nh,stm,spm,mf,busflag

    mf1 = count(metal7)-2
    mf = mf1/2
    nv = count(MOM_field5)/mf1
    nh = count(MOM_field6)/mf1
    w =  perimeter_coincide(MOM_field6,mom57_mx_aux)/ (nh*mf1)
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(mf1*(nv-1))
    stm = 5
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }

]

DEVICE crtmom_rf mom57_reg_rf metal7(PLUS) metal7(MINUS) poly2(BULK) <MOM_field5> <MOM_field6> <F_reg5> <MOMDMY26> (PLUS MINUS) [
    property w,s,nv,nh,stm,spm,busflag
    nv = count(MOM_field5)
    nh = count(MOM_field6)
    w =  perimeter_coincide(MOM_field6,mom57_reg_rf)/ nh
    s =  ((perimeter(F_reg5)-perimeter_coincide(F_reg5,MOM_field5))/2)/(nv-1)
    stm = 5
    spm = 7
    nr = count(MOMDMY26)
    lbus = (perimeter(MOMDMY26) - 5e-9*2 ) /(nr*2)
    if( lbus > 2e-07) { 
    busflag = 1   // LBUS = 0.23um
    } else { 
    busflag = 0   // LBUS = 0.14um
    }
]




TRACE PROPERTY crtmom nv nv 0 
TRACE PROPERTY crtmom nh nh 0 
TRACE PROPERTY crtmom s  s 0 
TRACE PROPERTY crtmom w  w 0
TRACE PROPERTY crtmom stm stm 0
TRACE PROPERTY crtmom spm spm 0
TRACE PROPERTY crtmom busflag busflag 0

TRACE PROPERTY crtmom_mx nv nv 0 
TRACE PROPERTY crtmom_mx nh nh 0 
TRACE PROPERTY crtmom_mx s  s 0 
TRACE PROPERTY crtmom_mx w  w 0
TRACE PROPERTY crtmom_mx stm stm 0
TRACE PROPERTY crtmom_mx spm spm 0
TRACE PROPERTY crtmom_mx mf mf 0
TRACE PROPERTY crtmom_mx busflag busflag 0


TRACE PROPERTY crtmom_rf nv nv 0 
TRACE PROPERTY crtmom_rf nh nh 0 
TRACE PROPERTY crtmom_rf s  s 0 
TRACE PROPERTY crtmom_rf w  w 0
TRACE PROPERTY crtmom_rf stm stm 0
TRACE PROPERTY crtmom_rf spm spm 0
TRACE PROPERTY crtmom_rf busflag busflag 0



//

//

#IFDEF extract_dnwdio
DEVICE D(dnwpsub) dnwdio psub_term DNW [
   property a,pj
   a = area(dnw)
   pj = perimeter(dnw)
]
TRACE PROPERTY D(dnwpsub) a a 0
#ENDIF

//    Define MIM devcie
RFDMYall = RFDMY OR RFDMYUD
mim_block = ctm AND cbm
shield1 = metal6 OR metal5
shield2 = shield1 AND ctm
shield  = shield2 AND RFDMY
shieldud  = shield2 AND RFDMYUD
RCTM = mim_block INTERACT VIA7i
RCBM = cbm INTERACT RCTM
OCBM = RCBM NOT RCTM
ctm_via = RCTM AND VIA7i
cbm_via = OCBM AND VIA7i
tvia1 = VIA7i NOT ctm_via
VIA7 = tvia1 NOT cbm_via
VIA8 = COPY VIA8i
RCTM_RF1 = RCTM AND RFDMY
RCTM_RF2 = RCTM_RF1 INTERACT shield
RCTM_RF  = RCTM_RF2 NOT RFDMYUD 
RCTM_RF_woum1 = RCTM_RF1 NOT INTERACT shield
RCTM_RF_woum  = RCTM_RF_woum1 NOT INTERACT CTMDMYUD
RCTM_RFUD1 = RCTM AND RFDMYUD
RCTM_RFUD = RCTM_RFUD1 INTERACT shieldud

RCTM_R1 = RCTM NOT RFDMYall
RCTM_R  = RCTM_R1 NOT CTMDMYUD
RCTM_RUD1 = RCTM NOT RFDMYUD
RCTM_RUD  = RCTM_RUD1 AND CTMDMYUD
RCTM_R_3T  = RCTM_R1 AND MIM_3TDMY
RCTM_R_2T  = RCTM_R NOT MIM_3TDMY
RCTM_R_2TUD = RCTM_RUD NOT MIM_3TDMY
mim_term = SIZE RCTM_R_3T BY 0.005 
mim_psub_via = mim_term AND psub
mim_nw_via   = mim_term AND nxwell

CONNECT  metal9  metal8 BY VIA8
CONNECT  metal8  metal7 BY VIA7
CONNECT  metal8  ctm BY ctm_via
CONNECT  metal8  cbm BY cbm_via
CONNECT  metal6  shield 
CONNECT  metal6  shieldud 
CONNECT  mim_block ctm
SCONNECT psub mim_term BY mim_psub_via
SCONNECT nxwell mim_term BY mim_nw_via


#IFDEF CAP_1P0
DEVICE mimcap_1p0_sin RCTM_R_2T ctm(PLUS) cbm(MINUS) [
  property lt, wt
  A_CAP = area(RCTM_R_2T)
  P_CAP = perimeter(RCTM_R_2T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
]

DEVICE mimcap_1p0_sin_3t RCTM_R_3T ctm(PLUS) cbm(MINUS) mim_term(BULK) [
  property lt,wt,lay
  A_CAP = area(RCTM_R_3T)
  P_CAP = perimeter(RCTM_R_3T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
    lay= 9

]
  TRACE PROPERTY mimcap_1p0_sin_3t lt lt 0
  TRACE PROPERTY mimcap_1p0_sin_3t wt wt 0
  TRACE PROPERTY mimcap_1p0_sin_3t lay lay 0
DEVICE mimcap_1p0_sin RCTM_R_2TUD ctm(PLUS) cbm(MINUS) [
  property lt, wt
  A_CAP = area(RCTM_R_2TUD)
  P_CAP = perimeter(RCTM_R_2TUD)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
]
  TRACE PROPERTY mimcap_1p0_sin lt lt 0
  TRACE PROPERTY mimcap_1p0_sin wt wt 0

#ELSE
 #IFDEF CAP_1P5
DEVICE mimcap_1p5_sin RCTM_R_2T ctm(PLUS) cbm(MINUS) [
  property lt, wt
  A_CAP = area(RCTM_R_2T)
  P_CAP = perimeter(RCTM_R_2T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
]

DEVICE mimcap_1p5_sin_3t RCTM_R_3T ctm(PLUS) cbm(MINUS) mim_term(BULK) [
  property lt,wt,lay
  A_CAP = area(RCTM_R_3T)
  P_CAP = perimeter(RCTM_R_3T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
    lay= 9

]
  TRACE PROPERTY mimcap_1p5_sin_3t lt lt 0
  TRACE PROPERTY mimcap_1p5_sin_3t wt wt 0
  TRACE PROPERTY mimcap_1p5_sin_3t lay lay 0
DEVICE mimcap_1p5_sin RCTM_R_2TUD ctm(PLUS) cbm(MINUS) [
  property lt, wt
  A_CAP = area(RCTM_R_2TUD)
  P_CAP = perimeter(RCTM_R_2TUD)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
]
  TRACE PROPERTY mimcap_1p5_sin lt lt 0
  TRACE PROPERTY mimcap_1p5_sin wt wt 0

 #ELSE
DEVICE mimcap_2p0_sin RCTM_R_2T ctm(PLUS) cbm(MINUS) [
  property lt, wt
  A_CAP = area(RCTM_R_2T)
  P_CAP = perimeter(RCTM_R_2T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
]

DEVICE mimcap_2p0_sin_3t RCTM_R_3T ctm(PLUS) cbm(MINUS) mim_term(BULK) [
  property lt,wt,lay
  A_CAP = area(RCTM_R_3T)
  P_CAP = perimeter(RCTM_R_3T)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
    lay= 9

]
  TRACE PROPERTY mimcap_2p0_sin_3t lt lt 0
  TRACE PROPERTY mimcap_2p0_sin_3t wt wt 0
  TRACE PROPERTY mimcap_2p0_sin_3t lay lay 0
DEVICE mimcap_2p0_sin RCTM_R_2TUD ctm(PLUS) cbm(MINUS) [
  property lt, wt
  A_CAP = area(RCTM_R_2TUD)
  P_CAP = perimeter(RCTM_R_2TUD)
  P_2_CAP = P_CAP * P_CAP
  AC4 = A_CAP * 16
  KKK = P_2_CAP-AC4
  IF(KKK<0) {
  KKK=0
  }
  SQ = sqrt(KKK)
  lt = (P_CAP+SQ)/4
  wt = (P_CAP-SQ)/4
]
  TRACE PROPERTY mimcap_2p0_sin lt lt 0
  TRACE PROPERTY mimcap_2p0_sin wt wt 0

 #ENDIF  
#ENDIF  


// mimcap_1p0_sin

// mimcap_1p0_sin_3t

// mimcap_1p5_sin

// mimcap_1p5_sin_3t

// mimcap_2p0_sin

// mimcap_2p0_sin_3t

L_EG1    = ctm INSIDE EDGE metal8
L_EG_RG1 = EXPAND EDGE L_EG1 OUTSIDE BY 0.005
L_EG     = ctm TOUCH EDGE L_EG_RG1
L_EG_RG = EXPAND EDGE L_EG OUTSIDE BY 0.005


#IFDEF CAP_1P0
DEVICE mimcap_um_1p0_sin_rf RCTM_RF ctm(PLUS) cbm(MINUS) shield(BULK) <L_EG_RG> [
  property lt,wt
  lt = perimeter_coincide(RCTM_RF,L_EG_RG)/2
  wt = area(RCTM_RF)/lt
]

DEVICE mimcap_woum_1p0_sin_rf RCTM_RF_woum ctm(PLUS) cbm(MINUS) nxwell(BULK) <L_EG_RG> [
  property lt,wt,lay
  lt = perimeter_coincide(RCTM_RF_woum,L_EG_RG)/2
  wt = area(RCTM_RF_woum)/lt
  lay= 9
]
  TRACE PROPERTY mimcap_woum_1p0_sin_rf lt lt 0
  TRACE PROPERTY mimcap_woum_1p0_sin_rf wt wt 0
  TRACE PROPERTY mimcap_woum_1p0_sin_rf lay lay 0
DEVICE mimcap_um_1p0_sin_rf RCTM_RFUD ctm(PLUS) cbm(MINUS) shieldud(BULK) <L_EG_RG> [
  property lt,wt
  lt = perimeter_coincide(RCTM_RFUD,L_EG_RG)/2
  wt = area(RCTM_RFUD)/lt
]
  TRACE PROPERTY mimcap_um_1p0_sin_rf lt lt 0
  TRACE PROPERTY mimcap_um_1p0_sin_rf wt wt 0

#ELSE
  #IFDEF CAP_1P5
DEVICE mimcap_um_1p5_sin_rf RCTM_RF ctm(PLUS) cbm(MINUS) shield(BULK) <L_EG_RG> [
  property lt,wt
  lt = perimeter_coincide(RCTM_RF,L_EG_RG)/2
  wt = area(RCTM_RF)/lt
]

DEVICE mimcap_woum_1p5_sin_rf RCTM_RF_woum ctm(PLUS) cbm(MINUS) nxwell(BULK) <L_EG_RG> [
  property lt,wt,lay
  lt = perimeter_coincide(RCTM_RF_woum,L_EG_RG)/2
  wt = area(RCTM_RF_woum)/lt
  lay= 9
]
  TRACE PROPERTY mimcap_woum_1p5_sin_rf lt lt 0
  TRACE PROPERTY mimcap_woum_1p5_sin_rf wt wt 0
  TRACE PROPERTY mimcap_woum_1p5_sin_rf lay lay 0
DEVICE mimcap_um_1p5_sin_rf RCTM_RFUD ctm(PLUS) cbm(MINUS) shieldud(BULK) <L_EG_RG> [
  property lt,wt
  lt = perimeter_coincide(RCTM_RFUD,L_EG_RG)/2
  wt = area(RCTM_RFUD)/lt
]
  TRACE PROPERTY mimcap_um_1p5_sin_rf lt lt 0
  TRACE PROPERTY mimcap_um_1p5_sin_rf wt wt 0

  #ELSE
DEVICE mimcap_um_2p0_sin_rf RCTM_RF ctm(PLUS) cbm(MINUS) shield(BULK) <L_EG_RG> [
  property lt,wt
  lt = perimeter_coincide(RCTM_RF,L_EG_RG)/2
  wt = area(RCTM_RF)/lt
]

DEVICE mimcap_woum_2p0_sin_rf RCTM_RF_woum ctm(PLUS) cbm(MINUS) nxwell(BULK) <L_EG_RG> [
  property lt,wt,lay
  lt = perimeter_coincide(RCTM_RF_woum,L_EG_RG)/2
  wt = area(RCTM_RF_woum)/lt
  lay= 9
]
  TRACE PROPERTY mimcap_woum_2p0_sin_rf lt lt 0
  TRACE PROPERTY mimcap_woum_2p0_sin_rf wt wt 0
  TRACE PROPERTY mimcap_woum_2p0_sin_rf lay lay 0
DEVICE mimcap_um_2p0_sin_rf RCTM_RFUD ctm(PLUS) cbm(MINUS) shieldud(BULK) <L_EG_RG> [
  property lt,wt
  lt = perimeter_coincide(RCTM_RFUD,L_EG_RG)/2
  wt = area(RCTM_RFUD)/lt
]
  TRACE PROPERTY mimcap_um_2p0_sin_rf lt lt 0
  TRACE PROPERTY mimcap_um_2p0_sin_rf wt wt 0

  #ENDIF
#ENDIF



// mimcap_um_1p0_sin_rf

// mimcap_um_1p5_sin_rf

// mimcap_um_2p0_sin_rf

// mimcap_woum_1p0_sin_rf

// mimcap_woum_1p5_sin_rf

// mimcap_woum_2p0_sin_rf

DEVICE moscap_rf var_nw3_rf poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf)
  wr = (perimeter_coincide(vargt_rf,tndiff)/2)/ar
  lr = (area(vargt_rf)/wr)/ar
]
TRACE PROPERTY moscap_rf lr lr 0
TRACE PROPERTY moscap_rf wr wr 0
TRACE PROPERTY moscap_rf br br 0
TRACE PROPERTY moscap_rf gr gr 0

DEVICE moscap_rf18 var_nw_rf18 poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf18> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf18)
  wr = (perimeter_coincide(vargt_rf18,tndiff)/2)/ar
  lr = (area(vargt_rf18)/wr)/ar
]
TRACE PROPERTY moscap_rf18 lr lr 0
TRACE PROPERTY moscap_rf18 wr wr 0
TRACE PROPERTY moscap_rf18 br br 0
TRACE PROPERTY moscap_rf18 gr gr 0

DEVICE moscap_rf18_nw var_nw_rf18_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf18> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf18)
  wr = (perimeter_coincide(vargt_rf18,tndiff)/2)/ar
  lr = (area(vargt_rf18)/wr)/ar
]
TRACE PROPERTY moscap_rf18_nw lr lr 0
TRACE PROPERTY moscap_rf18_nw wr wr 0
TRACE PROPERTY moscap_rf18_nw br br 0
TRACE PROPERTY moscap_rf18_nw gr gr 0

DEVICE moscap_rf25 var_nw_rf25 poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf25> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf25)
  wr = (perimeter_coincide(vargt_rf25,tndiff)/2)/ar
  lr = (area(vargt_rf25)/wr)/ar
]
TRACE PROPERTY moscap_rf25 lr lr 0
TRACE PROPERTY moscap_rf25 wr wr 0
TRACE PROPERTY moscap_rf25 br br 0
TRACE PROPERTY moscap_rf25 gr gr 0

DEVICE moscap_rf25_nw var_nw_rf25_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf25> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf25)
  wr = (perimeter_coincide(vargt_rf25,tndiff)/2)/ar
  lr = (area(vargt_rf25)/wr)/ar
]
TRACE PROPERTY moscap_rf25_nw lr lr 0
TRACE PROPERTY moscap_rf25_nw wr wr 0
TRACE PROPERTY moscap_rf25_nw br br 0
TRACE PROPERTY moscap_rf25_nw gr gr 0

DEVICE moscap_rf33 var_nw_rf33 poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf33> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf33)
  wr = (perimeter_coincide(vargt_rf33,tndiff)/2)/ar
  lr = (area(vargt_rf33)/wr)/ar
]
TRACE PROPERTY moscap_rf33 lr lr 0
TRACE PROPERTY moscap_rf33 wr wr 0
TRACE PROPERTY moscap_rf33 br br 0
TRACE PROPERTY moscap_rf33 gr gr 0

DEVICE moscap_rf33_nw var_nw_rf33_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf33> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf33)
  wr = (perimeter_coincide(vargt_rf33,tndiff)/2)/ar
  lr = (area(vargt_rf33)/wr)/ar
]
TRACE PROPERTY moscap_rf33_nw lr lr 0
TRACE PROPERTY moscap_rf33_nw wr wr 0
TRACE PROPERTY moscap_rf33_nw br br 0
TRACE PROPERTY moscap_rf33_nw gr gr 0

DEVICE moscap_rf_nw var_nw3_rf_nw poly(PLUS) tndiff(MINUS) psub(BULK) <vargt_rf> <poly_vargt> <nthin> [
  property lr,wr,br,gr
  gr = count(nthin)
  br = count(poly_vargt)
  ar = count(vargt_rf)
  wr = (perimeter_coincide(vargt_rf,tndiff)/2)/ar
  lr = (area(vargt_rf)/wr)/ar
]
TRACE PROPERTY moscap_rf_nw lr lr 0
TRACE PROPERTY moscap_rf_nw wr wr 0
TRACE PROPERTY moscap_rf_nw br br 0
TRACE PROPERTY moscap_rf_nw gr gr 0

DEVICE nmos_rf ngate_nthin d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf> [
   property lr,wr,nr
   nr = count(ngate_rf)
   wr = ((perimeter_coincide(ngate_rf,s_tndiff)+ perimeter_coincide(ngate_rf,d_tndiff))/2)/nr
   lr = (area(ngate_rf)/wr)/nr
]
TRACE PROPERTY nmos_rf wr wr 0
TRACE PROPERTY nmos_rf lr lr 0
TRACE PROPERTY nmos_rf nr nr 0

DEVICE nmos_rf18 ngate_nthin_io18 d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_18> [
   property lr,wr,nr
   nr = count(ngate_rf_18)
   wr = ((perimeter_coincide(ngate_rf_18,s_tndiff)+ perimeter_coincide(ngate_rf_18,d_tndiff))/2)/nr
   lr = (area(ngate_rf_18)/wr)/nr
]
TRACE PROPERTY nmos_rf18 wr wr 0
TRACE PROPERTY nmos_rf18 lr lr 0
TRACE PROPERTY nmos_rf18 nr nr 0

DEVICE nmos_rf25 ngate_nthin_io25 d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_25> [
   property lr,wr,nr
   nr = count(ngate_rf_25)
   wr = ((perimeter_coincide(ngate_rf_25,s_tndiff)+ perimeter_coincide(ngate_rf_25,d_tndiff))/2)/nr
   lr = (area(ngate_rf_25)/wr)/nr
]
TRACE PROPERTY nmos_rf25 wr wr 0
TRACE PROPERTY nmos_rf25 lr lr 0
TRACE PROPERTY nmos_rf25 nr nr 0

DEVICE nmos_rf33 ngate_nthin_io33 d_tndiff(D) poly_rf(G) s_tndiff(S) psub(B) <ngate_rf_33> [
   property lr,wr,nr
   nr = count(ngate_rf_33)
   wr = ((perimeter_coincide(ngate_rf_33,s_tndiff)+ perimeter_coincide(ngate_rf_33,d_tndiff))/2)/nr
   lr = (area(ngate_rf_33)/wr)/nr
]
TRACE PROPERTY nmos_rf33 wr wr 0
TRACE PROPERTY nmos_rf33 lr lr 0
TRACE PROPERTY nmos_rf33 nr nr 0

DEVICE nmoscap vargt poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap [
   property lr,wr
   nr = count(vargt)
   sw = count(tndiff)
   if(sw < 2) {
   lr = perimeter_coincide(vargt,nthin)/nr
   a  = area(vargt)/nr
   wr = a/lr
   }else {
   wr = perimeter_inside(vargt,nthin)/2/nr
   lr = area(vargt)/wr/nr
   }
]
TRACE PROPERTY nmoscap wr wr 0
TRACE PROPERTY nmoscap lr lr 0

DEVICE nmoscap_18 vargt_18 poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap_18 [
   property lr,wr
   nr = count(vargt_18)
   sw = count(tndiff)
   if(sw < 2) {
   lr = perimeter_coincide(vargt_18,nthin)/nr
   a  = area(vargt_18)/nr
   wr = a/lr
   }else {
   wr = perimeter_inside(vargt_18,nthin)/2/nr
   lr = area(vargt_18)/wr/nr
   }
]
TRACE PROPERTY nmoscap_18 wr wr 0
TRACE PROPERTY nmoscap_18 lr lr 0

DEVICE nmoscap_25 vargt_25 poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap_25 [
   property lr,wr
   nr = count(vargt_25)
   sw = count(tndiff)
   if(sw < 2) {
   lr = perimeter_coincide(vargt_25,nthin)/nr
   a  = area(vargt_25)/nr
   wr = a/lr
   }else {
   wr = perimeter_inside(vargt_25,nthin)/2/nr
   lr = area(vargt_25)/wr/nr
   }
]
TRACE PROPERTY nmoscap_25 wr wr 0
TRACE PROPERTY nmoscap_25 lr lr 0

DEVICE nmoscap_33 vargt_33 poly(PLUS) tndiff(MINUS) <nthin> netlist model nmoscap_33 [
   property lr,wr
   nr = count(vargt_33)
   sw = count(tndiff)
   if(sw < 2) {
   lr = perimeter_coincide(vargt_33,nthin)/nr
   a  = area(vargt_33)/nr
   wr = a/lr
   }else {
   wr = perimeter_inside(vargt_33,nthin)/2/nr
   lr = area(vargt_33)/wr/nr
   }
]
TRACE PROPERTY nmoscap_33 wr wr 0
TRACE PROPERTY nmoscap_33 lr lr 0

DEVICE pmos_rf pgate_pthin d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf> [
   property lr,wr,nr
   nr = count(pgate_rf)
   wr = ((perimeter_coincide(pgate_rf,s_tpdiff)+ perimeter_coincide(pgate_rf,d_tpdiff))/2)/nr
   lr = (area(pgate_rf)/wr)/nr
]
TRACE PROPERTY pmos_rf wr wr 0
TRACE PROPERTY pmos_rf lr lr 0
TRACE PROPERTY pmos_rf nr nr 0

DEVICE pmos_rf18 pgate_pthin_io18 d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_18> [
   property lr,wr,nr
   nr = count(pgate_rf_18)
   wr = ((perimeter_coincide(pgate_rf_18,s_tpdiff)+ perimeter_coincide(pgate_rf_18,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_18)/wr)/nr
]
TRACE PROPERTY pmos_rf18 wr wr 0
TRACE PROPERTY pmos_rf18 lr lr 0
TRACE PROPERTY pmos_rf18 nr nr 0

DEVICE pmos_rf25 pgate_pthin_io25 d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_25> [
   property lr,wr,nr
   nr = count(pgate_rf_25)
   wr = ((perimeter_coincide(pgate_rf_25,s_tpdiff)+ perimeter_coincide(pgate_rf_25,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_25)/wr)/nr
]
TRACE PROPERTY pmos_rf25 wr wr 0
TRACE PROPERTY pmos_rf25 lr lr 0
TRACE PROPERTY pmos_rf25 nr nr 0

DEVICE pmos_rf33 pgate_pthin_io33 d_tpdiff(D) poly_rf(G) s_tpdiff(S) nxwell(B) <pgate_rf_33> [
   property lr,wr,nr
   nr = count(pgate_rf_33)
   wr = ((perimeter_coincide(pgate_rf_33,s_tpdiff)+ perimeter_coincide(pgate_rf_33,d_tpdiff))/2)/nr
   lr = (area(pgate_rf_33)/wr)/nr
]
TRACE PROPERTY pmos_rf33 wr wr 0
TRACE PROPERTY pmos_rf33 lr lr 0
TRACE PROPERTY pmos_rf33 nr nr 0

#IFDEF extract_dnwdio
DEVICE D(pwdnw) rwdio psub DNW [
   property a,pj
   a = area(rwdio)
   pj = perimeter(rwdio)
]   
TRACE PROPERTY D(pwdnw) a a 0
#ENDIF

DEVICE rm1 mt1res metal1(PLUS) metal1(MINUS) (PLUS MINUS) NETLIST MODEL rm1w [
   property w,l
   w = perimeter_coincide(mt1res,metal1)/2
   l = area(mt1res)/w
]
TRACE PROPERTY rm1 w w 0
TRACE PROPERTY rm1 l l 0

DEVICE rm10 mt10res metal10(PLUS) metal10(MINUS) (PLUS MINUS) NETLIST MODEL rm10w [
   property w,l
   w = perimeter_coincide(mt10res,metal10)/2
   l = area(mt10res)/w
]
TRACE PROPERTY rm10 w w 0
TRACE PROPERTY rm10 l l 0

DEVICE rm2 mt2res metal2(PLUS) metal2(MINUS) (PLUS MINUS) NETLIST MODEL rm2_7w [
   property w,l
   w = perimeter_coincide(mt2res,metal2)/2
   l = area(mt2res)/w
]
TRACE PROPERTY rm2 w w 0
TRACE PROPERTY rm2 l l 0

DEVICE rm3 mt3res metal3(PLUS) metal3(MINUS) (PLUS MINUS) NETLIST MODEL rm2_7w [
   property w,l
   w = perimeter_coincide(mt3res,metal3)/2
   l = area(mt3res)/w
]
TRACE PROPERTY rm3 w w 0
TRACE PROPERTY rm3 l l 0

DEVICE rm4 mt4res metal4(PLUS) metal4(MINUS) (PLUS MINUS) NETLIST MODEL rm2_7w [
   property w,l
   w = perimeter_coincide(mt4res,metal4)/2
   l = area(mt4res)/w
]
TRACE PROPERTY rm4 w w 0
TRACE PROPERTY rm4 l l 0

DEVICE rm5 mt5res metal5(PLUS) metal5(MINUS) (PLUS MINUS) NETLIST MODEL rm2_7w [
   property w,l
   w = perimeter_coincide(mt5res,metal5)/2
   l = area(mt5res)/w
]
TRACE PROPERTY rm5 w w 0
TRACE PROPERTY rm5 l l 0

DEVICE rm6 mt6res metal6(PLUS) metal6(MINUS) (PLUS MINUS) NETLIST MODEL rm2_7w [
   property w,l
   w = perimeter_coincide(mt6res,metal6)/2
   l = area(mt6res)/w
]
TRACE PROPERTY rm6 w w 0
TRACE PROPERTY rm6 l l 0

DEVICE rm7 mt7res metal7(PLUS) metal7(MINUS) (PLUS MINUS) NETLIST MODEL rm2_7w [
   property w,l
   w = perimeter_coincide(mt7res,metal7)/2
   l = area(mt7res)/w
]
TRACE PROPERTY rm7 w w 0
TRACE PROPERTY rm7 l l 0


 DEVICE rm8 mt8res metal8(PLUS) metal8(MINUS) (PLUS MINUS) NETLIST MODEL rm8_9w [
   property w,l
   w = perimeter_coincide(mt8res,metal8)/2
   l = area(mt8res)/w
]
TRACE PROPERTY rm8 w w 0
TRACE PROPERTY rm8 l l 0

DEVICE rm9 mt9res metal9(PLUS) metal9(MINUS) (PLUS MINUS) NETLIST MODEL rmt [
   property w,l
   w = perimeter_coincide(mt9res,metal9)/2
   l = area(mt9res)/w
]
TRACE PROPERTY rm9 w w 0
TRACE PROPERTY rm9 l l 0

DEVICE rnodl rnodl_r tndiff(PLUS) tndiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnodl_r,tndiff)/2
   l = area(rnodl_r)/w
]
TRACE PROPERTY rnodl l l 0
TRACE PROPERTY rnodl w w 0

DEVICE rnodl_m rnodl_mr tndiff(PLUS) tndiff(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnodl_mr,tndiff)/2
   lr = area(rnodl_mr)/wr
]
TRACE PROPERTY rnodl_m lr lr 0
TRACE PROPERTY rnodl_m wr wr 0

DEVICE rnods rnods_r tndiff(PLUS) tndiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnods_r,tndiff)/2
   l = area(rnods_r)/w
]
TRACE PROPERTY rnods l l 0
TRACE PROPERTY rnods w w 0

DEVICE rnods_m rnods_mr tndiff(PLUS) tndiff(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnods_mr,tndiff)/2
   lr = area(rnods_mr)/wr
]
TRACE PROPERTY rnods_m lr lr 0
TRACE PROPERTY rnods_m wr wr 0

DEVICE rnodwo rnodwo_r tndiff(PLUS) tndiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnodwo_r,tndiff)/2
   l = area(rnodwo_r)/w
]
TRACE PROPERTY rnodwo l l 0
TRACE PROPERTY rnodwo w w 0

DEVICE rnodwo_m rnodwo_mr tndiff(PLUS) tndiff(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rnodwo_mr,tndiff)/2
   lr = area(rnodwo_mr)/wr
]
TRACE PROPERTY rnodwo_m lr lr 0
TRACE PROPERTY rnodwo_m wr wr 0

DEVICE rnpolyl rnpolyl_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolyl_r,poly)/2
   l = area(rnpolyl_r)/w
]
TRACE PROPERTY rnpolyl l l 0
TRACE PROPERTY rnpolyl w w 0

DEVICE rnpolyl_dis rnpolyl_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolyl_d,poly)/2
   l = area(rnpolyl_d)/w
]
TRACE PROPERTY rnpolyl_dis l l 0
TRACE PROPERTY rnpolyl_dis w w 0

DEVICE rnpolys rnpolys_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolys_r,poly)/2
   l = area(rnpolys_r)/w
]
TRACE PROPERTY rnpolys l l 0
TRACE PROPERTY rnpolys w w 0

DEVICE rnpolys_dis rnpolys_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolys_d,poly)/2
   l = area(rnpolys_d)/w
]
TRACE PROPERTY rnpolys_dis l l 0
TRACE PROPERTY rnpolys_dis w w 0

DEVICE rnpolywo rnpolywo_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolywo_r,poly)/2
   l = area(rnpolywo_r)/w
]
TRACE PROPERTY rnpolywo l l 0
TRACE PROPERTY rnpolywo w w 0

DEVICE rnpolywo_dis rnpolywo_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rnpolywo_d,poly)/2
   l = area(rnpolywo_d)/w
]
TRACE PROPERTY rnpolywo_dis l l 0
TRACE PROPERTY rnpolywo_dis w w 0

DEVICE rnwod nwod_r nxwell(PLUS) nxwell(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(nwod_r,nxwell)/2
   l = area(nwod_r)/w
]
TRACE PROPERTY rnwod l l 0
TRACE PROPERTY rnwod w w 0

DEVICE rnwod_m nwod_mr nxwell(PLUS) nxwell(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(nwod_mr,nxwell)/2
   lr = area(nwod_mr)/wr
]
TRACE PROPERTY rnwod_m lr lr 0
TRACE PROPERTY rnwod_m wr wr 0

DEVICE rnwsti nwsti_r nxwell(PLUS) nxwell(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(nwsti_r,nxwell)/2
   l = area(nwsti_r)/w
]
TRACE PROPERTY rnwsti l l 0
TRACE PROPERTY rnwsti w w 0

DEVICE rnwsti_m nwsti_mr nxwell(PLUS) nxwell(MINUS) psub(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(nwsti_mr,nxwell)/2
   lr = area(nwsti_mr)/wr
]
TRACE PROPERTY rnwsti_m lr lr 0
TRACE PROPERTY rnwsti_m wr wr 0

DEVICE rpodl rpodl_r tpdiff(PLUS) tpdiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rpodl_r,tpdiff)/2
   l = area(rpodl_r)/w
]
TRACE PROPERTY rpodl l l 0
TRACE PROPERTY rpodl w w 0

DEVICE rpodl_m rpodl_mr tpdiff(PLUS) tpdiff(MINUS) nxwell(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rpodl_mr,tpdiff)/2
   lr = area(rpodl_mr)/wr
]
TRACE PROPERTY rpodl_m lr lr 0
TRACE PROPERTY rpodl_m wr wr 0

DEVICE rpods rpods_r tpdiff(PLUS) tpdiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rpods_r,tpdiff)/2
   l = area(rpods_r)/w
]
TRACE PROPERTY rpods l l 0
TRACE PROPERTY rpods w w 0

DEVICE rpods_m rpods_mr tpdiff(PLUS) tpdiff(MINUS) nxwell(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rpods_mr,tpdiff)/2
   lr = area(rpods_mr)/wr
]
TRACE PROPERTY rpods_m lr lr 0
TRACE PROPERTY rpods_m wr wr 0

DEVICE rpodwo rpodwo_r tpdiff(PLUS) tpdiff(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rpodwo_r,tpdiff)/2
   l = area(rpodwo_r)/w
]
TRACE PROPERTY rpodwo l l 0
TRACE PROPERTY rpodwo w w 0

DEVICE rpodwo_m rpodwo_mr tpdiff(PLUS) tpdiff(MINUS) nxwell(BULK) (PLUS MINUS) [
   property lr,wr 
   wr = perimeter_coincide(rpodwo_mr,tpdiff)/2
   lr = area(rpodwo_mr)/wr
]
TRACE PROPERTY rpodwo_m lr lr 0
TRACE PROPERTY rpodwo_m wr wr 0

DEVICE rppolyl rppolyl_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolyl_r,poly)/2
   l = area(rppolyl_r)/w
]
TRACE PROPERTY rppolyl l l 0
TRACE PROPERTY rppolyl w w 0

DEVICE rppolyl_dis rppolyl_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolyl_d,poly)/2
   l = area(rppolyl_d)/w
]
TRACE PROPERTY rppolyl_dis l l 0
TRACE PROPERTY rppolyl_dis w w 0

DEVICE rppolyl_rf rppolyl_rf poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolyl_rf,poly)/2
   l = area(rppolyl_rf)/w
]
TRACE PROPERTY rppolyl_rf l l 0
TRACE PROPERTY rppolyl_rf w w 0

DEVICE rppolys rppolys_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolys_r,poly)/2
   l = area(rppolys_r)/w
]
TRACE PROPERTY rppolys l l 0
TRACE PROPERTY rppolys w w 0

DEVICE rppolys_dis rppolys_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolys_d,poly)/2
   l = area(rppolys_d)/w
]
TRACE PROPERTY rppolys_dis l l 0
TRACE PROPERTY rppolys_dis w w 0

DEVICE rppolys_rf rppolys_rf poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolys_rf,poly)/2
   l = area(rppolys_rf)/w
]
TRACE PROPERTY rppolys_rf l l 0
TRACE PROPERTY rppolys_rf w w 0

DEVICE rppolywo rppolywo_r poly(PLUS) poly(MINUS) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolywo_r,poly)/2
   l = area(rppolywo_r)/w
]
TRACE PROPERTY rppolywo l l 0
TRACE PROPERTY rppolywo w w 0

DEVICE rppolywo_dis rppolywo_d poly(PLUS) poly(MINUS) poly_term(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolywo_d,poly)/2
   l = area(rppolywo_d)/w
]
TRACE PROPERTY rppolywo_dis l l 0
TRACE PROPERTY rppolywo_dis w w 0

DEVICE rppolywo_rf rppolywo_rf poly(PLUS) poly(MINUS) nxwell(BULK) (PLUS MINUS) [
   property l,w 
   w = perimeter_coincide(rppolywo_rf,poly)/2
   l = area(rppolywo_rf)/w
]
TRACE PROPERTY rppolywo_rf l l 0
TRACE PROPERTY rppolywo_rf w w 0

sbd_w = EXT schottky_p schottky_n < 0.325 OPPOSITE REGION
DEVICE sbd_rf sbd_rfdnw schottky_p(PLUS) schottky_n(MINUS) psub(BULK) <sbd_w> [
   property l,w,nf
   nf = count(schottky_p)
   w = perimeter_coincide(schottky_p,sbd_w)/2/nf
   l = area(schottky_p)/w/nf

]
TRACE PROPERTY sbd_rf nf nf 0
TRACE PROPERTY sbd_rf w w 0
TRACE PROPERTY sbd_rf l l 0

DEVICE sbd_rf_nw sbd_rfnw schottky_p(PLUS) schottky_n(MINUS) psub(BULK) <sbd_w> [
   property l,w,nf
   nf = count(schottky_p)
   w = perimeter_coincide(schottky_p,sbd_w)/2/nf
   l = area(schottky_p)/w/nf

]
TRACE PROPERTY sbd_rf_nw nf nf 0
TRACE PROPERTY sbd_rf_nw w w 0
TRACE PROPERTY sbd_rf_nw l l 0

std_w1 = INT std_ind < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
std_w  = ( RECTANGLE std_w1 ORTHOGONAL ONLY ) NOT INTERACT metal9
sz_ind_std = SIZE IND_STD BY -50
std_nr0 = std_ind1 INTERACT IND_RAD
std_nr1 = INT std_nr0 < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED
std_nr2 =  RECTANGLE std_nr1 ORTHOGONAL ONLY
std_nr3 = std_nr2 INSIDE sz_ind_std
std_nr4 = std_nr2 NOT std_nr3
std_nr5 = std_nr2 NOT std_nr4
std_nr6 = SIZE std_nr4 BY 0.001
std_nr7 = std_nr6 INTERACT std_nr5
std_nr = std_nr2 NOT std_nr7
std_w_m1 = SIZE IND_STD BY 0.005
std_w_m2 = std_w_m1 AND M9X 
std_w_m3 = std_w_m1 AND M8X
std_w_m4 = std_w_m3 OR std_w_m2
std_w_m5 = std_w_m4 OUTSIDE IND_STD
std_w_m = std_w_m4 NOT std_w_m5
DEVICE spiral_std std_ind metal9(PLUS) metal9(MINUS) psub(BULK) <IND_RAD> <std_nr> <std_w> <std_w_m> [
   PROPERTY w,nr,rad,lay
   lay = 9
   nnr = count(std_nr)
   nr = (nnr-1)/4
   rad = (perimeter(IND_RAD) - (perimeter_coincide(IND_RAD,std_ind)*2))/2
   nw = count(std_w)
   w = (perimeter_inside(std_w,std_w_m))/(nw*2)
]
  TRACE PROPERTY spiral_std lay lay 0
  TRACE PROPERTY spiral_std w w 0
  TRACE PROPERTY spiral_std nr nr 0
  TRACE PROPERTY spiral_std rad rad 0
  

STD_IND_CHECK { @ VIA8 is needed for connection of M9 and M8 in Std. inductor.
  A = std_ind1 NOT INTERACT IND_RAD
  B = A AND std_ind2
  B NOT INTERACT VIA8
  C = std_ind_m INTERACT IND_RAD
  C NOT INTERACT VIA8
}

sym_w1 = INT sym_ind < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
sym_w2 = ( RECTANGLE sym_w1 ORTHOGONAL ONLY ) NOT INTERACT metal9
sym_w  = sym_w2 NOT INTERACT sym_ind2
DEVICE spiral_sym sym_ind metal9(PLUS) metal9(MINUS) psub(BULK) <IND_RAD> <ind_btm> <sym_w> [
   PROPERTY w,nr,rad,lay
   lay = 9
   nr = ((count(ind_btm)-1)/2)+1 
   rad = (perimeter(IND_RAD) - (perimeter_coincide(IND_RAD,sym_ind)*2))/2
   nw = count(sym_w)
   w = (perimeter_inside(sym_w,sym_ind))/(nw*2)
]
  TRACE PROPERTY spiral_sym lay lay 0
  TRACE PROPERTY spiral_sym w w 0
  TRACE PROPERTY spiral_sym nr nr 0
  TRACE PROPERTY spiral_sym rad rad 0
  

SYM_IND_CHECK { @ VIA8 is needed for connection of M9 and M8 in Sym. inductor.
  A = RECTANGLE sym_ind_m ORTHOGONAL ONLY
  A NOT INTERACT VIA8
}

ct_w1 = INT ct_inda < 31 OPPOSITE REGION PARALLEL ONLY EXCLUDE SHIELDED // "31" is a trade number from spice model
ct_w = ( RECTANGLE ct_w1 ORTHOGONAL ONLY ) NOT INTERACT metal9
DEVICE spiral_sym_ct ct_ind metal9(PLUS) metal9(MINUS) psub(BULK) metal7(CTAP) <IND_RAD> <ind_btm_ct> <ct_inda> <ct_w> [
   PROPERTY w,nr,rad,lay
   lay = 9
   nr = ((count(ind_btm_ct)-1)/2)+1 
   rad = (perimeter(IND_RAD) - (perimeter_coincide(IND_RAD,ct_inda)*2))/2
   nw = count(ct_w)
   w = (perimeter_inside(ct_w,ct_inda))/(nw*2)
]
  TRACE PROPERTY spiral_sym_ct lay lay 0
  TRACE PROPERTY spiral_sym_ct w w 0
  TRACE PROPERTY spiral_sym_ct nr nr 0
  TRACE PROPERTY spiral_sym_ct rad rad 0


CT_IND_CHECK { @ VIA8 is needed for connection of M9 and M8 in Cnt. inductor.
  A = RECTANGLE ct_ind_m ORTHOGONAL ONLY
  A NOT INTERACT VIA8
}

tpdiff_jvar = tpdiff AND jvar_rf1
tndiff_jvar = tndiff AND jvar_rf1
w_fac = EXT tpdiff_jvar tndiff_jvar < 0.29 OPPOSITE REGION

DEVICE xjvar jvar_rfdnw tpdiff(PLUS) tndiff(MINUS) psub(BULK) <w_fac> <jvar3_rf> [
   property l,w,nr
   nr = count(jvar3_rf)
   w = (perimeter_coincide(jvar3_rf,w_fac)/nr)/2
   l = (area(jvar3_rf)/w)/nr
]
TRACE PROPERTY xjvar w w 0
TRACE PROPERTY xjvar l l 0
TRACE PROPERTY xjvar nr nr 0

tpdiff_jvar1 = tpdiff AND jvar_rf1
tndiff_jvar1 = tndiff AND jvar_rf1
w_fac1 = EXT tpdiff_jvar1 tndiff_jvar1 < 0.29 OPPOSITE REGION

DEVICE xjvar_nw jvar_rf tpdiff(PLUS) tndiff(MINUS) psub(BULK) <w_fac> <jvar3_rf> [
   property l,w,nr
   nr = count(jvar3_rf)
   w = (perimeter_coincide(jvar3_rf,w_fac)/nr)/2
   l = (area(jvar3_rf)/w)/nr
]
TRACE PROPERTY xjvar_nw w w 0
TRACE PROPERTY xjvar_nw l l 0
TRACE PROPERTY xjvar_nw nr nr 0

TVF FUNCTION device_function [/*

    package require CalibreLVS_DEVICE_DFM
    namespace import device::*
    proc catching_expr { arg } {
      	#puts "called catching_expr"
      	set rtval 0.0
      	if { [ catch {
            set rtval [ expr $arg ]
      	} result ] } {
            global errorCode
            set tmpError $errorCode
            #puts $result
            if { [ string match "ARITH UNDERFLOW *" $errorCode ] } {
            	#puts "$errorCode error caught during expr"
            	set rtval 0.0
            } elseif { [ string match "ARITH OVERFLOW *" $errorCode ] } {
	    	#puts "$errorCode error caught during expr"
            	set rtval 1e200
            } else {
            	#puts "error propagated during expr"
            	error $result $tmpError
            }
      	}
      	return $rtval
    }

    proc calc_sca { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set sca_sum1 0.0
  	set sca_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]

  	for { set i 0 } { $i < $slice_count1} { incr i } {
       	    set sca_sum1 [ expr { $sca_sum1 + ( ([$SCALE]*[$SCH w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))) +  ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$LR_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))))) }]
       	}

  	for { set i 0 } { $i < $slice_count2} { incr i } {
            set sca_sum2 [ expr { $sca_sum2 + ( ([$SCALE]*[$SCV w $i]) * ( ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$BOT_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))) + ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$TOP_EXT]))) - ($SCref * $SCref/([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))))) }]
       	}

  	return [ expr { ($sca_sum1 + $sca_sum2) / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) * 1e12) }]
    }

    proc calc_scb {  SCH SCV W  L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scb_sum1 0.0
	set scb_sum2 0.0
  	set SCref 1.0
  	set slice_count1 [ $SCH slice_count ]
  	set slice_count2 [ $SCV slice_count ]
  	for { set i 0 } { $i < $slice_count1} { incr i } {
  	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
    	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
   	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
  	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scb_sum1 [ expr { $scb_sum1 + ( ([$SCALE]*[ $SCH w $i ])*1e6 * (   (([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6*($exp_term3/10)) - (($SCref*($exp_term4/100))) + (([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
   	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-10*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-10*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scb_sum2 [ expr { $scb_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/10)) +   ($SCref*($exp_term2/100)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/10)) - ($SCref*($exp_term4/100)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/10)) +   ($SCref*($exp_term6/100)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/10)) - ($SCref*($exp_term8/100))       )) } ]
     	}
	return [ expr { ( $scb_sum1 + $scb_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }

    proc calc_scc { SCH SCV W L LR_EXT TOP_EXT BOT_EXT SCALE } {
  	set scc_sum1 0.0
	set scc_sum2 0.0
	set SCref 1.0
	set slice_count1 [ $SCH slice_count ]
	set slice_count2 [ $SCV slice_count ]
	for { set i 0 } { $i < $slice_count1} { incr i } { 
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCH a $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCH b $i]+[$L]+[$LR_EXT]))*1e6/$SCref) " ]
	    set scc_sum1 [ expr { $scc_sum1 + ( ([$SCALE]*[$SCH w $i])*1e6 * (   (([$SCALE]*([$SCH a $i]+ [$LR_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCH a $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCH b $i]+ [$LR_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCH b $i]+[$L]+ [$LR_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	for { set i 0 } { $i < $slice_count2} { incr i } {
	    set exp_term1 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term2 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term3 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term4 [ catching_expr " exp(-20*([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6/$SCref) " ]
	    set exp_term5 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term6 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term7 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set exp_term8 [ catching_expr " exp(-20*([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6/$SCref) " ]
	    set scc_sum2 [ expr { $scc_sum2 + ( ([$SCALE]*[$SCV w $i])*1e6 * (   (([$SCALE]*([$SCV a $i]+[$BOT_EXT]))*1e6*( $exp_term1/20)) +   ($SCref*($exp_term2/400)) - (([$SCALE]*([$SCV a $i]+[$W]+[$BOT_EXT]))*1e6*($exp_term3/20)) - ($SCref*($exp_term4/400)) + (([$SCALE]*([$SCV b $i]+[$TOP_EXT]))*1e6*( $exp_term5/20)) +   ($SCref*($exp_term6/400)) - (([$SCALE]*([$SCV b $i]+[$W]+[$TOP_EXT]))*1e6*($exp_term7/20)) - ($SCref*($exp_term8/400))       )) } ]
	}
	return [ expr { ( $scc_sum1 + $scc_sum2)  / ( (([$SCALE]*[$W]) * ([$SCALE]*[$L])) *1e12) }]
    }
*/]
// Serve X-resistor as an built-in resistor (for PATHCHK)
LVS DEVICE TYPE RESISTOR rm1 rm10 rm2 rm3 rm4 rm5 rm6 rm7 rm8 rm9 rnodl rnodl_m rnods rnods_m rnodwo rnodwo_m rnpolyl rnpolyl_dis rnpolys rnpolys_dis rnpolywo rnpolywo_dis rnwod rnwod_m rnwsti rnwsti_m rpodl rpodl_m rpods rpods_m rpodwo rpodwo_m rppolyl rppolyl_dis rppolyl_rf rppolys rppolys_dis rppolys_rf rppolywo rppolywo_dis rppolywo_rf [POS=PLUS NEG=MINUS]
LVS REDUCE rppolyl_rf PARALLEL NO
LVS REDUCE rppolyl_rf SERIES PLUS MINUS NO
LVS REDUCE rppolys_rf PARALLEL NO
LVS REDUCE rppolys_rf SERIES PLUS MINUS NO
LVS REDUCE rppolywo_rf PARALLEL NO
LVS REDUCE rppolywo_rf SERIES PLUS MINUS NO

#IFDEF RC_DECK
//=============================
//======= Setup for PEX =======
//=============================
MASK SVDB DIRECTORY "svdb" XRC
PEX MAGNIFY 1.0
//PEX DELAY                      none   //PENFIELD 0.7 MASK DIRECT
PEX EXCLUDE DISTRIBUTED        "VDD" "AVDD" "VD33" "VDDSA" "VDDPST" "VDD5V" MASK DIRECT
PEX EXCLUDE LUMPED             "VDD" "AVDD" "VD33" "VDDSA" "VDDPST" "VDD5V" MASK DIRECT
PEX NETLIST DISTRIBUTED        "net.dist" HSPICE LAYOUT GROUND VSS MASK DIRECT LOCATION RCNAMED
PEX NETLIST LUMPED             "temp.spi" HSPICE LAYOUT GROUND VSS MASK DIRECT LOCATION RCNAMED
PEX NETLIST SIMPLE             "net.simple" HSPICE LAYOUT MASK DIRECT LOCATION RCNAMED
//Back-annotation xcalibre flow
//PEX NETLIST DISTRIBUTED        "net.dist" HSPICE SOURCE GROUND VSS MASK DIRECT LOCATION RCNAMED
//PEX NETLIST LUMPED             "temp.spi" HSPICE SOURCE GROUND VSS MASK DIRECT LOCATION RCNAMED
//PEX NETLIST SIMPLE             "net.simple" HSPICE SOURCE MASK DIRECT LOCATION RCNAMED

PEX REPORT DISTRIBUTED         none  //"report.dist" ASCII LAYOUT MASK DIRECT
PEX REPORT LUMPED              none  //"report.lump" LAYOUT MASK DIRECT
//PEX RESISTANCE LUMPED          YES MASK DIRECT
//PEX REDUCE LUMPED C            < 10000000
PEX IDEAL XCELL                YES

// xcalibre capacitance and resistance file 
UNIT CAPACITANCE ff
UNIT RESISTANCE OHM
include ./Calibre/rcx/rules


#ELSE

//#############################################
//# ERC CHECK                                 #
//#############################################
// Reports regions on a DNW layer that connect to more than one node.
LVS SOFTCHK DNW CONTACT
// Reports regions on a poly_term layer that connect to more than one node.
LVS SOFTCHK poly_term CONTACT
// Reports regions on a poly_term layer that connect to more than one node.
LVS SOFTCHK poly_term CONTACT
// Reports regions on a nxwell layer that connect to more than one node.
LVS SOFTCHK nxwell CONTACT
// Reports regions on a coll1 layer that connect to more than one node.
LVS SOFTCHK coll1 CONTACT
// Reports regions on a n_psub layer that connect to more than one node.
#IFNDEF NW_RING
	LVS SOFTCHK n_psub CONTACT
#ENDIF
// Reports regions on a psub layer that connect to more than one node.
LVS SOFTCHK psub CONTACT
// Reports regions on a psub_term layer that connect to more than one node.
LVS SOFTCHK psub_term CONTACT

#IFDEF WELL_TO_PG_CHECK
GROUP ERC_WELL_TO_PG_CHECK  npvss49 ppvdd49
ERC SELECT CHECK ERC_WELL_TO_PG_CHECK
#ENDIF

#IFDEF GATE_TO_PG_CHECK
GROUP ERC_GATE_TO_PG_CHECK  npgnd50 pppow50
ERC SELECT CHECK ERC_GATE_TO_PG_CHECK
#ENDIF

#IFDEF DS_TO_PG_CHECK
GROUP ERC_DS_TO_PG_CHECK  mnpg mppg
ERC SELECT CHECK ERC_DS_TO_PG_CHECK
#ENDIF

#IFDEF FLOATING_WELL_CHECK
GROUP ERC_FLOATING_WELL_CHECK  floating.nxwell_float floating.psub
ERC SELECT CHECK ERC_FLOATING_WELL_CHECK
#ENDIF

//MOS erc_nmos_gates S/D connect to POWER&GROUND --mnpg*/
N1tndiff = NET tndiff POWER_NAME
T1tndiff = erc_nmos_gates TOUCH N1tndiff
N2tndiff = NET tndiff GROUND_NAME
T2tndiff = erc_nmos_gates TOUCH N2tndiff

#IFDEF DS_TO_PG_CHECK
mnpg { @ MOS connected to both power and ground
  T1tndiff AND T2tndiff
}
#ENDIF

//MOS erc_pmos_gates S/D connect to POWER&GROUND --mppg*/
N1tpdiff = NET tpdiff POWER_NAME
T1tpdiff = erc_pmos_gates TOUCH N1tpdiff
N2tpdiff = NET tpdiff GROUND_NAME
T2tpdiff = erc_pmos_gates TOUCH N2tpdiff

#IFDEF DS_TO_PG_CHECK
mppg { @ MOS connected to both power and ground
  T1tpdiff AND T2tpdiff
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
SCONNECT tndiff nxwell_float by nplug
floating.nxwell_float { @ Floating nxwell_float is not allowed
  PATHCHK !POWER nxwell_float PORTS ALSO
}
#ENDIF

#IFDEF FLOATING_WELL_CHECK
floating.psub { @ Floating psub is not allowed
  PATHCHK !GROUND psub PORTS ALSO
}
#ENDIF
gate_erc_GND = NET gate_erc_not_IO2 GROUND_NAME

#IFDEF GATE_TO_PG_CHECK
// gate_erc connect to ground 
npgnd50 { @ gate_erc connected to GROUND
  gate_erc_GND1 = gate_erc_GND INTERACT N2tndiff == 2
  gate_erc_GND NOT gate_erc_GND1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ntap connect to ground 
npvss49 { @ ntap connected to GROUND
  ntap_not_var = ntap NOT VAR
  NET ntap_not_var GROUND_NAME
}
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to ground but not power 
ERC PATHCHK GROUND && !POWER
#ENDIF

#IFDEF PATH_CHECK
// Nodes with a path to power but not ground 
ERC PATHCHK POWER && !GROUND
#ENDIF

#IFDEF PATH_CHECK
// Nodes without a path to power and ground 
ERC PATHCHK !POWER && !GROUND NOFLOAT
#ENDIF

#IFDEF PATH_CHECK
ERC PATHCHK !LABELED NOFLOAT
#ENDIF
gate_erc_not_IO1 = gate_erc NOT OD25
gate_erc_not_IO2 = gate_erc_not_IO1 NOT OD33
CONNECT gate_erc_not_IO2 poly
gate_erc_PWR = NET gate_erc_not_IO2 POWER_NAME

#IFDEF GATE_TO_PG_CHECK
// gate_erc connect to power 
pppow50 { @ gate_erc connected to POWER
  gate_erc_PWR1 = gate_erc_PWR INTERACT N1tpdiff == 2
  gate_erc_PWR NOT gate_erc_PWR1
}
#ENDIF

#IFDEF WELL_TO_PG_CHECK
// ptap connect to power 
ppvdd49 { @ ptap connected to POWER
  NET ptap POWER_NAME
}
#ENDIF

#ENDIF
