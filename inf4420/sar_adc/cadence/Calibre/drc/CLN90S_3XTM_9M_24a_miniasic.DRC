//**************************************************************************************
//* CALIBRE DRC COMMAND FILE - CLN90S_3XTM_9M.24a (VER 2.4a 08/30/2013)
//* FOR TSMC 90NM CMOS 1P9M 3XTM LOGIC/MS/RF PROCESS (CLN90G/GT/LP,CMN90G/GT/LP,CLN85G/LP,CMN85G/LP,CLN80GC/GT/HS/LP,CMN80GC)
//* (THE TOP METAL PITCH HAS 3 TIMES OF Mx PITCH WITH 8500A THICKNESS)
//* (DRC COMMAND FILE DOCUMENT: T-N90-LO-DR-001-C1 VER 2.4a)
//* (DESIGN RULE DOCUMENT:      T-N90-LO-DR-001    VER 2.4 )
//**************************************************************************************


// TSMC developed this deck using Mentor Graphics proprietary SVRF and TVF formats.
// The deck is to be used only in Calibre tools.



//
//***************************** OPTION SETUP ***************************************
//
#DEFINE DATATYPE_WARNING          // Turn on to flag NW/OD/PO warning datatype
#DEFINE RODMY_WARNING             // Turn on to check RODMY outside Sram dummy
#DEFINE GUIDELINE_RES           // Turn on to check OD/PO resistor guidelines
#DEFINE GUIDELINE_LUP	          // Turn on to check Latch-up guidelines
#DEFINE GUIDELINE_ESD           // Turn on to check ESD protection guidelines
//#DEFINE SUGGESTED               // Turn on to check suggested rules
#DEFINE DISCONNECT_ALL_RESISTOR  // Turn on to disconnect all resistors between pad and device for Latch-Up rule check.
#DEFINE CONNECT_ALL_RESISTOR     // Turn on to connect all resistors between pad and device for Latch-Up rule check.
//#DEFINE CU_WIRE              // Turn on if copper wire bond is used

//#DEFINE DEFINE_PAD_BY_TEXT              // Turn on to recognize IO PAD by following text for Latch-Up rules 
  VARIABLE PAD_TEXT  "?"                  // Pin name of PAD
  VARIABLE VDD_TEXT  "VDD?"               // Pin name of VDD
  VARIABLE VSS_TEXT  "VSS?"               // Pin name of VSS 

//#DEFINE EXCLUDE_SRM_ALSO        // Turn on to waive the SRAM regions with layer SRM(50) also
//#DEFINE DENSITY_IN_BLOCKAGE     // Turn on to check density within blockage layers only 
//#DEFINE DENSITY_FOR_NONFULLCHIP // Turn on to check Mx.DN.1 low density for non whole chip design, IP/macro/block
//#DEFINE WLCSPSealringCorner     // Turn on to use WLCSP seal-ring corner for whole chip design
//#DEFINE BigSealringCorner       // Turn on to use big seal-ring corner for whole chip design
//#DEFINE SmallSealringCorner     // Turn on to use small seal-ring corner for whole chip design
#DEFINE LmarkSealringCorner       // Turn on to use L-mark seal-ring corner for whole chip design
#DEFINE FULL_CHIP                 // Turn on for chip level design 

#DEFINE MSRF                    // Turn on to check N90 MS/RF design. Turning off this switch will check LOGIC rules by default.
//#DEFINE MSRF_SEALRING           // Turn on to use MS/RF sealring. 
//                                // Turn off this switch will check logic realring rules by default.
#DEFINE UTM                     // Turn on for UTM rules, Please note that N80 doesn't support UTM


//#DEFINE N80                             // Turn on to check N80 non-shrink rules and N90 shrinkable rules.
//#DEFINE RECOMMENDED_NONSHRINKABLE_RULE // Turn on to check recommended non-shrinkable rules for N80.
//                                        // All values for non-shrinkable rules will be changed according to DRM.
//#DEFINE N85                             // Turn on to check SRAM.BTC.S.1, SRAM.BTC.S.2 and RAM.BTC.S.3 with N85 spec


#DEFINE LP                              // Turn on for LP (Low-Power) design, check NT_N.W.2.1, 
                                          // schottky barrier diode, and ultra low Vt NMOS/PMOS
//#DEFINE GC                              // Turn on for GC design, check NT_N.W.2.2
//#DEFINE HS                              // Turn on for HS (High-Speed) design, check NT_N.W.2.2/NT_N.W.2.3/VAR.R.6

//#DEFINE 28K_AP                          // Turn on to check AP thinkness 28000 A
  
#IFDEF N80
  VARIABLE CellsFor1nmGrid " "      // Specify Cells for 1nm grid.
  // Please note that only N80 process could use this variable.
#ENDIF
DRC MAXIMUM VERTEX 150

//
// OPTION SETUP OF DFM RULES
//-----------------------------

//#DEFINE DFM              // Turn on to check DFM rules
//#DEFINE DFM_ONLY         // Turn on to check DFM rules only
#DEFINE Required         // Turn on to check DFM Action-Required rules
#DEFINE Recommended_DFM  // Turn on to check DFM Recommendations
  #DEFINE First_priority // Turn on to check First priority Recommendations.  
  #DEFINE Systematic     // Turn on to check Systematic related Action-Required rules and Recommendations
  #DEFINE Defect         // Turn on to check Defect related recommendations
  #DEFINE SPICE          // Turn on to check SPICE related Action-Required rules and Recommendations.
  #DEFINE Analog         // Turn on to check DFM analog rules
                         // must select by layer RRuleAnalog(182;3) or cell CellsForRRuleAnalog to enable it
  #DEFINE Guideline      // Turn on to check Guidelines
VARIABLE CellsForRRuleRequired "*"         // include cell in Action-Required rules check 
VARIABLE CellsForRRuleRecommended "*"      // include cell in Recommendations check
VARIABLE CellsForRRuleAnalog " "           // include cell in Analog rules check (default is empty)
VARIABLE CellsForRRuleGuideline "*"        // include cell in Guidleline check
VARIABLE ExclCellsForRRuleRequired " "     // exclude cell from Action-Required rules check
VARIABLE ExclCellsForRRuleRecommended " "  // exclude cell from Recommendations check
VARIABLE ExclCellsForRRuleAnalog " "       // exclude cell from Analog rules check
VARIABLE ExclCellsForRRuleGuideline " "    // exclude cell from Guidleline check
  
// Start of Action-required DFM rules 
#DEFINE _POS2_
#DEFINE _POEX2_
#DEFINE _POS5_
#DEFINE _POS6_
// End of Action-required DFM rules

// Start of recommended DFM rules
#DEFINE _OPCR1_    // Systematic related
#DEFINE _OPCR3_    // Systematic related
#DEFINE _OPCR2_    // Systematic related
#DEFINE _NWR1_     // Systematic related
#DEFINE _DNWR5_
#DEFINE _NWRODR3_NWRSTIR3_
#DEFINE _COS6_     // SPICE related
#DEFINE _COR5_     // 1st priority, Defect, and SPICE
#DEFINE _COS3_ 
#DEFINE _DNWEN1_   // Parametric related
#DEFINE _UTMDN5_

#DEFINE _ODW2_     // Parametric related
#DEFINE _CTMW1_    // Parametric related
#DEFINE _UTMEN3_   // Parametric related

#DEFINE _ODS1_     // Defect related
#DEFINE _ODS6_     // Systematic related
#DEFINE _ESDIMPEN1_ // Systematic related
#DEFINE _NWRODR1_  // Parametric related
#DEFINE _NWRSTIR1_ // Parametric related
#DEFINE _OD2W2_    // Systematic related 
#DEFINE _OD2W3_    // Systematic related 
#DEFINE _OD2S5_    // Systematic related
#DEFINE _OD2S6_    // Systematic related
#DEFINE _OD2S7_    // Systematic related
#DEFINE _OD2S8_    // Systematic related
#DEFINE _POS1_     // Defect related
#DEFINE _VARA1_    // Parametric related
#DEFINE _COEN1_    // Parametric related
#DEFINE _COEN3_    // Parametric related
#DEFINE _M1S6_     // Systematic related
#DEFINE _M1EN2_    // Parametric related
#DEFINE _M1EN3_    // Parametric related
#DEFINE _M1DN3_    // Systematic related
#DEFINE _VIA1EN1_VIA1EN2_     // 1st priority and parametric related
#DEFINE _VIA2EN1_VIA2EN2_     // 1st priority and parametric related
#DEFINE _VIA3EN1_VIA3EN2_     // 1st priority and parametric related
#DEFINE _VIA4EN1_VIA4EN2_     // 1st priority and parametric related
#DEFINE _VIA5EN1_VIA5EN2_     // 1st priority and parametric related
#DEFINE _VIA6EN1_VIA6EN2_     // 1st priority and parametric related


#DEFINE _VIAxR8_   // Systematic related

#DEFINE _VIA1R9_     // 1st priority, Defect, and SPICE
#DEFINE _VIA2R9_     // 1st priority, Defect, and SPICE
#DEFINE _VIA3R9_     // 1st priority, Defect, and SPICE
#DEFINE _VIA4R9_     // 1st priority, Defect, and SPICE
#DEFINE _VIA5R9_     // 1st priority, Defect, and SPICE
#DEFINE _VIA6R9_     // 1st priority, Defect, and SPICE
#DEFINE _VIA7R5_   // 1st priority, Defect, and SPICE
#DEFINE _VIA8R5_    // 1st priority, Defect, and SPICE


#DEFINE _M2S6_     // Systematic related
#DEFINE _M3S6_     // Systematic related
#DEFINE _M4S6_     // Systematic related
#DEFINE _M5S6_     // Systematic related
#DEFINE _M6S6_     // Systematic related
#DEFINE _M7S6_     // Systematic related


#DEFINE _M2EN1_M2EN2_   // 1st priority and parametric related
#DEFINE _M3EN1_M3EN2_   // 1st priority and parametric related
#DEFINE _M4EN1_M4EN2_   // 1st priority and parametric related
#DEFINE _M5EN1_M5EN2_   // 1st priority and parametric related
#DEFINE _M6EN1_M6EN2_   // 1st priority and parametric related
#DEFINE _M7EN1_M7EN2_   // 1st priority and parametric related


#DEFINE _M2W4_     // Systematic related
#DEFINE _M3W4_     // Systematic related
#DEFINE _M4W4_     // Systematic related
#DEFINE _M5W4_     // Systematic related
#DEFINE _M6W4_     // Systematic related
#DEFINE _M7W4_     // Systematic related

#DEFINE _M8W3_    // Systematic related
#DEFINE _M9W3_     // Systematic related

#DEFINE _M2DN3_    // Systematic related

#DEFINE _M3DN3_    // Systematic related

#DEFINE _M4DN3_    // Systematic related

#DEFINE _M5DN3_    // Systematic related

#DEFINE _M6DN3_    // Systematic related

#DEFINE _M7DN3_    // Systematic related


#DEFINE _M1DN4_     // Systematic related
#DEFINE _M2DN4_     // Systematic related
#DEFINE _M3DN4_     // Systematic related
#DEFINE _M4DN4_     // Systematic related
#DEFINE _M5DN4_     // Systematic related

// End of recommended DFM rules    

// Start of analog DFM rules/guidelines   
#DEFINE _RES5m_
#DEFINE _POEX1m_
#DEFINE _POS6m_
#DEFINE _POS5m_
#DEFINE _BJTR2R_
#DEFINE _BJTR3R_
#DEFINE _BJTR4R_
#DEFINE _BJTR5R_
#DEFINE _BJTR6R_
#DEFINE _BJTR7R_
#DEFINE _ANR17mg_
#DEFINE _ANR19mg_
#DEFINE _ANR46mg_
#DEFINE _ANR47mg_
// End of analog DFM rules/guidelines

#DEFINE _RESR17_   // SPICE related
#DEFINE _RESR18_   // SPICE related
#DEFINE _RESR19_   // SPICE related
#DEFINE _RESR20_   // SPICE related
#DEFINE _RESR21_   // SPICE related



  // The following are the group of dfm recommended rules. 
  // Please turn on option DFM, Recommended_DFM, and recommended rules when use it.
  //----------------------------------------------------------------------------
  
  //** Group of first priority DFM recommended rules ** 
  //GROUP First_priority_recommendations RR:RE:M?EN? RR:RE:VIA?EN?
  //DRC SELECT CHECK First_priority_recommendations
  
  //** Group of parametric related DFM recommended rules **
  //GROUP Parametric_recommendations RR:RE:DNW? RR:RE:ODW? RR:RE:NWR? RR:RE:POEX? RR:RE:VAR? RR:RE:COEN? RR:RE:M?EN? RR:RE:VIA?EN?
  //DRC SELECT CHECK Parametric_recommendations
  
  //** Group of systematic related DFM recommended rules **
  //GROUP Systematic_recommendations RR:RE:OPCR? RR:RE:ODS6 RR:RE:POS10 RR:RE:M?S6 RR:RE:M?DN3 RR:RE:VIA?S3? RR:RE:VIAxR8? RR:RE:M?W3 RR:RE:M?W4 RR:RE:M?R3
  //DRC SELECT CHECK Systematic_recommendations
  
  //** Group of defect related DFM recommended rules **
  //GROUP Defect_recommendations RR:RE:ODS1 RR:RE:POS1
  //DRC SELECT CHECK Defect_recommendations



// OPTION DEPENDENCE
//-----------------------------

#IFDEF DFM_ONLY
#DEFINE DFM
#ENDIF

  







//
//  ENVIRONMENT SETUP
//---------------------

PRECISION    1000 
//PRECISION    2000
RESOLUTION      5    // For 0.005um layout grid  

LAYOUT SYSTEM GDSII
// *LL* LAYOUT PATH "GDSFILENAME"
// *LL* LAYOUT PRIMARY "TOPCELLNAME"
LAYOUT PATH  "./../../2_des/PhDo_s2014_D.gds" // *LL*
LAYOUT PRIMARY "PhDo_s2014_D" // *LL*

// *LL* DRC RESULTS DATABASE "DRC_RES.db"
// *LL* DRC SUMMARY REPORT "DRC.rep" // HIER  
// *LL* DRC CHECK TEXT ALL
DRC RESULTS DATABASE "./DRC_PhDo_s2014_D.gds.txt" ASCII pseudo // *LL*
DRC SUMMARY REPORT "./DRC_PhDo_s2014_D.gds.sum" HIER // *LL*
DRC CHECK TEXT ALL RFI // *LL*
DRC KEEP EMPTY NO  // *LL*
DRC MAXIMUM RESULTS ALL
//DRC INCREMENTAL CONNECT YES

FLAG OFFGRID YES     // For layout grid check. default grid value is resolution size
FLAG ACUTE YES
FLAG SKEW YES
FLAG NONSIMPLE YES
//LAYOUT ALLOW DUPLICATE CELL YES
//LAYOUT ERROR ON INPUT NO
LAYOUT PROCESS BOX RECORD YES    // For box record in gds. default box record is not loaded in gds.



VARIABLE  GRID      0.005
VARIABLE  BIG_AREA  4000000
VARIABLE  DNW_W_1   3.0 

#IFDEF N80
  VARIABLE  DNW_S_1   5.28 	// N80 non-shrinkable rule
  VARIABLE  DNW_S_2   3.63 	// N80 non-shrinkable rule
#ELSE
  VARIABLE  DNW_S_1   4.8 
  VARIABLE  DNW_S_2   3.3 
#ENDIF

VARIABLE  DNW_S_3   1.82 
VARIABLE  DNW_S_4   1.0 
VARIABLE  DNW_S_5   1.2 
VARIABLE  DNW_EN_2  0.62 
VARIABLE  DNW_O_1   0.4 


VARIABLE  OD_W_1   0.11 
VARIABLE  OD_W_2   0.12 
VARIABLE  OD_W_3   0.4 
#IFDEF N80
  VARIABLE  OD_W_4R   0.195	// Recommended for N80 process
  VARIABLE  OD_S_4R   0.195	// Recommended for N80 process
#ENDIF

VARIABLE  OD_W_4   0.18
VARIABLE  OD_S_4   0.18
VARIABLE  OD_S_2   0.18  
VARIABLE  OD_S_3_L 0.3 
VARIABLE  OD_S_3_W 0.23 
VARIABLE  OD_S_1   0.14 
VARIABLE  OD_S_3   0.16
VARIABLE  OD_S_5   0.2 
VARIABLE  OD_A_1   0.06 
#IFDEF N80
  VARIABLE  OD_A_2   0.102 	// N80 non-shrinkable rule
#ELSE

  VARIABLE  OD_A_2   0.085 
#ENDIF

VARIABLE  OD_L_1   0.5 
VARIABLE  OD_L_1_W 0.15 
VARIABLE  OD_L_2   25.0 
VARIABLE  OD_L_2_W 0.15 

VARIABLE  NW_W_1   0.62 
VARIABLE  NW_W_2   1.80 
VARIABLE  NW_S_1   0.62 
VARIABLE  NW_S_2   1.0 
VARIABLE  NW_S_3   1.2 
VARIABLE  NW_S_4   1.2 
VARIABLE  NW_S_5   0.17 
VARIABLE  NW_S_6   0.22 
VARIABLE  NW_S_7   0.31
VARIABLE  NW_EN_1  0.17
VARIABLE  NW_EN_2  0.22
VARIABLE  NW_EN_3  0.31
VARIABLE  NW_A_1   1.55 
VARIABLE  NW_A_2   1.55 
VARIABLE  NW_R_2M  3.0

VARIABLE  NWROD_W_1   1.8 
VARIABLE  NWROD_S_1   1.2 
VARIABLE  NWROD_S_2   0.3 
VARIABLE  NWROD_EN_1  1.0 
VARIABLE  NWROD_EN_2  0.3 
VARIABLE  NWROD_O_1   0.4 

VARIABLE  NWRSTI_EN_1  0.4 
VARIABLE  NWRSTI_EN_2  0.3 
VARIABLE  NWRSTI_EN_3  0.3 
VARIABLE  NWRSTI_EX_1  0.3 

VARIABLE  NT_N_W_1   0.62 
VARIABLE  NT_N_W_2_1 0.33   // For 1.2V LP native device
#IFDEF N80
  VARIABLE  NT_N_W_2   0.22	// N80 non-shrinkable rule, for GT core native device 
  VARIABLE  NT_N_W_2_2 0.50	// N80 non-shrinkable rule, for HS/GC core native device
  VARIABLE  NT_N_W_2_3 0.30	// N80 non-shrinkable rule, for HS core native device
  VARIABLE  NT_N_W_3   1.32	// N80 non-shrinkable rule 
  VARIABLE  NT_N_W_4   0.88	// N80 non-shrinkable rule
  VARIABLE  NT_N_S_2   0.415	// N80 non-shrinkable rule
  VARIABLE  NT_N_S_3   1.32	// N80 non-shrinkable rule
  VARIABLE  NT_N_EN_1  0.285	// N80 non-shrinkable rule
  VARIABLE  NT_N_EX_1  0.385	// N80 non-shrinkable rule
#ELSE
  VARIABLE  NT_N_W_2   0.2 
  VARIABLE  NT_N_W_3   1.2 
  VARIABLE  NT_N_W_4   0.8 
  VARIABLE  NT_N_S_2   0.38 
  VARIABLE  NT_N_S_3   1.2 
  VARIABLE  NT_N_EN_1  0.26 
  VARIABLE  NT_N_EN_1b  0.285
  VARIABLE  NT_N_EX_1  0.35 
#ENDIF
VARIABLE  NT_N_W_5   0.5
VARIABLE  NT_N_S_1   0.62


VARIABLE  OD2_W_1   0.62 
VARIABLE  OD2_S_1   0.62 
VARIABLE  OD2_S_2   0.27 
VARIABLE  OD2_S_3   0.34 
VARIABLE  OD2_S_4   0.62 
VARIABLE  OD2_EN_1  0.34 
VARIABLE  OD2_EX_1  0.62 
VARIABLE  OD2_EX_2  0.62 
VARIABLE  OD2_EX_3  0.27 
VARIABLE  OD2_O_1   0.62 
VARIABLE  OD2_W_3R  0.62
VARIABLE  OD2_S_8R  0.62

#IFDEF N80
  VARIABLE  OD_DECAP_W_1  0.47
  VARIABLE  OD_DECAP_W_2  0.52
  VARIABLE  OD_DECAP_S_1  0.47
  VARIABLE  OD_DECAP_S_2  0.22
  VARIABLE  OD_DECAP_S_3  0.07
  VARIABLE  OD_DECAP_S_4  0.27
  VARIABLE  OD_DECAP_S_5  0.47
  VARIABLE  OD_DECAP_EN_1 0.07
  VARIABLE  OD_DECAP_R_1  0.22
#ENDIF



VARIABLE  PO_W_1    0.10 
#IFDEF N80
  VARIABLE  PO_W_2    0.31  	// N80 non-shrinkable rule
  VARIABLE  PO_W_3    0.415  	// N80 non-shrinkable rule
  VARIABLE  PO_W_4    0.22 	// N80 non-shrinkable rule
#ELSE

  VARIABLE  PO_W_2    0.28 
  VARIABLE  PO_W_3    0.38 
  VARIABLE  PO_W_4    0.20 
#ENDIF

VARIABLE  PO_S_1    0.14 
VARIABLE  PO_S_2    0.15 
VARIABLE  PO_S_3    0.25 
VARIABLE  PO_S_4    0.05 
VARIABLE  PO_S_5    0.10 
VARIABLE  PO_S_5_W  0.2 
VARIABLE  PO_S_6    0.10 
//VARIABLE  PO_S_6_W 0.2 	// Use the same setting of PO_S_5_W
VARIABLE  PO_S_7    0.18 
VARIABLE  PO_S_7_L  0.3 
VARIABLE  PO_S_7_W  0.23 
#IFDEF N80
  VARIABLE  PO_W_5R    0.205  	// Recommended for N80 process
  VARIABLE  PO_S_8R    0.205  	// Recommended for N80 process
  VARIABLE  PO_EX_1R   0.175 	// Recommended for N80 process
#ENDIF

VARIABLE  PO_W_5    0.19 
VARIABLE  PO_S_8    0.19 
VARIABLE  PO_EX_1   0.16 
VARIABLE  PO_S_9    0.25 
VARIABLE  PO_EX_2   0.15 
VARIABLE  PO_EX_3   0.18 
VARIABLE  PO_EX_3_W 0.2 
VARIABLE  PO_EX_3_S 0.1 
VARIABLE  PO_L_1    25.0 
VARIABLE  PO_L_1_W  0.13 
VARIABLE  PO_A_1    0.06 
VARIABLE  PO_A_2    0.11 
VARIABLE  PO_R_3_W  0.14 
VARIABLE  PO_R_3_E  0.18 
VARIABLE  PSPO_EN_1  0.05 
VARIABLE  PSPO_S_1   0.05

VARIABLE  VTH_N_W_1   0.40 
VARIABLE  VTH_N_S_1   0.24 
VARIABLE  VTH_N_S_2   0.22 
VARIABLE  VTH_N_S_3   0.22
VARIABLE  VTH_N_EN_1  0.22 
VARIABLE  VTH_N_A_1   0.40 
VARIABLE  VTH_N_A_2   0.40
VARIABLE  VTH_N_R_2   0.56
VARIABLE  VTH_N_R_3   0.28

VARIABLE  VTH_P_W_1   0.40 
VARIABLE  VTH_P_S_1   0.24 
VARIABLE  VTH_P_S_2   0.22 
VARIABLE  VTH_P_S_3   0.22
VARIABLE  VTH_P_EN_1  0.22 
VARIABLE  VTH_P_A_1   0.40 
VARIABLE  VTH_P_A_2   0.40 
VARIABLE  VTH_P_R_2   0.56
VARIABLE  VTH_P_R_3   0.28

VARIABLE  VTL_N_W_1   0.40 
VARIABLE  VTL_N_S_1   0.24 
VARIABLE  VTL_N_S_2   0.22 
VARIABLE  VTL_N_S_3   0.22
VARIABLE  VTL_N_EN_1  0.22 
VARIABLE  VTL_N_A_1   0.40 
VARIABLE  VTL_N_A_2   0.40 
VARIABLE  VTL_N_R_2   0.56
VARIABLE  VTL_N_R_3   0.28

VARIABLE  VTL_P_W_1   0.40 
VARIABLE  VTL_P_S_1   0.24 
VARIABLE  VTL_P_S_2   0.22 
VARIABLE  VTL_P_S_3   0.22
VARIABLE  VTL_P_EN_1  0.22 
VARIABLE  VTL_P_A_1   0.40 
VARIABLE  VTL_P_A_2   0.40 
VARIABLE  VTL_P_R_2   0.56
VARIABLE  VTL_P_R_3   0.28

VARIABLE  ULVT_P_W_1   0.40 
VARIABLE  ULVT_P_S_1   0.24 
VARIABLE  ULVT_P_S_2   0.22 
VARIABLE  ULVT_P_S_3   0.22
VARIABLE  ULVT_P_EN_1  0.22 
VARIABLE  ULVT_P_A_1   0.40 
VARIABLE  ULVT_P_A_2   0.40 
VARIABLE  ULVT_P_R_2   0.56
VARIABLE  ULVT_P_R_3   0.28

VARIABLE  ULVT_N_W_1   0.40 
VARIABLE  ULVT_N_S_1   0.24 
VARIABLE  ULVT_N_S_2   0.22 
VARIABLE  ULVT_N_S_3   0.22
VARIABLE  ULVT_N_EN_1  0.22 
VARIABLE  ULVT_N_A_1   0.40 
VARIABLE  ULVT_N_A_2   0.40 
VARIABLE  ULVT_N_R_2   0.56
VARIABLE  ULVT_N_R_3   0.28


VARIABLE  PP_W_1    0.24 
VARIABLE  PP_S_1    0.24 
VARIABLE  PP_S_2    0.13 
VARIABLE  PP_S_4    0.02 
VARIABLE  PP_S_5    0.32 
VARIABLE  PP_S_6    0.32 
VARIABLE  PP_S_6_J  0.22 
VARIABLE  PP_S_7    0.20 
VARIABLE  PP_EN_1   0.20 
VARIABLE  PP_EX_1   0.13 
VARIABLE  PP_EX_2   0.02 
VARIABLE  PP_EX_3   0.20 
VARIABLE  PP_EX_4   0.32 
VARIABLE  PP_O_1    0.13 
VARIABLE  PP_A_1    0.122 
VARIABLE  PP_A_2    0.122 
VARIABLE  PP_A_3    0.04 
VARIABLE  PP_R_1    0.22 

VARIABLE  NP_W_1    0.24 
VARIABLE  NP_S_1    0.24 
VARIABLE  NP_S_2    0.13 
VARIABLE  NP_S_4    0.02 
VARIABLE  NP_S_5    0.32 
VARIABLE  NP_S_6    0.32 
VARIABLE  NP_S_6_J  0.22 
VARIABLE  NP_S_7    0.20 
VARIABLE  NP_EX_1   0.13 
VARIABLE  NP_EX_2   0.02 
VARIABLE  NP_EX_3   0.20 
VARIABLE  NP_EX_4   0.32 
VARIABLE  NP_O_1    0.13 
VARIABLE  NP_A_1    0.122 
VARIABLE  NP_A_2    0.122 
VARIABLE  NP_A_3    0.04 
VARIABLE  NP_R_1    0.22 

VARIABLE  LDN_EX_1  0.24 
VARIABLE  LDN_O_1   0.24 
VARIABLE  LDP_EX_2  0.24 
VARIABLE  LDP_O_1   0.24 
VARIABLE  VT_S_1    0.24 
VARIABLE  VT_EX_2   0.24 
VARIABLE  ESDIMP_W_1  0.6
VARIABLE  ESDIMP_S_1  0.6
VARIABLE  ESDIMP_S_2  0.6
VARIABLE  ESDIMP_EN_1 0.4
VARIABLE  ESDIMP_EN_1_R 0.4
VARIABLE  ESDIMP_A_1  1.0
VARIABLE  ESDIMP_A_2  1.0

VARIABLE  RPO_W_1    0.43 
VARIABLE  RPO_S_1    0.43 
VARIABLE  RPO_S_2    0.22 
VARIABLE  RPO_S_3    0.22 
VARIABLE  RPO_S_4    0.38 
VARIABLE  RPO_S_5    0.30
VARIABLE  RPO_EX_1   0.22 
VARIABLE  RPO_EX_2   0.22 
VARIABLE  RPO_EX_3   0.30 
VARIABLE  RPO_EX_3_W 10.0 
VARIABLE  RPO_A_1    1.0 
VARIABLE  RPO_A_2    1.0 
VARIABLE  RES_2G_OD_W  0.4
VARIABLE  RES_2G_OD_L  0.8
VARIABLE  RES_2G_PO_W  0.4
VARIABLE  RES_2G_PO_L  0.8
VARIABLE  RES_8G       0.32
VARIABLE  RES_9G       0.20
VARIABLE  RES_8        0.22
VARIABLE  RES_10G      0.20

VARIABLE  VAR_W_1    0.40 
VARIABLE  VAR_S_1    0.13 
VARIABLE  VAR_EN_1   0.22 
VARIABLE  VAR_R_4    0.22 
VARIABLE  VAR_R_5a    0.19 
VARIABLE  VAR_R_5b    0.13 

VARIABLE  SBD_W_1    1.0
VARIABLE  SBD_W_1_1  16.0
VARIABLE  SBD_W_2    0.5
VARIABLE  SBD_W_2_1  4.0
VARIABLE  SBD_W_3    0.2
VARIABLE  SBD_S_1    0.32
VARIABLE  SBD_E_1    0.7
VARIABLE  SBD_E_1_1  0.6
VARIABLE  SBD_E_2    0.13
VARIABLE  SBD_E_2_1  0.13
VARIABLE  SBD_E_2_2  0.06
VARIABLE  SBD_E_3    0
VARIABLE  SBD_O_1    0.13
VARIABLE  SBD_R_2    16




VARIABLE  CO_W_1    0.12 
VARIABLE  CO_W_2    0.12 	// For CO bar on sealring
VARIABLE  CO_S_1    0.14 
VARIABLE  CO_S_2    0.16 
VARIABLE  CO_S_2_N  0.18 
VARIABLE  CO_S_4    0.10 
#IFDEF N80
  VARIABLE  CO_S_3R    0.075	// Recommended for N80 process 
#ENDIF
VARIABLE  CO_S_3    0.07 
VARIABLE  CO_EN_3   0.05 
VARIABLE  CO_S_3_S  0.058 	// For SRAM periphrial regions
VARIABLE  CO_S_5    0.11
VARIABLE  CO_S_6    0.06 
VARIABLE  CO_EN_1   0.04 
VARIABLE  CO_EN_2   0.02 


VARIABLE  M1_W_1    0.12 
VARIABLE  M1_W_3    12.0 
VARIABLE  M1_S_1    0.12 
#IFDEF N80
  VARIABLE  M1_S_2    0.17 
  VARIABLE  M1_S_2_W  0.33 	// N80 blow-up rule
  VARIABLE  M1_S_2_L  0.575	// N80 blow-up rule 
  VARIABLE  M1_S_2_1   0.13	// N80 added rule
  VARIABLE  M1_S_2_1_W 0.30	// N80 added rule
  VARIABLE  M1_S_2_1_L 0.80	// N80 added rule
  VARIABLE  M1_S_3    0.5 
  VARIABLE  M1_S_3_W  1.65 	// N80 blow-up rule
  VARIABLE  M1_S_3_L  1.65 	// N80 blow-up rule
  VARIABLE  M1_S_4    1.5 
  VARIABLE  M1_S_4_W  4.95  	// N80 blow-up rule
  VARIABLE  M1_S_4_L  4.95  	// N80 blow-up rule
  VARIABLE  M1_W_2R   0.205 	// Recommended for N80 process
  VARIABLE  M1_S_5R   0.205  	// Recommended for N80 process
  VARIABLE  M1_W_2    0.19 
  VARIABLE  M1_EN_2   0.05 
  VARIABLE  M1_EN_3   0.025 
  VARIABLE  M1_S_5    0.19 
#ELSE

  VARIABLE  M1_W_2    0.19 
  VARIABLE  M1_S_2    0.17 
  VARIABLE  M1_S_2_W  0.30 
  VARIABLE  M1_S_2_L  0.52 
  VARIABLE  M1_S_3    0.5 
  VARIABLE  M1_S_3_W  1.5 
  VARIABLE  M1_S_3_L  1.5 
  VARIABLE  M1_S_4    1.5 
  VARIABLE  M1_S_4_W  4.5 
  VARIABLE  M1_S_4_L  4.5 
  VARIABLE  M1_EN_2   0.05 
  VARIABLE  M1_EN_3   0.025 
  VARIABLE  M1_S_5    0.19 
#ENDIF


VARIABLE  M1_A_1    0.058 
VARIABLE  M1_A_2    0.20 



VARIABLE  VIA1_W_1     0.13 
VARIABLE  VIA1_W_2     0.13 	// For VIA bar on sealring
VARIABLE  VIA1_S_1     0.15 
VARIABLE  VIA1_S_2     0.17 
VARIABLE  VIA1_S_2_S   0.19 
VARIABLE  VIA1_EN_1    0.005 
VARIABLE  VIA1_EN_2    0.05 
VARIABLE  VIA1_EN_3    0.04 
#IFDEF N80
  VARIABLE  VIA1_R_2_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA1_R_2_S2  0.63  	// N80 blow-up rule
  VARIABLE  VIA1_R_2_S3  0.85  	// N80 blow-up rule
  VARIABLE  VIA1_R_2_W   0.47 	// N80 blow-up rule
  VARIABLE  VIA1_R_3_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA1_R_3_S2  0.85  	// N80 blow-up rule
  VARIABLE  VIA1_R_3_W   1.26  	// N80 blow-up rule
  VARIABLE  VIA1_R_4_W   0.77 	// N80 blow-up rule
  VARIABLE  VIA1_R_4_D   1.0
  VARIABLE  VIA1_R_5_W   2.2 	// N80 blow-up rule
  VARIABLE  VIA1_R_5_D   2.0
  VARIABLE  VIA1_R_6_W   3.3 	// N80 blow-up rule
  VARIABLE  VIA1_R_6_L   11.0 	// N80 blow-up rule
  VARIABLE  VIA1_R_6_D   5.0
#ELSE
  VARIABLE  VIA1_R_2_S1  0.29 
  VARIABLE  VIA1_R_2_S2  0.57 
  VARIABLE  VIA1_R_2_S3  0.77 
  VARIABLE  VIA1_R_2_W   0.42 
  VARIABLE  VIA1_R_3_S1  0.29 
  VARIABLE  VIA1_R_3_S2  0.77 
  VARIABLE  VIA1_R_3_W   1.14
  VARIABLE  VIA1_R_4_W   0.7
  VARIABLE  VIA1_R_4_D   1.0
  VARIABLE  VIA1_R_5_W   2.0
  VARIABLE  VIA1_R_5_D   2.0
  VARIABLE  VIA1_R_6_W   3.0
  VARIABLE  VIA1_R_6_L   10.0
  VARIABLE  VIA1_R_6_D   5.0
#ENDIF
VARIABLE  VIA1_R_11_L   1.0
VARIABLE  VIA1_R_11_W   0.42
VARIABLE  VIA1_R_11_A   5.0
VARIABLE  VIA1_R_11_L2  5.0


#IFDEF N80
  VARIABLE  VIA1_S_3R     0.17    // Recommended for N80 proces 
#ENDIF

VARIABLE  M2_W_1     0.14 
VARIABLE  M2_W_2     0.19 
VARIABLE  M2_W_3     12.0 
VARIABLE  M2_S_1     0.14 
#IFDEF N80
  VARIABLE  M2_S_2     0.19 
  VARIABLE  M2_S_2_W   0.24	// N80 blow-up rule
  VARIABLE  M2_S_2_L   0.575	// N80 blow-up rule
  VARIABLE  M2_S_2_1   0.15	// N80 added rule
  VARIABLE  M2_S_2_1_W 0.21	// N80 added rule
  VARIABLE  M2_S_2_1_L 0.80	// N80 added rule
  VARIABLE  M2_S_3     0.5 
  VARIABLE  M2_S_3_W   1.65	// N80 blow-up rule
  VARIABLE  M2_S_3_L   1.65	// N80 blow-up rule
  VARIABLE  M2_S_4     1.5 
  VARIABLE  M2_S_4_W   4.95	// N80 blow-up rule
  VARIABLE  M2_S_4_L   4.95	// N80 blow-up rule
#ELSE
  VARIABLE  M2_S_2     0.19 
  VARIABLE  M2_S_2_W   0.21 
  VARIABLE  M2_S_2_L   0.52 
  VARIABLE  M2_S_3     0.5 
  VARIABLE  M2_S_3_W   1.5 
  VARIABLE  M2_S_3_L   1.5 
  VARIABLE  M2_S_4     1.5 
  VARIABLE  M2_S_4_W   4.5 
  VARIABLE  M2_S_4_L   4.5 
#ENDIF
VARIABLE  M2_S_5     0.19
VARIABLE  M2_EN_1    0.005
VARIABLE  M2_EN_2    0.05 
VARIABLE  M2_EN_3    0.04 
VARIABLE  M2_A_1     0.07 
VARIABLE  M2_A_2     0.2 
#IFDEF N80
  VARIABLE  M2_W_2R    0.205  	// Recommended for N80 process
  VARIABLE  M2_S_5R    0.205  	// Recommended for N80 process
#ENDIF


VARIABLE  VIA2_W_1     0.13 
VARIABLE  VIA2_W_2     0.13 	// For VIA bar on sealring
VARIABLE  VIA2_S_1     0.15 
VARIABLE  VIA2_S_2     0.17 
VARIABLE  VIA2_S_2_S   0.19 
VARIABLE  VIA2_EN_1    0.005 
VARIABLE  VIA2_EN_2    0.05 
VARIABLE  VIA2_EN_3    0.04 
#IFDEF N80
  VARIABLE  VIA2_R_2_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA2_R_2_S2  0.63  	// N80 blow-up rule
  VARIABLE  VIA2_R_2_S3  0.85  	// N80 blow-up rule
  VARIABLE  VIA2_R_2_W   0.47 	// N80 blow-up rule
  VARIABLE  VIA2_R_3_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA2_R_3_S2  0.85  	// N80 blow-up rule
  VARIABLE  VIA2_R_3_W   1.26  	// N80 blow-up rule
  VARIABLE  VIA2_R_4_W   0.77 	// N80 blow-up rule
  VARIABLE  VIA2_R_4_D   1.0
  VARIABLE  VIA2_R_5_W   2.2 	// N80 blow-up rule
  VARIABLE  VIA2_R_5_D   2.0
  VARIABLE  VIA2_R_6_W   3.3 	// N80 blow-up rule
  VARIABLE  VIA2_R_6_L   11.0 	// N80 blow-up rule
  VARIABLE  VIA2_R_6_D   5.0
#ELSE
  VARIABLE  VIA2_R_2_S1  0.29 
  VARIABLE  VIA2_R_2_S2  0.57 
  VARIABLE  VIA2_R_2_S3  0.77 
  VARIABLE  VIA2_R_2_W   0.42 
  VARIABLE  VIA2_R_3_S1  0.29 
  VARIABLE  VIA2_R_3_S2  0.77 
  VARIABLE  VIA2_R_3_W   1.14
  VARIABLE  VIA2_R_4_W   0.7
  VARIABLE  VIA2_R_4_D   1.0
  VARIABLE  VIA2_R_5_W   2.0
  VARIABLE  VIA2_R_5_D   2.0
  VARIABLE  VIA2_R_6_W   3.0
  VARIABLE  VIA2_R_6_L   10.0
  VARIABLE  VIA2_R_6_D   5.0
#ENDIF
VARIABLE  VIA2_R_11_L   1.0
VARIABLE  VIA2_R_11_W   0.42
VARIABLE  VIA2_R_11_A   5.0
VARIABLE  VIA2_R_11_L2  5.0


#IFDEF N80
  VARIABLE  VIA2_S_3R     0.17    // Recommended for N80 proces 
#ENDIF

VARIABLE  M3_W_1     0.14 
VARIABLE  M3_W_2     0.19 
VARIABLE  M3_W_3     12.0 
VARIABLE  M3_S_1     0.14 
#IFDEF N80
  VARIABLE  M3_S_2     0.19 
  VARIABLE  M3_S_2_W   0.24	// N80 blow-up rule
  VARIABLE  M3_S_2_L   0.575	// N80 blow-up rule
  VARIABLE  M3_S_2_1   0.15	// N80 added rule
  VARIABLE  M3_S_2_1_W 0.21	// N80 added rule
  VARIABLE  M3_S_2_1_L 0.80	// N80 added rule
  VARIABLE  M3_S_3     0.5 
  VARIABLE  M3_S_3_W   1.65	// N80 blow-up rule
  VARIABLE  M3_S_3_L   1.65	// N80 blow-up rule
  VARIABLE  M3_S_4     1.5 
  VARIABLE  M3_S_4_W   4.95	// N80 blow-up rule
  VARIABLE  M3_S_4_L   4.95	// N80 blow-up rule
#ELSE
  VARIABLE  M3_S_2     0.19 
  VARIABLE  M3_S_2_W   0.21 
  VARIABLE  M3_S_2_L   0.52 
  VARIABLE  M3_S_3     0.5 
  VARIABLE  M3_S_3_W   1.5 
  VARIABLE  M3_S_3_L   1.5 
  VARIABLE  M3_S_4     1.5 
  VARIABLE  M3_S_4_W   4.5 
  VARIABLE  M3_S_4_L   4.5 
#ENDIF
VARIABLE  M3_S_5     0.19
VARIABLE  M3_EN_1    0.005
VARIABLE  M3_EN_2    0.05 
VARIABLE  M3_EN_3    0.04 
VARIABLE  M3_A_1     0.07 
VARIABLE  M3_A_2     0.2 
#IFDEF N80
  VARIABLE  M3_W_2R    0.205  	// Recommended for N80 process
  VARIABLE  M3_S_5R    0.205  	// Recommended for N80 process
#ENDIF


VARIABLE  VIA3_W_1     0.13 
VARIABLE  VIA3_W_2     0.13 	// For VIA bar on sealring
VARIABLE  VIA3_S_1     0.15 
VARIABLE  VIA3_S_2     0.17 
VARIABLE  VIA3_S_2_S   0.19 
VARIABLE  VIA3_EN_1    0.005 
VARIABLE  VIA3_EN_2    0.05 
VARIABLE  VIA3_EN_3    0.04 
#IFDEF N80
  VARIABLE  VIA3_R_2_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA3_R_2_S2  0.63  	// N80 blow-up rule
  VARIABLE  VIA3_R_2_S3  0.85  	// N80 blow-up rule
  VARIABLE  VIA3_R_2_W   0.47 	// N80 blow-up rule
  VARIABLE  VIA3_R_3_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA3_R_3_S2  0.85  	// N80 blow-up rule
  VARIABLE  VIA3_R_3_W   1.26  	// N80 blow-up rule
  VARIABLE  VIA3_R_4_W   0.77 	// N80 blow-up rule
  VARIABLE  VIA3_R_4_D   1.0
  VARIABLE  VIA3_R_5_W   2.2 	// N80 blow-up rule
  VARIABLE  VIA3_R_5_D   2.0
  VARIABLE  VIA3_R_6_W   3.3 	// N80 blow-up rule
  VARIABLE  VIA3_R_6_L   11.0 	// N80 blow-up rule
  VARIABLE  VIA3_R_6_D   5.0
#ELSE
  VARIABLE  VIA3_R_2_S1  0.29 
  VARIABLE  VIA3_R_2_S2  0.57 
  VARIABLE  VIA3_R_2_S3  0.77 
  VARIABLE  VIA3_R_2_W   0.42 
  VARIABLE  VIA3_R_3_S1  0.29 
  VARIABLE  VIA3_R_3_S2  0.77 
  VARIABLE  VIA3_R_3_W   1.14
  VARIABLE  VIA3_R_4_W   0.7
  VARIABLE  VIA3_R_4_D   1.0
  VARIABLE  VIA3_R_5_W   2.0
  VARIABLE  VIA3_R_5_D   2.0
  VARIABLE  VIA3_R_6_W   3.0
  VARIABLE  VIA3_R_6_L   10.0
  VARIABLE  VIA3_R_6_D   5.0
#ENDIF
VARIABLE  VIA3_R_11_L   1.0
VARIABLE  VIA3_R_11_W   0.42
VARIABLE  VIA3_R_11_A   5.0
VARIABLE  VIA3_R_11_L2  5.0


#IFDEF N80
  VARIABLE  VIA3_S_3R     0.17    // Recommended for N80 proces 
#ENDIF

VARIABLE  M4_W_1     0.14 
VARIABLE  M4_W_2     0.19 
VARIABLE  M4_W_3     12.0 
VARIABLE  M4_S_1     0.14 
#IFDEF N80
  VARIABLE  M4_S_2     0.19 
  VARIABLE  M4_S_2_W   0.24	// N80 blow-up rule
  VARIABLE  M4_S_2_L   0.575	// N80 blow-up rule
  VARIABLE  M4_S_2_1   0.15	// N80 added rule
  VARIABLE  M4_S_2_1_W 0.21	// N80 added rule
  VARIABLE  M4_S_2_1_L 0.80	// N80 added rule
  VARIABLE  M4_S_3     0.5 
  VARIABLE  M4_S_3_W   1.65	// N80 blow-up rule
  VARIABLE  M4_S_3_L   1.65	// N80 blow-up rule
  VARIABLE  M4_S_4     1.5 
  VARIABLE  M4_S_4_W   4.95	// N80 blow-up rule
  VARIABLE  M4_S_4_L   4.95	// N80 blow-up rule
#ELSE
  VARIABLE  M4_S_2     0.19 
  VARIABLE  M4_S_2_W   0.21 
  VARIABLE  M4_S_2_L   0.52 
  VARIABLE  M4_S_3     0.5 
  VARIABLE  M4_S_3_W   1.5 
  VARIABLE  M4_S_3_L   1.5 
  VARIABLE  M4_S_4     1.5 
  VARIABLE  M4_S_4_W   4.5 
  VARIABLE  M4_S_4_L   4.5 
#ENDIF
VARIABLE  M4_S_5     0.19
VARIABLE  M4_EN_1    0.005
VARIABLE  M4_EN_2    0.05 
VARIABLE  M4_EN_3    0.04 
VARIABLE  M4_A_1     0.07 
VARIABLE  M4_A_2     0.2 
#IFDEF N80
  VARIABLE  M4_W_2R    0.205  	// Recommended for N80 process
  VARIABLE  M4_S_5R    0.205  	// Recommended for N80 process
#ENDIF


VARIABLE  VIA4_W_1     0.13 
VARIABLE  VIA4_W_2     0.13 	// For VIA bar on sealring
VARIABLE  VIA4_S_1     0.15 
VARIABLE  VIA4_S_2     0.17 
VARIABLE  VIA4_S_2_S   0.19 
VARIABLE  VIA4_EN_1    0.005 
VARIABLE  VIA4_EN_2    0.05 
VARIABLE  VIA4_EN_3    0.04 
#IFDEF N80
  VARIABLE  VIA4_R_2_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA4_R_2_S2  0.63  	// N80 blow-up rule
  VARIABLE  VIA4_R_2_S3  0.85  	// N80 blow-up rule
  VARIABLE  VIA4_R_2_W   0.47 	// N80 blow-up rule
  VARIABLE  VIA4_R_3_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA4_R_3_S2  0.85  	// N80 blow-up rule
  VARIABLE  VIA4_R_3_W   1.26  	// N80 blow-up rule
  VARIABLE  VIA4_R_4_W   0.77 	// N80 blow-up rule
  VARIABLE  VIA4_R_4_D   1.0
  VARIABLE  VIA4_R_5_W   2.2 	// N80 blow-up rule
  VARIABLE  VIA4_R_5_D   2.0
  VARIABLE  VIA4_R_6_W   3.3 	// N80 blow-up rule
  VARIABLE  VIA4_R_6_L   11.0 	// N80 blow-up rule
  VARIABLE  VIA4_R_6_D   5.0
#ELSE
  VARIABLE  VIA4_R_2_S1  0.29 
  VARIABLE  VIA4_R_2_S2  0.57 
  VARIABLE  VIA4_R_2_S3  0.77 
  VARIABLE  VIA4_R_2_W   0.42 
  VARIABLE  VIA4_R_3_S1  0.29 
  VARIABLE  VIA4_R_3_S2  0.77 
  VARIABLE  VIA4_R_3_W   1.14
  VARIABLE  VIA4_R_4_W   0.7
  VARIABLE  VIA4_R_4_D   1.0
  VARIABLE  VIA4_R_5_W   2.0
  VARIABLE  VIA4_R_5_D   2.0
  VARIABLE  VIA4_R_6_W   3.0
  VARIABLE  VIA4_R_6_L   10.0
  VARIABLE  VIA4_R_6_D   5.0
#ENDIF
VARIABLE  VIA4_R_11_L   1.0
VARIABLE  VIA4_R_11_W   0.42
VARIABLE  VIA4_R_11_A   5.0
VARIABLE  VIA4_R_11_L2  5.0


#IFDEF N80
  VARIABLE  VIA4_S_3R     0.17    // Recommended for N80 proces 
#ENDIF

VARIABLE  M5_W_1     0.14 
VARIABLE  M5_W_2     0.19 
VARIABLE  M5_W_3     12.0 
VARIABLE  M5_S_1     0.14 
#IFDEF N80
  VARIABLE  M5_S_2     0.19 
  VARIABLE  M5_S_2_W   0.24	// N80 blow-up rule
  VARIABLE  M5_S_2_L   0.575	// N80 blow-up rule
  VARIABLE  M5_S_2_1   0.15	// N80 added rule
  VARIABLE  M5_S_2_1_W 0.21	// N80 added rule
  VARIABLE  M5_S_2_1_L 0.80	// N80 added rule
  VARIABLE  M5_S_3     0.5 
  VARIABLE  M5_S_3_W   1.65	// N80 blow-up rule
  VARIABLE  M5_S_3_L   1.65	// N80 blow-up rule
  VARIABLE  M5_S_4     1.5 
  VARIABLE  M5_S_4_W   4.95	// N80 blow-up rule
  VARIABLE  M5_S_4_L   4.95	// N80 blow-up rule
#ELSE
  VARIABLE  M5_S_2     0.19 
  VARIABLE  M5_S_2_W   0.21 
  VARIABLE  M5_S_2_L   0.52 
  VARIABLE  M5_S_3     0.5 
  VARIABLE  M5_S_3_W   1.5 
  VARIABLE  M5_S_3_L   1.5 
  VARIABLE  M5_S_4     1.5 
  VARIABLE  M5_S_4_W   4.5 
  VARIABLE  M5_S_4_L   4.5 
#ENDIF
VARIABLE  M5_S_5     0.19
VARIABLE  M5_EN_1    0.005
VARIABLE  M5_EN_2    0.05 
VARIABLE  M5_EN_3    0.04 
VARIABLE  M5_A_1     0.07 
VARIABLE  M5_A_2     0.2 
#IFDEF N80
  VARIABLE  M5_W_2R    0.205  	// Recommended for N80 process
  VARIABLE  M5_S_5R    0.205  	// Recommended for N80 process
#ENDIF


VARIABLE  VIA5_W_1     0.13 
VARIABLE  VIA5_W_2     0.13 	// For VIA bar on sealring
VARIABLE  VIA5_S_1     0.15 
VARIABLE  VIA5_S_2     0.17 
VARIABLE  VIA5_S_2_S   0.19 
VARIABLE  VIA5_EN_1    0.005 
VARIABLE  VIA5_EN_2    0.05 
VARIABLE  VIA5_EN_3    0.04 
#IFDEF N80
  VARIABLE  VIA5_R_2_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA5_R_2_S2  0.63  	// N80 blow-up rule
  VARIABLE  VIA5_R_2_S3  0.85  	// N80 blow-up rule
  VARIABLE  VIA5_R_2_W   0.47 	// N80 blow-up rule
  VARIABLE  VIA5_R_3_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA5_R_3_S2  0.85  	// N80 blow-up rule
  VARIABLE  VIA5_R_3_W   1.26  	// N80 blow-up rule
  VARIABLE  VIA5_R_4_W   0.77 	// N80 blow-up rule
  VARIABLE  VIA5_R_4_D   1.0
  VARIABLE  VIA5_R_5_W   2.2 	// N80 blow-up rule
  VARIABLE  VIA5_R_5_D   2.0
  VARIABLE  VIA5_R_6_W   3.3 	// N80 blow-up rule
  VARIABLE  VIA5_R_6_L   11.0 	// N80 blow-up rule
  VARIABLE  VIA5_R_6_D   5.0
#ELSE
  VARIABLE  VIA5_R_2_S1  0.29 
  VARIABLE  VIA5_R_2_S2  0.57 
  VARIABLE  VIA5_R_2_S3  0.77 
  VARIABLE  VIA5_R_2_W   0.42 
  VARIABLE  VIA5_R_3_S1  0.29 
  VARIABLE  VIA5_R_3_S2  0.77 
  VARIABLE  VIA5_R_3_W   1.14
  VARIABLE  VIA5_R_4_W   0.7
  VARIABLE  VIA5_R_4_D   1.0
  VARIABLE  VIA5_R_5_W   2.0
  VARIABLE  VIA5_R_5_D   2.0
  VARIABLE  VIA5_R_6_W   3.0
  VARIABLE  VIA5_R_6_L   10.0
  VARIABLE  VIA5_R_6_D   5.0
#ENDIF
VARIABLE  VIA5_R_11_L   1.0
VARIABLE  VIA5_R_11_W   0.42
VARIABLE  VIA5_R_11_A   5.0
VARIABLE  VIA5_R_11_L2  5.0


#IFDEF N80
  VARIABLE  VIA5_S_3R     0.17    // Recommended for N80 proces 
#ENDIF

VARIABLE  M6_W_1     0.14 
VARIABLE  M6_W_2     0.19 
VARIABLE  M6_W_3     12.0 
VARIABLE  M6_S_1     0.14 
#IFDEF N80
  VARIABLE  M6_S_2     0.19 
  VARIABLE  M6_S_2_W   0.24	// N80 blow-up rule
  VARIABLE  M6_S_2_L   0.575	// N80 blow-up rule
  VARIABLE  M6_S_2_1   0.15	// N80 added rule
  VARIABLE  M6_S_2_1_W 0.21	// N80 added rule
  VARIABLE  M6_S_2_1_L 0.80	// N80 added rule
  VARIABLE  M6_S_3     0.5 
  VARIABLE  M6_S_3_W   1.65	// N80 blow-up rule
  VARIABLE  M6_S_3_L   1.65	// N80 blow-up rule
  VARIABLE  M6_S_4     1.5 
  VARIABLE  M6_S_4_W   4.95	// N80 blow-up rule
  VARIABLE  M6_S_4_L   4.95	// N80 blow-up rule
#ELSE
  VARIABLE  M6_S_2     0.19 
  VARIABLE  M6_S_2_W   0.21 
  VARIABLE  M6_S_2_L   0.52 
  VARIABLE  M6_S_3     0.5 
  VARIABLE  M6_S_3_W   1.5 
  VARIABLE  M6_S_3_L   1.5 
  VARIABLE  M6_S_4     1.5 
  VARIABLE  M6_S_4_W   4.5 
  VARIABLE  M6_S_4_L   4.5 
#ENDIF
VARIABLE  M6_S_5     0.19
VARIABLE  M6_EN_1    0.005
VARIABLE  M6_EN_2    0.05 
VARIABLE  M6_EN_3    0.04 
VARIABLE  M6_A_1     0.07 
VARIABLE  M6_A_2     0.2 
#IFDEF N80
  VARIABLE  M6_W_2R    0.205  	// Recommended for N80 process
  VARIABLE  M6_S_5R    0.205  	// Recommended for N80 process
#ENDIF


VARIABLE  VIA6_W_1     0.13 
VARIABLE  VIA6_W_2     0.13 	// For VIA bar on sealring
VARIABLE  VIA6_S_1     0.15 
VARIABLE  VIA6_S_2     0.17 
VARIABLE  VIA6_S_2_S   0.19 
VARIABLE  VIA6_EN_1    0.005 
VARIABLE  VIA6_EN_2    0.05 
VARIABLE  VIA6_EN_3    0.04 
#IFDEF N80
  VARIABLE  VIA6_R_2_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA6_R_2_S2  0.63  	// N80 blow-up rule
  VARIABLE  VIA6_R_2_S3  0.85  	// N80 blow-up rule
  VARIABLE  VIA6_R_2_W   0.47 	// N80 blow-up rule
  VARIABLE  VIA6_R_3_S1  0.32  	// N80 blow-up rule
  VARIABLE  VIA6_R_3_S2  0.85  	// N80 blow-up rule
  VARIABLE  VIA6_R_3_W   1.26  	// N80 blow-up rule
  VARIABLE  VIA6_R_4_W   0.77 	// N80 blow-up rule
  VARIABLE  VIA6_R_4_D   1.0
  VARIABLE  VIA6_R_5_W   2.2 	// N80 blow-up rule
  VARIABLE  VIA6_R_5_D   2.0
  VARIABLE  VIA6_R_6_W   3.3 	// N80 blow-up rule
  VARIABLE  VIA6_R_6_L   11.0 	// N80 blow-up rule
  VARIABLE  VIA6_R_6_D   5.0
#ELSE
  VARIABLE  VIA6_R_2_S1  0.29 
  VARIABLE  VIA6_R_2_S2  0.57 
  VARIABLE  VIA6_R_2_S3  0.77 
  VARIABLE  VIA6_R_2_W   0.42 
  VARIABLE  VIA6_R_3_S1  0.29 
  VARIABLE  VIA6_R_3_S2  0.77 
  VARIABLE  VIA6_R_3_W   1.14
  VARIABLE  VIA6_R_4_W   0.7
  VARIABLE  VIA6_R_4_D   1.0
  VARIABLE  VIA6_R_5_W   2.0
  VARIABLE  VIA6_R_5_D   2.0
  VARIABLE  VIA6_R_6_W   3.0
  VARIABLE  VIA6_R_6_L   10.0
  VARIABLE  VIA6_R_6_D   5.0
#ENDIF
VARIABLE  VIA6_R_11_L   1.0
VARIABLE  VIA6_R_11_W   0.42
VARIABLE  VIA6_R_11_A   5.0
VARIABLE  VIA6_R_11_L2  5.0


#IFDEF N80
  VARIABLE  VIA6_S_3R     0.17    // Recommended for N80 proces 
#ENDIF

VARIABLE  M7_W_1     0.14 
VARIABLE  M7_W_2     0.19 
VARIABLE  M7_W_3     12.0 
VARIABLE  M7_S_1     0.14 
#IFDEF N80
  VARIABLE  M7_S_2     0.19 
  VARIABLE  M7_S_2_W   0.24	// N80 blow-up rule
  VARIABLE  M7_S_2_L   0.575	// N80 blow-up rule
  VARIABLE  M7_S_2_1   0.15	// N80 added rule
  VARIABLE  M7_S_2_1_W 0.21	// N80 added rule
  VARIABLE  M7_S_2_1_L 0.80	// N80 added rule
  VARIABLE  M7_S_3     0.5 
  VARIABLE  M7_S_3_W   1.65	// N80 blow-up rule
  VARIABLE  M7_S_3_L   1.65	// N80 blow-up rule
  VARIABLE  M7_S_4     1.5 
  VARIABLE  M7_S_4_W   4.95	// N80 blow-up rule
  VARIABLE  M7_S_4_L   4.95	// N80 blow-up rule
#ELSE
  VARIABLE  M7_S_2     0.19 
  VARIABLE  M7_S_2_W   0.21 
  VARIABLE  M7_S_2_L   0.52 
  VARIABLE  M7_S_3     0.5 
  VARIABLE  M7_S_3_W   1.5 
  VARIABLE  M7_S_3_L   1.5 
  VARIABLE  M7_S_4     1.5 
  VARIABLE  M7_S_4_W   4.5 
  VARIABLE  M7_S_4_L   4.5 
#ENDIF
VARIABLE  M7_S_5     0.19
VARIABLE  M7_EN_1    0.005
VARIABLE  M7_EN_2    0.05 
VARIABLE  M7_EN_3    0.04 
VARIABLE  M7_A_1     0.07 
VARIABLE  M7_A_2     0.2 
#IFDEF N80
  VARIABLE  M7_W_2R    0.205  	// Recommended for N80 process
  VARIABLE  M7_S_5R    0.205  	// Recommended for N80 process
#ENDIF




VARIABLE  VIA7_W_1    0.36  // 3XTM 
VARIABLE  VIA7_W_2    0.28  // 3XTM	// For VIA bar on sealring
VARIABLE  VIA7_S_1    0.34  // 3XTM
VARIABLE  VIA7_S_2    0.54  // 3XTM
VARIABLE  VIA7_S_2_S  0.56  // 3XTM
VARIABLE  VIA7_EN_1   0.03  // 3XTM
VARIABLE  VIA7_EN_2   0.08  // 3XTM
#IFDEF N80
  VARIABLE  VIA7_R_2_S  1.87  // 3XTM, N80 blow-up rule
  VARIABLE  VIA7_R_2_W  1.98  // 3XTM, N80 blow-up rule
  VARIABLE  VIA7_R_3_W  3.3   // 3XTM, N80 blow-up rule
  VARIABLE  VIA7_R_3_L  11.0  // 3XTM, N80 blow-up rule
  VARIABLE  VIA7_R_3_D  5.0   // 3XTM
#ELSE
  VARIABLE  VIA7_R_2_S  1.7   // 3XTM 
  VARIABLE  VIA7_R_2_W  1.8   // 3XTM
  VARIABLE  VIA7_R_3_W  3.0   // 3XTM
  VARIABLE  VIA7_R_3_L  10.0  // 3XTM
  VARIABLE  VIA7_R_3_D  5.0   // 3XTM
#ENDIF
VARIABLE  M8_W_1    0.42   // 3XTM
VARIABLE  M8_W_2    12.0   // 3XTM
VARIABLE  M8_S_1    0.42   // 3XTM
#IFDEF N80
  VARIABLE  M8_S_2    0.50   // 3XTM
  VARIABLE  M8_S_2_W  1.65   // 3XTM, N80 blow-up rule
  VARIABLE  M8_S_2_L  1.65   // 3XTM, N80 blow-up rule
  VARIABLE  M8_S_3    1.50   // 3XTM
  VARIABLE  M8_S_3_W  4.95   // 3XTM, N80 blow-up rule
  VARIABLE  M8_S_3_L  4.95   // 3XTM, N80 blow-up rule
#ELSE
  VARIABLE  M8_S_2    0.5    // 3XTM
  VARIABLE  M8_S_2_W  1.5    // 3XTM
  VARIABLE  M8_S_2_L  1.5    // 3XTM
  VARIABLE  M8_S_3    1.5    // 3XTM
  VARIABLE  M8_S_3_W  4.5    // 3XTM
  VARIABLE  M8_S_3_L  4.5    // 3XTM
#ENDIF
VARIABLE  M8_EN_1   0.03   // 3XTM
VARIABLE  M8_EN_2   0.08   // 3XTM
VARIABLE  M8_A_1    0.565  // 3XTM 
VARIABLE  M8_A_2    0.565  // 3XTM






VARIABLE  VIA8_W_1    0.36  // 3XTM 
VARIABLE  VIA8_W_2    0.28  // 3XTM	// For VIA bar on sealring
VARIABLE  VIA8_S_1    0.34  // 3XTM
VARIABLE  VIA8_S_2    0.54  // 3XTM
VARIABLE  VIA8_S_2_S  0.56  // 3XTM
VARIABLE  VIA8_EN_1   0.03  // 3XTM
VARIABLE  VIA8_EN_2   0.08  // 3XTM
#IFDEF N80
  VARIABLE  VIA8_R_2_S  1.87  // 3XTM, N80 blow-up rule
  VARIABLE  VIA8_R_2_W  1.98  // 3XTM, N80 blow-up rule
  VARIABLE  VIA8_R_3_W  3.3   // 3XTM, N80 blow-up rule
  VARIABLE  VIA8_R_3_L  11.0  // 3XTM, N80 blow-up rule
  VARIABLE  VIA8_R_3_D  5.0   // 3XTM
#ELSE
  VARIABLE  VIA8_R_2_S  1.7   // 3XTM 
  VARIABLE  VIA8_R_2_W  1.8   // 3XTM
  VARIABLE  VIA8_R_3_W  3.0   // 3XTM
  VARIABLE  VIA8_R_3_L  10.0  // 3XTM
  VARIABLE  VIA8_R_3_D  5.0   // 3XTM
#ENDIF
VARIABLE  M9_W_1    0.42   // 3XTM
VARIABLE  M9_W_2    12.0   // 3XTM
VARIABLE  M9_S_1    0.42   // 3XTM
#IFDEF N80
  VARIABLE  M9_S_2    0.50   // 3XTM
  VARIABLE  M9_S_2_W  1.65   // 3XTM, N80 blow-up rule
  VARIABLE  M9_S_2_L  1.65   // 3XTM, N80 blow-up rule
  VARIABLE  M9_S_3    1.50   // 3XTM
  VARIABLE  M9_S_3_W  4.95   // 3XTM, N80 blow-up rule
  VARIABLE  M9_S_3_L  4.95   // 3XTM, N80 blow-up rule
#ELSE
  VARIABLE  M9_S_2    0.5    // 3XTM
  VARIABLE  M9_S_2_W  1.5    // 3XTM
  VARIABLE  M9_S_2_L  1.5    // 3XTM
  VARIABLE  M9_S_3    1.5    // 3XTM
  VARIABLE  M9_S_3_W  4.5    // 3XTM
  VARIABLE  M9_S_3_L  4.5    // 3XTM
#ENDIF
VARIABLE  M9_EN_1   0.03   // 3XTM
VARIABLE  M9_EN_2   0.08   // 3XTM
VARIABLE  M9_A_1    0.565  // 3XTM 
VARIABLE  M9_A_2    0.565  // 3XTM




VARIABLE  VIAD_W_1    0.36  // 3XTM 
VARIABLE  VIAD_W_2    0.28  // 3XTM	// For VIA bar on sealring
VARIABLE  VIAD_S_1    0.34  // 3XTM
VARIABLE  VIAD_S_2    0.54  // 3XTM
VARIABLE  VIAD_S_2_S  0.56  // 3XTM
VARIABLE  VIAD_EN_1   0.03  // 3XTM
VARIABLE  VIAD_EN_2   0.08  // 3XTM
#IFDEF N80
  VARIABLE  VIAD_R_2_S  1.87  // 3XTM, N80 blow-up rule
  VARIABLE  VIAD_R_2_W  1.98  // 3XTM, N80 blow-up rule
  VARIABLE  VIAD_R_3_W  3.3   // 3XTM, N80 blow-up rule
  VARIABLE  VIAD_R_3_L  11.0  // 3XTM, N80 blow-up rule
  VARIABLE  VIAD_R_3_D  5.0   // 3XTM
#ELSE
  VARIABLE  VIAD_R_2_S  1.7   // 3XTM 
  VARIABLE  VIAD_R_2_W  1.8   // 3XTM
  VARIABLE  VIAD_R_3_W  3.0   // 3XTM
  VARIABLE  VIAD_R_3_L  10.0  // 3XTM
  VARIABLE  VIAD_R_3_D  5.0   // 3XTM
#ENDIF
VARIABLE  MD_W_1    0.42   // 3XTM
VARIABLE  MD_W_2    12.0   // 3XTM
VARIABLE  MD_S_1    0.42   // 3XTM
#IFDEF N80
  VARIABLE  MD_S_2    0.50   // 3XTM
  VARIABLE  MD_S_2_W  1.65   // 3XTM, N80 blow-up rule
  VARIABLE  MD_S_2_L  1.65   // 3XTM, N80 blow-up rule
  VARIABLE  MD_S_3    1.50   // 3XTM
  VARIABLE  MD_S_3_W  4.95   // 3XTM, N80 blow-up rule
  VARIABLE  MD_S_3_L  4.95   // 3XTM, N80 blow-up rule
#ELSE
  VARIABLE  MD_S_2    0.5    // 3XTM
  VARIABLE  MD_S_2_W  1.5    // 3XTM
  VARIABLE  MD_S_2_L  1.5    // 3XTM
  VARIABLE  MD_S_3    1.5    // 3XTM
  VARIABLE  MD_S_3_W  4.5    // 3XTM
  VARIABLE  MD_S_3_L  4.5    // 3XTM
#ENDIF
VARIABLE  MD_EN_1   0.03   // 3XTM
VARIABLE  MD_EN_2   0.08   // 3XTM
VARIABLE  MD_A_1    0.565  // 3XTM 
VARIABLE  MD_A_2    0.565  // 3XTM



VARIABLE  MOM_A_1    2.77E8
VARIABLE  MOM_S_3    0.14
VARIABLE  MOM_S_4    0.15
VARIABLE  MOM_A_2    2E6

VARIABLE  LOGO_S_1  10.0

#IFDEF N80
VARIABLE SRAM_BTC_S_1 0.15
VARIABLE SRAM_BTC_S_2 0.105
VARIABLE SRAM_BTC_S_3 0.116
#ELSE
#IFDEF N85
VARIABLE SRAM_BTC_S_1 0.14
VARIABLE SRAM_BTC_S_2 0.095
VARIABLE SRAM_BTC_S_3 0.116
#ELSE
VARIABLE SRAM_BTC_S_1 0.14
VARIABLE SRAM_BTC_S_2 0.115
VARIABLE SRAM_BTC_S_3 0.136
#ENDIF
#ENDIF


VARIABLE  SRAM_W_1  0.62
VARIABLE  SRAM_EX_1 0.62

VARIABLE  CSR_R_2   1.5 
VARIABLE  CSR_S_1   0.32 
VARIABLE  CSR_S_2   0.29 
VARIABLE  CSR_S_3   0.40 
// L-mark corner
VARIABLE  CSR_W_1    10 
VARIABLE  CSR_W_2_1   6 
VARIABLE  CSR_W_2_2   8 
VARIABLE  CSR_L_1_1  20 
VARIABLE  CSR_L_1_2  25 
#IFDEF WLCSPSealringCorner
#IFDEF UTM
  VARIABLE  CSR_EN_5_1_L1 15.5
  VARIABLE  CSR_EN_5_1_L2 16.5 
  VARIABLE  CSR_EN_4_1    4 
  VARIABLE  CSR_EN_4_2    6 
#ELSE

  VARIABLE  CSR_EN_5_1_L1 18.5
  VARIABLE  CSR_EN_5_1_L2 19.5 
  VARIABLE  CSR_EN_4_1_1  4 
  VARIABLE  CSR_EN_4_1_2  7 
#ENDIF // UTM

#ELSE
  VARIABLE  CSR_EN_4_1  4 
  VARIABLE  CSR_EN_4_2  6 
#IFDEF UTM
  VARIABLE  CSR_EN_5_1 27 
#ELSE

  VARIABLE  CSR_EN_5_1 28 
#ENDIF // UTM

VARIABLE  CSR_EN_5_2 29 
#ENDIF  // WLCSPSealringCorner  
VARIABLE  CSR_EN_6   0.52 
VARIABLE  CSR_EN_7   0.25 

VARIABLE  SR_S_1    10
#IFDEF UTM
 VARIABLE  SR_EN_1    2
#ELSE    //UTM

 VARIABLE  SR_EN_1    0.5
#ENDIF  //UTM


VARIABLE  SEALRING_M1   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M2   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M3   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M4   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M5   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M6   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M7   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M8   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_M9   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  SEALRING_MD   2.5	// Exact space between wide and narrow sealring metal rings 
VARIABLE  MM_SEALRING_M1   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M2   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M3   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M4   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M5   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M6   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M7   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M8   1.9	// // Since MM Ver 1.1 top metal space follows that of inter metal.
VARIABLE  MM_SEALRING_M9   2.0	// Exact space between wide and narrow sealring metal rings


VARIABLE  DOD_W_1   0.5 
VARIABLE  DOD_S_1   0.4 
VARIABLE  DOD_S_2   0.6 
VARIABLE  DOD_S_3   0.6 
VARIABLE  DOD_S_8   0.6 
VARIABLE  DOD_EN_2  0.6 
VARIABLE  DOD_S_5   0.6 
VARIABLE  DOD_S_6   1.2 
VARIABLE  DOD_S_7   1.2 
VARIABLE  DOD_S_7_1 5.0 
VARIABLE  DOD_S_10  1.2 
VARIABLE  DOD_EN_1  0.6 


VARIABLE  DPO_W_1   0.4 
VARIABLE  DPO_S_2   0.2 
VARIABLE  DPO_S_3   0.5 
VARIABLE  DPO_EN_1  0.6 
VARIABLE  DPO_S_1   0.3 
VARIABLE  DPO_S_5   1.2 
VARIABLE  DPO_S_6   1.2 
VARIABLE  DPO_S_6_1 5.0 
VARIABLE  DPO_S_9   1.2 


VARIABLE  DM1_W_2   3.0 
VARIABLE  DM1_S_3   1.5 
VARIABLE  DM1_S_3_L 4.5 
VARIABLE  DM1_S_4   5.0 
VARIABLE  DM1_S_5   5.0 
VARIABLE  DM1_S_5_1 5.0 
VARIABLE  DM1_S_8   2.5 
VARIABLE  DM1_EN_1  2.5 

VARIABLE  DM2_W_2   3.0 
VARIABLE  DM2_S_3   1.5 
VARIABLE  DM2_S_3_L 4.5 
VARIABLE  DM2_S_4   5.0 
VARIABLE  DM2_S_5   5.0 
VARIABLE  DM2_S_5_1 5.0 
VARIABLE  DM2_S_8   2.5 
VARIABLE  DM2_EN_1  2.5 

VARIABLE  DM3_W_2   3.0 
VARIABLE  DM3_S_3   1.5 
VARIABLE  DM3_S_3_L 4.5 
VARIABLE  DM3_S_4   5.0 
VARIABLE  DM3_S_5   5.0 
VARIABLE  DM3_S_5_1 5.0 
VARIABLE  DM3_S_8   2.5 
VARIABLE  DM3_EN_1  2.5 

VARIABLE  DM4_W_2   3.0 
VARIABLE  DM4_S_3   1.5 
VARIABLE  DM4_S_3_L 4.5 
VARIABLE  DM4_S_4   5.0 
VARIABLE  DM4_S_5   5.0 
VARIABLE  DM4_S_5_1 5.0 
VARIABLE  DM4_S_8   2.5 
VARIABLE  DM4_EN_1  2.5 

VARIABLE  DM5_W_2   3.0 
VARIABLE  DM5_S_3   1.5 
VARIABLE  DM5_S_3_L 4.5 
VARIABLE  DM5_S_4   5.0 
VARIABLE  DM5_S_5   5.0 
VARIABLE  DM5_S_5_1 5.0 
VARIABLE  DM5_S_8   2.5 
VARIABLE  DM5_EN_1  2.5 

VARIABLE  DM6_W_2   3.0 
VARIABLE  DM6_S_3   1.5 
VARIABLE  DM6_S_3_L 4.5 
VARIABLE  DM6_S_4   5.0 
VARIABLE  DM6_S_5   5.0 
VARIABLE  DM6_S_5_1 5.0 
VARIABLE  DM6_S_8   2.5 
VARIABLE  DM6_EN_1  2.5 

VARIABLE  DM7_W_2   3.0 
VARIABLE  DM7_S_3   1.5 
VARIABLE  DM7_S_3_L 4.5 
VARIABLE  DM7_S_4   5.0 
VARIABLE  DM7_S_5   5.0 
VARIABLE  DM7_S_5_1 5.0 
VARIABLE  DM7_S_8   2.5 
VARIABLE  DM7_EN_1  2.5 

VARIABLE  DM8_W_2   3.0 
VARIABLE  DM8_S_3   1.5 
VARIABLE  DM8_S_3_L 4.5 
VARIABLE  DM8_S_4   5.0 
VARIABLE  DM8_S_5   5.0 
VARIABLE  DM8_S_5_1 5.0 
VARIABLE  DM8_S_8   2.5 
VARIABLE  DM8_EN_1  2.5 

VARIABLE  DM9_W_2   3.0 
VARIABLE  DM9_S_3   1.5 
VARIABLE  DM9_S_3_L 4.5 
VARIABLE  DM9_S_4   5.0 
VARIABLE  DM9_S_5   5.0 
VARIABLE  DM9_S_5_1 5.0 
VARIABLE  DM9_S_8   2.5 
VARIABLE  DM9_EN_1  2.5 

VARIABLE  DM1_W_1   0.32 
VARIABLE  DM1_S_1   0.4 
VARIABLE  DM1_S_2   0.6 
VARIABLE  DM1_A_1   0.32 
VARIABLE  DM1_A_2   80 
VARIABLE  DM2_W_1   0.32 
VARIABLE  DM2_S_1   0.4 
VARIABLE  DM2_S_2   0.6 
VARIABLE  DM2_A_1   0.32 
VARIABLE  DM2_A_2   80 
VARIABLE  DM3_W_1   0.32 
VARIABLE  DM3_S_1   0.4 
VARIABLE  DM3_S_2   0.6 
VARIABLE  DM3_A_1   0.32 
VARIABLE  DM3_A_2   80 
VARIABLE  DM4_W_1   0.32 
VARIABLE  DM4_S_1   0.4 
VARIABLE  DM4_S_2   0.6 
VARIABLE  DM4_A_1   0.32 
VARIABLE  DM4_A_2   80 
VARIABLE  DM5_W_1   0.32 
VARIABLE  DM5_S_1   0.4 
VARIABLE  DM5_S_2   0.6 
VARIABLE  DM5_A_1   0.32 
VARIABLE  DM5_A_2   80 
VARIABLE  DM6_W_1   0.32 
VARIABLE  DM6_S_1   0.4 
VARIABLE  DM6_S_2   0.6 
VARIABLE  DM6_A_1   0.32 
VARIABLE  DM6_A_2   80 
VARIABLE  DM7_W_1   0.32 
VARIABLE  DM7_S_1   0.4 
VARIABLE  DM7_S_2   0.6 
VARIABLE  DM7_A_1   0.32 
VARIABLE  DM7_A_2   80 

VARIABLE  DM7_S_9  1.5



  VARIABLE  DM8_W_1   0.6 
  VARIABLE  DM8_S_1   0.8 
  VARIABLE  DM8_S_2   0.6 
  VARIABLE  DM8_A_1   0.6 
  VARIABLE  DM8_A_2   160.0




VARIABLE  DM9_W_1   0.6 
VARIABLE  DM9_S_1   0.8 
VARIABLE  DM9_S_2   0.6 
VARIABLE  DM9_A_1   0.6 
VARIABLE  DM9_A_2   160

VARIABLE  DMD_W_1   0.6 
VARIABLE  DMD_W_2   3.0 
VARIABLE  DMD_S_1   0.8 
VARIABLE  DMD_S_2   0.6 
VARIABLE  DMD_S_4   5.0 
VARIABLE  DMD_S_5   5.0 
VARIABLE  DMD_S_5_1 5.0 
VARIABLE  DMD_S_8   2.5 
VARIABLE  DMD_A_1   0.6 
VARIABLE  DMD_A_2   160 
VARIABLE  DMD_EN_1  2.5 
VARIABLE  DMD_S_3   1.5 
VARIABLE  DMD_S_3_L 4.5 



VARIABLE Mx_DN_1H 0.7
VARIABLE Mx_DN_1L 0.15
VARIABLE Mx_DN_W1 50
VARIABLE Mx_DN_W2 100

VARIABLE  LUP_2g   20.0
VARIABLE  LUP_3g_W 0.2
VARIABLE  LUP_3_1g 2
VARIABLE  LUP_3_2g 2.3
VARIABLE  LUP_3_3g 2.6
VARIABLE  LUP_3_4g 5
VARIABLE  LUP_4g   0.2
VARIABLE  LUP_5_1g 2
VARIABLE  LUP_5_2g 2.3
VARIABLE  LUP_5_3g 2.6
VARIABLE  LUP_5_4g 5
VARIABLE  LUP_6   30.0
VARIABLE  LUP_6_SRAM 40.0

VARIABLE  ESD_3g_MIN   15.0
VARIABLE  ESD_3g_MAX   60.0
VARIABLE  ESD_6g       2.0
VARIABLE  ESD_7g       2.4
VARIABLE  ESD_16g      360 
VARIABLE  ESD_17g      360
VARIABLE  ESD_18g_33V  0.4
VARIABLE  ESD_18g_25V  0.35
VARIABLE  ESD_18g_18V  0.2
VARIABLE  ESD_18g_10V  0.15
VARIABLE  ESD_20g      0.06
VARIABLE  ESD_21g      1.95
VARIABLE  ESD_22g      1.0
VARIABLE  ESD_23g      0.4
VARIABLE  ESD_24g      360
VARIABLE  ESD_25g      360
VARIABLE  ESD_26g_5V  0.4
VARIABLE  ESD_26g_33V  0.35
VARIABLE  ESD_26g_25V  0.2
VARIABLE  ESD_28g      0.06
VARIABLE  ESD_29g      0.06
VARIABLE  ESD_30g      1.95
VARIABLE  ESD_31g      1.0
VARIABLE  ESD_32g      0.4
VARIABLE  ESD_33g      0.25
VARIABLE  ESD_36g      360
VARIABLE  ESD_37g      900
VARIABLE  ESD_38g_33V  0.4
VARIABLE  ESD_38g_25V  0.35
VARIABLE  ESD_38g_18V  0.2
VARIABLE  ESD_38g_LV   0.15
VARIABLE  ESD_40g      0.06
VARIABLE  ESD_41g      1.95
VARIABLE  ESD_42g      0.4
VARIABLE  ESD_44g      360
VARIABLE  ESD_45g      360
VARIABLE  ESD_46g      0.2
VARIABLE  ESD_48g      0.45
VARIABLE  ESD_49g      1.5
VARIABLE  ESD_50g      1.5
VARIABLE  ESD_51g      0.4
VARIABLE  ESD_53g      360
VARIABLE  ESD_54g_33V  0.4
VARIABLE  ESD_54g_25V  0.35
VARIABLE  ESD_56g      1.95
VARIABLE  ESD_57g      0.4




//UTM rule variables
#IFNDEF N80
  VARIABLE	VIAn_EN_5	0.08
  VARIABLE	VIAn_R_9	1.7
  VARIABLE	UTM_W_1 	2.0
  VARIABLE	UTM_W_2		12
  VARIABLE	UTM_W_3		30
  VARIABLE	UTM_W_4		600
  VARIABLE	UTM_S_1		2
  VARIABLE	UTM_S_2		3
  VARIABLE	UTM_S_2A	12
  VARIABLE	UTM_EN_1	0.3
  VARIABLE	UTM_EN_2	0.4
  VARIABLE	UTM_A_1		9
  VARIABLE	UTM_A_2		9
#ELSE
  VARIABLE	VIAn_EN_5	0.085
  VARIABLE	VIAn_R_9	1.87
  VARIABLE	UTM_W_1 	2.2
  VARIABLE	UTM_W_2		12
  VARIABLE	UTM_W_3		30
  VARIABLE	UTM_W_4		600
  VARIABLE	UTM_S_1		1.65
  VARIABLE	UTM_S_2		3
  VARIABLE	UTM_S_2A	12
  VARIABLE	UTM_EN_1	0.33
  VARIABLE	UTM_EN_2	0.4
  VARIABLE	UTM_A_1		10
  VARIABLE	UTM_A_2		10
#ENDIF







LAYER RRuleRequired 1821        // marker layer for DFM action-required rules
LAYER MAP 182 DATATYPE 1 1821
LAYER RRuleRecommended 1822	// marker layer for DFM recommendations
LAYER MAP 182 DATATYPE 2 1822
LAYER RRuleAnalog 1823		// marker layer for analog rules and recommendations
LAYER MAP 182 DATATYPE 3 1823
LAYER RRuleGuideline 1824	// marker layer for DFM guidelines
LAYER MAP 182 DATATYPE 4 1824
LAYER excludeRRuleRequired 1831  // marker layer for excluding DFM action-required rules
LAYER MAP 182 DATATYPE 11 1831
LAYER excludeRRuleRecommended 1832 // marker layer for excluding DFM recommendations
LAYER MAP 182 DATATYPE 12 1832
LAYER excludeRRuleAnalog 1833	   // marker layer for excluding analog rules and recommendations
LAYER MAP 182 DATATYPE 13 1833
LAYER excludeRRuleGuideline 1834   // marker layer for excluding DFM guidelines
LAYER MAP 182 DATATYPE 14 1834
LAYER 	RODMY	49
//
//  DRAWN LAYER DEFINITIONS
//---------------------------

LAYER DNWi       1   // deep-nwell
LAYER NWi         3000  // nwell technology
LAYER MAP 3 DATATYPE >=0 <=255 3000
LAYER NWi_OTHERS  3001     
LAYER MAP 3 DATATYPE >=1 <=255 3001
LAYER OD_18i     16  // define 1.8V thick gate oxides
LAYER OD_25i     41  // define 2.5V thick gate oxides
LAYER OD_2533     4130      // a dummy layer for 2.5V MOS overdriven to 3.3V
LAYER MAP 41 DATATYPE 3 4130  		
LAYER OD_33i     15  // define 3.3V thick gate oxides
LAYER OD_DECAP   118 // decoupling capacitor device region
LAYER PPi        25  // P+ S/D imlant
LAYER NPi        26  // N+ S/D imlant
LAYER COi        30  // Define connect for M1 to S/D and Gate
LAYER CBi        43  // Passivation opening for Bond Pad
LAYER CB2i       86  // Passivation-2 opening for Bond Pad
LAYER RPOi       29  // Silicided Block Layer
LAYER NT_Ni      11  // Native NMOS blocked implant
LAYER NCap_NTNi 450  // connected NMOS capacitors within same NT_N region
LAYER MAP 11 DATATYPE 20 450
LAYER FW_APi      951   // Al fuse window
LAYER MAP 95 DATATYPE 20 951
LAYER FW_CUi      952   // Cu fuse window
LAYER MAP 95 DATATYPE 0 952
FWi = FW_APi OR FW_CUi 
LAYER PMi 5
LAYER PM1i        5001   // Polymide (if drawn)
LAYER MAP 5  DATATYPE 1 5001	 
LAYER PM2i        5002   // Polymide (if drawn)
LAYER MAP 5  DATATYPE 2 5002	 
LAYER SEALRINGi  162 // SEALRING Layer to cover seal ring area
LAYER VTH_Ni     67  // 1.0V High Vt NMOS Implant
LAYER VTH_Pi     68  // 1.0V High Vt PMOS Implant
LAYER ULVT_Ni	 15100 // 1.2V ultra low Vt NMOS implant
LAYER MAP 151 DATATYPE 0 15100
LAYER ULVT_Pi	 15200 // 1.2V ultra low Vt PMOS implant
LAYER MAP 152 DATATYPE 0 15200
LAYER VTL_Ni     12  // 1.0V Low Vt NMOS Implant
LAYER VTL_Pi     13  // 1.0V Low Vt PMOS Implant
LAYER CBDi       169 // CBD For solder Bump and RDL layer 
LAYER UBMi       170 // UBM For solder Bump and RDL layer 
LAYER VTUH_Ni     93  // 1.2V Ultra High Vt NMOS Implant
LAYER VTUH_Pi     94  // 1.2V Ultra High Vt PMOS Implant
LAYER RH         117  // Form P+OD/POLY resistor & N+OD/POLY resistor with RPO
LAYER ESD3       147
LAYER VARi       143  // For both MOS and junction type varactor
LAYER APi         42  // AlRDL
LAYER Cu_PPIi	  4210 //Cu_PPI interconnection between Polymide1 and Polymide2 for WLCSP 
LAYER MAP 42 DATATYPE 10 4210
LAYER RVi         85  // Via hole for AlRDL
LAYER SANi        81
LAYER CBMi        88
LAYER CTMi        77
LAYER SRM         50
LAYER LMARK      109  // Alignment Mark Rule for Laser Repair
//
// Dummy Layers
//
LAYER BJTDMY     110  // BJT dummy layer to cover BJT device
LAYER DIODMY     119  // dummy layer for diode
LAYER NWDMY      114  // NWEL resistor dummy layer
LAYER RPDMY      115  // dummy layer to cover precision high poly resistor
LAYER DPDMY      1230 // dummy pad area dummy layer
LAYER MAP 123 DATATYPE 0 1230
LAYER PLDMY      1240 // power line area dummy layer
LAYER MAP 124 DATATYPE 0 1240

LAYER SDI        122  // cover IO ESD area
LAYER PMDMY      106  // dummy layer to cover fuse window and protection ring structure
LAYER ESD1DMY    145
LAYER ESD2DMY    146
LAYER CDUDMY     165  // CDUDMY Dummy layer to cover CDU pattern
LAYER CSRDMY	 166  // Layer to cover chip corner areas
LAYER LOGO       158  // Dummy layer for product labels and LOGO
LAYER INDDMY     144  // Dummy layer for inductor
LAYER CTMDMY     148   
LAYER WBDMY      183  // For CUP purpose
LAYER LUPWDMY    2551 // DRC dummy layer to waive Latch-Up rules for verified IP.
LAYER MAP 255 DATATYPE 1 2551
LAYER VDDDMY    2554  // DRC dummy layer to identify VDD PAD for Latch-Up rules.
LAYER MAP 255 DATATYPE 4 2554
LAYER VSSDMY    2555  // DRC dummy layer to identify VSS PAD for Latch-Up rules.
LAYER MAP 255 DATATYPE 5 2555


LAYER  MOMDMY_1  1551     // Dummy layer for M1 MOM region
LAYER MAP 155 DATATYPE 1 1551
LAYER  MOMDMY_2  1552     // Dummy layer for M2 MOM region
LAYER MAP 155 DATATYPE 2 1552
LAYER  MOMDMY_3  1553     // Dummy layer for M3 MOM region
LAYER MAP 155 DATATYPE 3 1553
LAYER  MOMDMY_4  1554     // Dummy layer for M4 MOM region
LAYER MAP 155 DATATYPE 4 1554
LAYER  MOMDMY_5  1555     // Dummy layer for M5 MOM region
LAYER MAP 155 DATATYPE 5 1555
LAYER  MOMDMY_6  1556     // Dummy layer for M6 MOM region
LAYER MAP 155 DATATYPE 6 1556
LAYER  MOMDMY_7  1557     // Dummy layer for M7 MOM region
LAYER MAP 155 DATATYPE 7 1557
LAYER  MOMDMY_8  1558     // Dummy layer for M8 MOM region
LAYER MAP 155 DATATYPE 8 1558
LAYER  MOMDMY_9  1559     // Dummy layer for M9 MOM region
LAYER MAP 155 DATATYPE 9 1559

LAYER  MOMDMY_AP 1570            // Dummy layer for AP MOM region
LAYER MAP 155 DATATYPE 20 1570
LAYER RTMOMDMY  1571            // Dummy layer for RTMOM 
LAYER MAP 155 DATATYPE 21 1571
LAYER RFDMY      161  // For RF circuit
LAYER SRAMDMY    400         // SRAM DRC violations waive layer		
LAYER MAP 186 DATATYPE 0 400  		
LAYER SRAMDMY_PERI    401    // SRAM periphrial region outside SRAMDMY
LAYER MAP 186 DATATYPE 4 401 
LAYER SRAMDMY6_PERI    402    // SRAM periphrial region outside SRAMDMY
LAYER MAP 186 DATATYPE 6 402 
LAYER SBDDMY     113  	     // SBDDMY to cover schottky barrier diode
LAYER MAP 182 DATATYPE 70 1827
LAYER MATCHING	 1827


LAYER M1_real        671         // Metal1 layer (drawing metal)
LAYER MAP 31 DATATYPE 0 671  // Mapping (31;0) to 671 for M1
LAYER M1i        321         // Metal1 layer
LAYER MAP 31 DATATYPE 0 321  // Mapping (31;0) to 321 for M1i
LAYER MAP 31 DATATYPE 7 321  // Mapping (DM1_O, 31;7) to 321 for M1i, OPC dummy metal
LAYER DUM1       331         // dummy Metal1
LAYER MAP 31 DATATYPE 1 331  // Mapping (31;1) to 331 for DUM1
LAYER DUM1_O     661         // opc dummy Metal1
LAYER MAP 31 DATATYPE 7 661  // Mapping (31;7) to 661 for DUM1
LAYER NOTUSEM1   341 // TSMC internal mask making layer (31;161-165)
LAYER MAP 31 DATATYPE >=161 <=165  341
LAYER NOUSEM1    31         // unused metals (31;2-6,8-160,166-255)
LAYER M2_real        672         // Metal2 layer (drawing metal)
LAYER MAP 32 DATATYPE 0 672  // Mapping (32;0) to 672 for M2
LAYER M2i        322         // Metal2 layer
LAYER MAP 32 DATATYPE 0 322  // Mapping (32;0) to 322 for M2i
LAYER MAP 32 DATATYPE 7 322  // Mapping (DM2_O, 32;7) to 322 for M2i, OPC dummy metal
LAYER DUM2       332         // dummy Metal2
LAYER MAP 32 DATATYPE 1 332  // Mapping (32;1) to 332 for DUM2
LAYER DUM2_O     662         // opc dummy Metal2
LAYER MAP 32 DATATYPE 7 662  // Mapping (32;7) to 662 for DUM2
LAYER NOTUSEM2   342 // TSMC internal mask making layer (32;161-165)
LAYER MAP 32 DATATYPE >=161 <=165  342
LAYER NOUSEM2    32         // unused metals (32;2-6,8-160,166-255)
LAYER M3_real        673         // Metal3 layer (drawing metal)
LAYER MAP 33 DATATYPE 0 673  // Mapping (33;0) to 673 for M3
LAYER M3i        323         // Metal3 layer
LAYER MAP 33 DATATYPE 0 323  // Mapping (33;0) to 323 for M3i
LAYER MAP 33 DATATYPE 7 323  // Mapping (DM3_O, 33;7) to 323 for M3i, OPC dummy metal
LAYER DUM3       333         // dummy Metal3
LAYER MAP 33 DATATYPE 1 333  // Mapping (33;1) to 333 for DUM3
LAYER DUM3_O     663         // opc dummy Metal3
LAYER MAP 33 DATATYPE 7 663  // Mapping (33;7) to 663 for DUM3
LAYER NOTUSEM3   343 // TSMC internal mask making layer (33;161-165)
LAYER MAP 33 DATATYPE >=161 <=165  343
LAYER NOUSEM3    33         // unused metals (33;2-6,8-160,166-255)
LAYER M4_real        674         // Metal4 layer (drawing metal)
LAYER MAP 34 DATATYPE 0 674  // Mapping (34;0) to 674 for M4
LAYER M4i        324         // Metal4 layer
LAYER MAP 34 DATATYPE 0 324  // Mapping (34;0) to 324 for M4i
LAYER MAP 34 DATATYPE 7 324  // Mapping (DM4_O, 34;7) to 324 for M4i, OPC dummy metal
LAYER DUM4       334         // dummy Metal4
LAYER MAP 34 DATATYPE 1 334  // Mapping (34;1) to 334 for DUM4
LAYER DUM4_O     664         // opc dummy Metal4
LAYER MAP 34 DATATYPE 7 664  // Mapping (34;7) to 664 for DUM4
LAYER NOTUSEM4   344 // TSMC internal mask making layer (34;161-165)
LAYER MAP 34 DATATYPE >=161 <=165  344
LAYER NOUSEM4    34         // unused metals (34;2-6,8-160,166-255)
LAYER M5_real        675         // Metal5 layer (drawing metal)
LAYER MAP 35 DATATYPE 0 675  // Mapping (35;0) to 675 for M5
LAYER M5i        325         // Metal5 layer
LAYER MAP 35 DATATYPE 0 325  // Mapping (35;0) to 325 for M5i
LAYER MAP 35 DATATYPE 7 325  // Mapping (DM5_O, 35;7) to 325 for M5i, OPC dummy metal
LAYER DUM5       335         // dummy Metal5
LAYER MAP 35 DATATYPE 1 335  // Mapping (35;1) to 335 for DUM5
LAYER DUM5_O     665         // opc dummy Metal5
LAYER MAP 35 DATATYPE 7 665  // Mapping (35;7) to 665 for DUM5
LAYER NOTUSEM5   345 // TSMC internal mask making layer (35;161-165)
LAYER MAP 35 DATATYPE >=161 <=165  345
LAYER NOUSEM5    35         // unused metals (35;2-6,8-160,166-255)
LAYER M6_real        676         // Metal6 layer (drawing metal)
LAYER MAP 36 DATATYPE 0 676  // Mapping (36;0) to 676 for M6
LAYER M6i        326         // Metal6 layer
LAYER MAP 36 DATATYPE 0 326  // Mapping (36;0) to 326 for M6i
LAYER MAP 36 DATATYPE 7 326  // Mapping (DM6_O, 36;7) to 326 for M6i, OPC dummy metal
LAYER DUM6       336         // dummy Metal6
LAYER MAP 36 DATATYPE 1 336  // Mapping (36;1) to 336 for DUM6
LAYER DUM6_O     666         // opc dummy Metal6
LAYER MAP 36 DATATYPE 7 666  // Mapping (36;7) to 666 for DUM6
LAYER NOTUSEM6   346 // TSMC internal mask making layer (36;161-165)
LAYER MAP 36 DATATYPE >=161 <=165  346
LAYER NOUSEM6    36         // unused metals (36;2-6,8-160,166-255)
LAYER M7_real        677         // Metal7 layer (drawing metal)
LAYER MAP 37 DATATYPE 0 677  // Mapping (37;0) to 677 for M7
LAYER M7i        327         // Metal7 layer
LAYER MAP 37 DATATYPE 0 327  // Mapping (37;0) to 327 for M7i
LAYER MAP 37 DATATYPE 7 327  // Mapping (DM7_O, 37;7) to 327 for M7i, OPC dummy metal
LAYER DUM7       337         // dummy Metal7
LAYER MAP 37 DATATYPE 1 337  // Mapping (37;1) to 337 for DUM7
LAYER DUM7_O     667         // opc dummy Metal7
LAYER MAP 37 DATATYPE 7 667  // Mapping (37;7) to 667 for DUM7
LAYER NOTUSEM7   347 // TSMC internal mask making layer (37;161-165)
LAYER MAP 37 DATATYPE >=161 <=165  347
LAYER NOUSEM7    37         // unused metals (37;2-6,8-160,166-255)
LAYER M8_real        678         // Metal8 layer (drawing metal)
LAYER MAP 38 DATATYPE 0 678  // Mapping (38;0) to 678 for M8
LAYER M8i        328         // Metal8 layer
LAYER MAP 38 DATATYPE 0 328  // Mapping (38;0) to 328 for M8i
LAYER MAP 38 DATATYPE 7 328  // Mapping (DM8_O, 38;7) to 328 for M8i, OPC dummy metal
LAYER DUM8       338         // dummy Metal8
LAYER MAP 38 DATATYPE 1 338  // Mapping (38;1) to 338 for DUM8
LAYER DUM8_O     668         // opc dummy Metal8
LAYER MAP 38 DATATYPE 7 668  // Mapping (38;7) to 668 for DUM8
LAYER NOTUSEM8   348 // TSMC internal mask making layer (38;161-165)
LAYER MAP 38 DATATYPE >=161 <=165  348
LAYER NOUSEM8    38         // unused metals (38;2-6,8-160,166-255)
LAYER M9_real        679         // Metal9 layer (drawing metal)
LAYER MAP 39 DATATYPE 0 679  // Mapping (39;0) to 679 for M9
LAYER M9i        329         // Metal9 layer
LAYER MAP 39 DATATYPE 0 329  // Mapping (39;0) to 329 for M9i
LAYER MAP 39 DATATYPE 7 329  // Mapping (DM9_O, 39;7) to 329 for M9i, OPC dummy metal
LAYER DUM9       339         // dummy Metal9
LAYER MAP 39 DATATYPE 1 339  // Mapping (39;1) to 339 for DUM9
LAYER DUM9_O     669         // opc dummy Metal9
LAYER MAP 39 DATATYPE 7 669  // Mapping (39;7) to 669 for DUM9
LAYER NOTUSEM9   349 // TSMC internal mask making layer (39;161-165)
LAYER MAP 39 DATATYPE >=161 <=165  349
LAYER NOUSEM9    39         // unused metals (39;2-6,8-160,166-255)
LAYER MD_real  670              // MD (drawing metal)
LAYER MAP 168 DATATYPE 0 670  	// Mapping (168;0) to 1680 for MD
LAYER MDi        1680  		// MD
LAYER MAP 168 DATATYPE 0 1680  	// Mapping (168;0) to 1680 for MD
LAYER MAP 168 DATATYPE 7 1680  	// Mapping (DMD_O, 168;7) to 1680 for MD, OPC dummy metal
LAYER DUMD       1681  		// dummy MD
LAYER MAP 168 DATATYPE 1 1681  	// Mapping (168;1) to 1681 for DUMD
LAYER DUMD_O     1687           // opc dummy MD
LAYER MAP 168 DATATYPE 7 1687   // Mapping (168;7) to 1687 for DUMD
LAYER NOTUSEMD 1682		// TSMC internal mask making layer (168;161-165)
LAYER MAP 168 DATATYPE >=161 <=165 1682 // Mapping (168;16#) to 1682 for NOTUSEMD
LAYER NOUSEMD    168  		// unused metals (168;2-6,8-160,166-255) 

LAYER DM1EXCL  1501
LAYER MAP 150 DATATYPE 1 1501
LAYER DM2EXCL  1502
LAYER MAP 150 DATATYPE 2 1502
LAYER DM3EXCL  1503
LAYER MAP 150 DATATYPE 3 1503
LAYER DM4EXCL  1504
LAYER MAP 150 DATATYPE 4 1504
LAYER DM5EXCL  1505
LAYER MAP 150 DATATYPE 5 1505
LAYER DM6EXCL  1506
LAYER MAP 150 DATATYPE 6 1506
LAYER DM7EXCL  1507
LAYER MAP 150 DATATYPE 7 1507
LAYER DM8EXCL  1508
LAYER MAP 150 DATATYPE 8 1508
LAYER DM9EXCL  1509
LAYER MAP 150 DATATYPE 9 1509
LAYER DMDEXCL    1515
LAYER MAP 150 DATATYPE 15 1515

LAYER VIA1i      51  // Define connect for M2 to M1
LAYER VIA2i      52  // Define connect for M3 to M2
LAYER VIA3i      53  // Define connect for M4 to M3
LAYER VIA4i      54  // Define connect for M5 to M4
LAYER VIA5i      55  // Define connect for M6 to M5
LAYER VIA6i      56  // Define connect for M7 to M6
LAYER VIA7i      57  // Define connect for M8 to M7
LAYER VIA8i      58  // Define connect for M9 to M8
LAYER VIADi      167 // VIAD Connection of MD and MT for RDL

LAYER ODi      355 7 8
LAYER MAP 6 DATATYPE 0 355
LAYER MAP 6 DATATYPE 2 355
LAYER MAP 6 DATATYPE >=4 <=160 355
LAYER MAP 6 DATATYPE >=166 <=255 355

LAYER ODi_OTHERS  354 7 8
LAYER MAP 6 DATATYPE 2  354
LAYER MAP 6 DATATYPE >=4 <=160 354
LAYER MAP 6 DATATYPE >=166 <=255 354

LAYER ODi_RFDRAIN 351 
LAYER MAP 6 DATATYPE 3 351

LAYER DOD      353
LAYER MAP 6 DATATYPE 1 353  // Mapping (6;1) to 353 for dummy OD
LAYER NOTUSEOD 616
LAYER MAP 6 DATATYPE >=161 <=165 616  // TSMC internal mask making layer (6;161-165)

LAYER POi      365
LAYER MAP 17 DATATYPE 0 365
LAYER MAP 17 DATATYPE >=2 <=50 365
LAYER MAP 17 DATATYPE >=52 <=160 365
LAYER MAP 17 DATATYPE >=166 <=255 365

LAYER POi_OTHERS 364            
LAYER MAP 17 DATATYPE >=2 <=50 364
LAYER MAP 17 DATATYPE >=52 <=160 364
LAYER MAP 17 DATATYPE >=166 <=255 364

LAYER DPO      361
LAYER MAP 17 DATATYPE 1 361  // Mapping (17;1) to 361 for dummy PO
LAYER PSPOi    362	     // Used to generate poly logical operation in N90LP LVT process
LAYER MAP 17 DATATYPE 51 362 // Mapping (17;51, layer PO, purpose rule1) to 361 for PSPO
LAYER NOTUSEPO 1716
LAYER MAP 17 DATATYPE >=161 <=165 1716   // TSMC internal mask making layer (17;161-165)

LAYER ODBLK  382
LAYER MAP 150 DATATYPE 20 382
LAYER POBLK  383
LAYER MAP 150 DATATYPE 21 383
LAYER RES200 2559             // Recognize resistor over 200ohm for ESD/LUP check
LAYER MAP 255 DATATYPE 9 2559
LAYER ESDIMP     1890    // ESD Implant layer
LAYER MAP 189 DATATYPE 0 1890
LAYER M1_PIN     1301
LAYER MAP 131 DATATYPE 0 1301 
LAYER M1_PIN_TEXT   11301
LAYER MAP 131 TEXTTYPE 0 11301
LAYER M2_PIN     1302
LAYER MAP 132 DATATYPE 0 1302 
LAYER M2_PIN_TEXT   11302
LAYER MAP 132 TEXTTYPE 0 11302
LAYER M3_PIN     1303
LAYER MAP 133 DATATYPE 0 1303 
LAYER M3_PIN_TEXT   11303
LAYER MAP 133 TEXTTYPE 0 11303
LAYER M4_PIN     1304
LAYER MAP 134 DATATYPE 0 1304 
LAYER M4_PIN_TEXT   11304
LAYER MAP 134 TEXTTYPE 0 11304
LAYER M5_PIN     1305
LAYER MAP 135 DATATYPE 0 1305 
LAYER M5_PIN_TEXT   11305
LAYER MAP 135 TEXTTYPE 0 11305
LAYER M6_PIN     1306
LAYER MAP 136 DATATYPE 0 1306 
LAYER M6_PIN_TEXT   11306
LAYER MAP 136 TEXTTYPE 0 11306
LAYER M7_PIN     1307
LAYER MAP 137 DATATYPE 0 1307 
LAYER M7_PIN_TEXT   11307
LAYER MAP 137 TEXTTYPE 0 11307
LAYER M8_PIN     1308
LAYER MAP 138 DATATYPE 0 1308 
LAYER M8_PIN_TEXT   11308
LAYER MAP 138 TEXTTYPE 0 11308
LAYER M9_PIN     1309
LAYER MAP 139 DATATYPE 0 1309 
LAYER M9_PIN_TEXT   11309
LAYER MAP 139 TEXTTYPE 0 11309
LAYER MD_PIN             1590
LAYER MAP 159 DATATYPE 0 1590 
LAYER MD_PIN_TEXT        11590
LAYER MAP 159 TEXTTYPE 0 11590
LAYER AP_PIN             1260
LAYER MAP 126 DATATYPE 0 1260
LAYER AP_PIN_TEXT        11260
LAYER MAP 126 TEXTTYPE 0 11260

//
//  LAYER OPERATION
//-------------------

ALL_OD = ODi OR DOD
ALL_POLY = POi OR DPO

// metal in silicon
M1x = M1i OR DUM1 
M2x = M2i OR DUM2 
M3x = M3i OR DUM3 
M4x = M4i OR DUM4 
M5x = M5i OR DUM5 
M6x = M6i OR DUM6 
M7x = M7i OR DUM7 
M8x = M8i OR DUM8 
M9x = M9i OR DUM9 
MDx = MDi OR DUMD 

LAYOUT BASE LAYER OD_18i OD_25i OD_33i NT_Ni VTH_Ni VTH_Pi VTL_Ni VTL_Pi
LAYOUT BASE LAYER DNWi NWi ODi POi PPi NPi COi
LAYOUT TOP LAYER VIA1i M2i
LAYOUT TOP LAYER VIA2i M3i
LAYOUT TOP LAYER VIA3i M4i
LAYOUT TOP LAYER VIA4i M5i
LAYOUT TOP LAYER VIA5i M6i
LAYOUT TOP LAYER VIA6i M7i
LAYOUT TOP LAYER VIA7i M8i
LAYOUT TOP LAYER VIA8i M9i
LAYOUT TOP LAYER VIADi MDi



LAYOUT TOP LAYER CBi CBDi UBMi WBDMY FW_APi FW_CUi PMi APi PMDMY DPDMY LMARK SEALRINGi CSRDMY
LAYOUT TOP LAYER NWDMY SDI
LAYOUT TOP LAYER SDI ESD1DMY ESD2DMY ESD3 SRM SRAMDMY LOGO
LAYOUT TOP LAYER DOD DPO ODBLK POBLK
LAYOUT TOP LAYER CBMi CTMi CTMDMY INDDMY VARi

LAYOUT TOP LAYER DUM1 DM1EXCL 
LAYOUT TOP LAYER DUM2 DM2EXCL 
LAYOUT TOP LAYER DUM3 DM3EXCL 
LAYOUT TOP LAYER DUM4 DM4EXCL 
LAYOUT TOP LAYER DUM5 DM5EXCL 
LAYOUT TOP LAYER DUM6 DM6EXCL 
LAYOUT TOP LAYER DUM7 DM7EXCL 
LAYOUT TOP LAYER DUM8 DM8EXCL 
LAYOUT TOP LAYER DUM9 DM9EXCL 
LAYOUT TOP LAYER DUMD DMDEXCL 




excludeRRuleRequired_EXTENT = EXTENT excludeRRuleRequired
excludeRRuleRecommended_EXTENT = EXTENT excludeRRuleRecommended
excludeRRuleAnalog_EXTENT = EXTENT excludeRRuleAnalog
excludeRRuleGuideline_EXTENT = EXTENT excludeRRuleGuideline
DNWi_EXTENT = EXTENT DNWi
NWi_EXTENT = EXTENT NWi
OD_18i_EXTENT = EXTENT OD_18i
OD_25i_EXTENT = EXTENT OD_25i
OD_2533_EXTENT = EXTENT OD_2533
OD_33i_EXTENT = EXTENT OD_33i
OD_DECAP_EXTENT = EXTENT OD_DECAP
PPi_EXTENT = EXTENT PPi
NPi_EXTENT = EXTENT NPi
COi_EXTENT = EXTENT COi
CBi_EXTENT = EXTENT CBi
CB2i_EXTENT = EXTENT CB2i
RPOi_EXTENT = EXTENT RPOi
NT_Ni_EXTENT = EXTENT NT_Ni
NCap_NTNi_EXTENT = EXTENT NCap_NTNi
FW_APi_EXTENT = EXTENT FW_APi
FW_CUi_EXTENT = EXTENT FW_CUi
PMi_EXTENT = EXTENT PMi
PM1i_EXTENT = EXTENT PM1i
PM2i_EXTENT = EXTENT PM2i
SEALRINGi_EXTENT = EXTENT SEALRINGi
VTH_Ni_EXTENT = EXTENT VTH_Ni
VTH_Pi_EXTENT = EXTENT VTH_Pi
ULVT_Ni_EXTENT = EXTENT ULVT_Ni
ULVT_Pi_EXTENT = EXTENT ULVT_Pi
VTL_Ni_EXTENT = EXTENT VTL_Ni
VTL_Pi_EXTENT = EXTENT VTL_Pi
CBDi_EXTENT = EXTENT CBDi
UBMi_EXTENT = EXTENT UBMi
VTUH_Ni_EXTENT = EXTENT VTUH_Ni
VTUH_Pi_EXTENT = EXTENT VTUH_Pi
RH_EXTENT = EXTENT RH
ESD3_EXTENT = EXTENT ESD3
VARi_EXTENT = EXTENT VARi
APi_EXTENT = EXTENT APi
Cu_PPIi_EXTENT = EXTENT Cu_PPIi
RVi_EXTENT = EXTENT RVi
SANi_EXTENT = EXTENT SANi
CBMi_EXTENT = EXTENT CBMi
CTMi_EXTENT = EXTENT CTMi
SRM_EXTENT = EXTENT SRM
LMARK_EXTENT = EXTENT LMARK
MATCHING_EXTENT = EXTENT MATCHING
M1_real_EXTENT = EXTENT M1_real
M1i_EXTENT = EXTENT M1i
DUM1_EXTENT = EXTENT DUM1
M2_real_EXTENT = EXTENT M2_real
M2i_EXTENT = EXTENT M2i
DUM2_EXTENT = EXTENT DUM2
M3_real_EXTENT = EXTENT M3_real
M3i_EXTENT = EXTENT M3i
DUM3_EXTENT = EXTENT DUM3
M4_real_EXTENT = EXTENT M4_real
M4i_EXTENT = EXTENT M4i
DUM4_EXTENT = EXTENT DUM4
M5_real_EXTENT = EXTENT M5_real
M5i_EXTENT = EXTENT M5i
DUM5_EXTENT = EXTENT DUM5
M6_real_EXTENT = EXTENT M6_real
M6i_EXTENT = EXTENT M6i
DUM6_EXTENT = EXTENT DUM6
M7_real_EXTENT = EXTENT M7_real
M7i_EXTENT = EXTENT M7i
DUM7_EXTENT = EXTENT DUM7
M8_real_EXTENT = EXTENT M8_real
M8i_EXTENT = EXTENT M8i
DUM8_EXTENT = EXTENT DUM8
M9_real_EXTENT = EXTENT M9_real
M9i_EXTENT = EXTENT M9i
DUM9_EXTENT = EXTENT DUM9
MD_real_EXTENT = EXTENT MD_real
MDi_EXTENT = EXTENT MDi
DUMD_EXTENT = EXTENT DUMD
VIA1i_EXTENT = EXTENT VIA1i
VIA2i_EXTENT = EXTENT VIA2i
VIA3i_EXTENT = EXTENT VIA3i
VIA4i_EXTENT = EXTENT VIA4i
VIA5i_EXTENT = EXTENT VIA5i
VIA6i_EXTENT = EXTENT VIA6i
VIA7i_EXTENT = EXTENT VIA7i
VIA8i_EXTENT = EXTENT VIA8i
VIADi_EXTENT = EXTENT VIADi
ODi_EXTENT = EXTENT ODi
ODi_RFDRAIN_EXTENT = EXTENT ODi_RFDRAIN
DOD_EXTENT = EXTENT DOD
POi_EXTENT = EXTENT POi
DPO_EXTENT = EXTENT DPO
PSPOi_EXTENT = EXTENT PSPOi
RES200_EXTENT = EXTENT RES200
ESDIMP_EXTENT = EXTENT ESDIMP
M1_PIN_EXTENT = EXTENT M1_PIN
M1_PIN_TEXT_EXTENT = EXTENT M1_PIN_TEXT
M2_PIN_EXTENT = EXTENT M2_PIN
M2_PIN_TEXT_EXTENT = EXTENT M2_PIN_TEXT
M3_PIN_EXTENT = EXTENT M3_PIN
M3_PIN_TEXT_EXTENT = EXTENT M3_PIN_TEXT
M4_PIN_EXTENT = EXTENT M4_PIN
M4_PIN_TEXT_EXTENT = EXTENT M4_PIN_TEXT
M5_PIN_EXTENT = EXTENT M5_PIN
M5_PIN_TEXT_EXTENT = EXTENT M5_PIN_TEXT
M6_PIN_EXTENT = EXTENT M6_PIN
M6_PIN_TEXT_EXTENT = EXTENT M6_PIN_TEXT
M7_PIN_EXTENT = EXTENT M7_PIN
M7_PIN_TEXT_EXTENT = EXTENT M7_PIN_TEXT
M8_PIN_EXTENT = EXTENT M8_PIN
M8_PIN_TEXT_EXTENT = EXTENT M8_PIN_TEXT
M9_PIN_EXTENT = EXTENT M9_PIN
M9_PIN_TEXT_EXTENT = EXTENT M9_PIN_TEXT
MD_PIN_EXTENT = EXTENT MD_PIN
MD_PIN_TEXT_EXTENT = EXTENT MD_PIN_TEXT
AP_PIN_EXTENT = EXTENT AP_PIN
AP_PIN_TEXT_EXTENT = EXTENT AP_PIN_TEXT

 MT_LAYERS =  ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((excludeRRuleRequired_EXTENT OR excludeRRuleRecommended_EXTENT) OR excludeRRuleAnalog_EXTENT) OR excludeRRuleGuideline_EXTENT) OR DNWi_EXTENT) OR NWi_EXTENT) OR OD_18i_EXTENT) OR OD_25i_EXTENT) OR OD_2533_EXTENT) OR OD_33i_EXTENT) OR OD_DECAP_EXTENT) OR PPi_EXTENT) OR NPi_EXTENT) OR COi_EXTENT) OR CBi_EXTENT) OR CB2i_EXTENT) OR RPOi_EXTENT) OR NT_Ni_EXTENT) OR NCap_NTNi_EXTENT) OR FW_APi_EXTENT) OR FW_CUi_EXTENT) OR PMi_EXTENT) OR PM1i_EXTENT) OR PM2i_EXTENT) OR SEALRINGi_EXTENT) OR VTH_Ni_EXTENT) OR VTH_Pi_EXTENT) OR ULVT_Ni_EXTENT) OR ULVT_Pi_EXTENT) OR VTL_Ni_EXTENT) OR VTL_Pi_EXTENT) OR CBDi_EXTENT) OR UBMi_EXTENT) OR VTUH_Ni_EXTENT) OR VTUH_Pi_EXTENT) OR RH_EXTENT) OR ESD3_EXTENT) OR VARi_EXTENT) OR APi_EXTENT) OR Cu_PPIi_EXTENT) OR RVi_EXTENT) OR SANi_EXTENT) OR CBMi_EXTENT) OR CTMi_EXTENT) OR SRM_EXTENT) OR LMARK_EXTENT) OR MATCHING_EXTENT) OR M1_real_EXTENT) OR M1i_EXTENT) OR DUM1_EXTENT) OR M2_real_EXTENT) OR M2i_EXTENT) OR DUM2_EXTENT) OR M3_real_EXTENT) OR M3i_EXTENT) OR DUM3_EXTENT) OR M4_real_EXTENT) OR M4i_EXTENT) OR DUM4_EXTENT) OR M5_real_EXTENT) OR M5i_EXTENT) OR DUM5_EXTENT) OR M6_real_EXTENT) OR M6i_EXTENT) OR DUM6_EXTENT) OR M7_real_EXTENT) OR M7i_EXTENT) OR DUM7_EXTENT) OR M8_real_EXTENT) OR M8i_EXTENT) OR DUM8_EXTENT) OR M9_real_EXTENT) OR M9i_EXTENT) OR DUM9_EXTENT) OR MD_real_EXTENT) OR MDi_EXTENT) OR DUMD_EXTENT) OR VIA1i_EXTENT) OR VIA2i_EXTENT) OR VIA3i_EXTENT) OR VIA4i_EXTENT) OR VIA5i_EXTENT) OR VIA6i_EXTENT) OR VIA7i_EXTENT) OR VIA8i_EXTENT) OR VIADi_EXTENT) OR ODi_EXTENT) OR ODi_RFDRAIN_EXTENT) OR DOD_EXTENT) OR POi_EXTENT) OR DPO_EXTENT) OR PSPOi_EXTENT) OR RES200_EXTENT) OR ESDIMP_EXTENT) OR M1_PIN_EXTENT) OR M1_PIN_TEXT_EXTENT) OR M2_PIN_EXTENT) OR M2_PIN_TEXT_EXTENT) OR M3_PIN_EXTENT) OR M3_PIN_TEXT_EXTENT) OR M4_PIN_EXTENT) OR M4_PIN_TEXT_EXTENT) OR M5_PIN_EXTENT) OR M5_PIN_TEXT_EXTENT) OR M6_PIN_EXTENT) OR M6_PIN_TEXT_EXTENT) OR M7_PIN_EXTENT) OR M7_PIN_TEXT_EXTENT) OR M8_PIN_EXTENT) OR M8_PIN_TEXT_EXTENT) OR M9_PIN_EXTENT) OR M9_PIN_TEXT_EXTENT) OR MD_PIN_EXTENT) OR MD_PIN_TEXT_EXTENT) OR AP_PIN_EXTENT) OR AP_PIN_TEXT_EXTENT

#IFDEF EXCLUDE_SRM_ALSO
SRAM_EXCLUDE = SRM OR SRAMDMY
#ELSE
SRAM_EXCLUDE = COPY SRAMDMY
#ENDIF


// GLOBAL DERIVED LAYERS FOR RULE CHECKS
//--------------------------------------

CHIP         = EXTENT MT_LAYERS
CHIPx	     = MERGE CHIP
//CHIP       = EXTENT CELL "*" ORIGINAL 
BULK         = SIZE CHIP BY 1.0
EMPTYi       = CHIP NOT BULK // for DRC coding
PWELi        = BULK NOT NWi
PWEL         = PWELi NOT SRAM_EXCLUDE

// EXCLUDE UNCHECKED REGIONS
//--------------------------

DNW     = DNWi    NOT INSIDE SRAM_EXCLUDE
NWEL    = NWi     NOT INSIDE SRAM_EXCLUDE
OD      = ODi     NOT SRAM_EXCLUDE
ODs     = ODi     NOT INSIDE SRAM_EXCLUDE
OD_18   = OD_18i  NOT SRAM_EXCLUDE
OD_25   = OD_25i  NOT SRAM_EXCLUDE
OD_33   = OD_33i  NOT SRAM_EXCLUDE
POLY    = POi     NOT SRAM_EXCLUDE
POLYs   = POi     NOT INSIDE SRAM_EXCLUDE
PP      = PPi     NOT INSIDE SRAM_EXCLUDE
NP      = NPi     NOT INSIDE SRAM_EXCLUDE
VTHN    = VTH_Ni  NOT SRAM_EXCLUDE
VTHNs   = VTH_Ni  NOT INSIDE SRAM_EXCLUDE
VTHP    = VTH_Pi  NOT SRAM_EXCLUDE
VTHPs   = VTH_Pi  NOT INSIDE SRAM_EXCLUDE
VTLN    = VTL_Ni  NOT SRAM_EXCLUDE
VTLNs   = VTL_Ni  NOT INSIDE SRAM_EXCLUDE
VTLP    = VTL_Pi  NOT SRAM_EXCLUDE
VTLPs   = VTL_Pi  NOT INSIDE SRAM_EXCLUDE
ULVT_N  = ULVT_Ni NOT SRAM_EXCLUDE
ULVT_Ns = ULVT_Ni NOT INSIDE SRAM_EXCLUDE
ULVT_P	= ULVT_Pi NOT SRAM_EXCLUDE
ULVT_Ps = ULVT_Pi NOT INSIDE SRAM_EXCLUDE
RPO     = RPOi    NOT SRAM_EXCLUDE
RPOs    = RPOi    NOT INSIDE SRAM_EXCLUDE
NTN     = NT_Ni   NOT SRAM_EXCLUDE
NCap_NTN  = NCap_NTNi NOT SRAM_EXCLUDE 
CO      = COi     NOT SRAM_EXCLUDE
COs     = COi     NOT INSIDE SRAM_EXCLUDE
M1      = M1i     NOT SRAM_EXCLUDE
M1s     = M1i     NOT INSIDE SRAM_EXCLUDE
VIA1    = VIA1i   NOT SRAM_EXCLUDE
VIA1s   = VIA1i   NOT INSIDE SRAM_EXCLUDE
M2   = COPY M2i
VIA2 = COPY VIA2i
M3   = COPY M3i
VIA3 = COPY VIA3i
M4   = COPY M4i
VIA4 = COPY VIA4i
M5   = COPY M5i
VIA5 = COPY VIA5i
M6   = COPY M6i
VIA6 = COPY VIA6i
M7   = COPY M7i
VIA7 = COPY VIA7i
M8   = COPY M8i
VIA8 = COPY VIA8i
M9   = COPY M9i
VIAD = COPY VIADi
MD   = COPY MDi

AP      = COPY APi
CB      = COPY CBi
CB2     = COPY CB2i
CBD     = COPY CBDi
UBM     = COPY UBMi
RV      = COPY RVi
FW      = COPY FWi
FW_AP   = COPY FW_APi
FW_CU   = COPY FW_CUi
PM      = COPY PMi
SAN	= COPY SANi
CBM	= COPY CBMi
CTM	= COPY CTMi
VAR	= COPY VARi


ALL_PAD  = (CBi OR CBDi) OR RVi
LMARK_MD = LMARK INTERACT MDi     // LMARK for Cu-RDL
LMARK_MT = LMARK NOT INTERACT MDi // LMARK for non-RDL & Al-RDL

LMARK_METAL = (M9i AND LMARK_MT) OR (MDi AND LMARK) // might be slot or solid
LSLOT = HOLES LMARK_METAL EMPTY  // L shaped oxide in L-mark metal in corner or pad
LSOLID = LMARK_METAL NOT INTERACT LSLOT // L solid metal

LMARK_SLOT  = LMARK INTERACT LSLOT 
LMARK_SOLID = LMARK INTERACT LSOLID

UBM_MT = (UBMi NOT INTERACT MDi) INTERACT CBDi
UBM_EXC = SIZE UBM_MT BY 5 INSIDE OF M9i STEP 0.32
CBMT = SIZE CBi BY 5 INSIDE OF M9i STEP 0.32
MTOP_EXC = CBMT OR UBM_EXC	// For 'top metal' high density limit and max. width rule
CB_NON_CUP = CB NOT INTERACT WBDMY // non-cup pad

CBM8 = SIZE CBi BY 5 INSIDE OF M8i STEP 0.32
#IFDEF CU_WIRE
M8_MAX_WIDTH = M8 NOT CBMT  
#ELSE
M8_MAX_WIDTH = M8 NOT WBDMY
#ENDIF
M9_MAX_WIDTH = (M9 NOT MTOP_EXC) NOT LMARK_MT 
MD_HI_EXC = SIZE UBMi BY 5 INSIDE OF MDi STEP 0.32
MD_MAX_WIDTH = (MD NOT MD_HI_EXC) NOT LMARK

FC_NOT   = MDx OR CB2i
PAD_EXD  = UBMi NOT INTERACT FC_NOT    		// for ground-up 

OD2533 = OD_25 OR OD_33
OD2 = OD_18 OR OD2533

IMP          = NP OR PP
NPOD         = OD AND NP
PPOD         = OD AND PP
COOD         = CO AND OD        // Diffusion contacts 
COPO         = CO NOT OD        // POLY contacts + floating contacts

RNWEL = NWEL INTERACT NWDMY	// NWEL resistor (Within OD & STI)

NWRES = RNWEL INTERACT RPO	// NWEL resistor (Within OD)
NONWR = NWEL NOT RNWEL		// NWEL exclude resistor area (Within OD)
ODWR  = OD INTERACT NWRES	// OD area of NW resistor (Within OD)
NPWR  = NP INTERACT NWRES	// N+ implant on NW resistor terminals (Within OD)
COWR  = COOD INTERACT NWRES	// Contact on NW resistor terminals (Within OD)
RHWR  = ODWR NOT RPO		// Silicided terminal of NW resistor (Within OD)

NWRES_STI = RNWEL NOT INTERACT RPO	// NWEL resistor (Under STI)
ODWR_STI = OD INTERACT NWRES_STI	// OD area of NW resistor (Under STI)
NPWR_STI = NP INTERACT NWRES_STI
COWR_STI = COOD INTERACT NWRES_STI	// Contact on NW resistor terminals (Under STI)

NSTP         = NPOD AND NONWR          // NWEL tap diffusion OR VARACTOR
NACT         = NPOD NOT NWEL           // NMOS device active diffusion
PACT         = PPOD AND NWEL           // PMOS device active diffusion
NACT2        = NACT INTERACT OD2
PACT2        = PACT INTERACT OD2
PSTP         = PPOD NOT NWEL           // Substrate (pwell) tap diffusion
DACT         = NACT OR PACT            // NMOS/PMOS device active diffusion
DSTP         = NSTP OR PSTP

GATE         = POLY AND OD	       // Gate regions for NMOS and PMOS
SD           = (DACT ENCLOSE GATE) NOT GATE  // Source, drain areas
FPO1         = POLY NOT OD             // Field poly
HV_GATE      = GATE AND OD2
LV_GATE      = GATE NOT OD2

GATE_NP      = GATE AND NP
GATE_PP      = GATE AND PP

GATE_W       = POLY COIN INSIDE EDGE GATE      // Gate width
GATE_L       = GATE NOT COIN INSIDE EDGE POLY  // Coincident edge of interconnect POLY

GATEN_W      = GATE_W INSIDE EDGE NP
GATEP_W      = GATE_W INSIDE EDGE PP

HV_GATE_W    = GATE_W INSIDE EDGE OD2         // 2.5V/3.3V/1.8V MOS gates
LV_GATE_W    = GATE_W NOT INSIDE EDGE OD2     // 1.0V MOS gates

// For poly and od resistors identify

RPDMYi        = RPDMY NOT INTERACT RPOi	  
RPO_RPDMY     = RPOi OR RPDMYi
ILP1          = POLY NOT RPO_RPDMY      // Interconnect poly
ODPO_RES_MARK = ((RPO NOT SDI) NOT BJTDMY) OUTSIDE INDDMY  // For unsilicided OD/poly resistors
PORES	      = FPO1 AND ODPO_RES_MARK  // POLY unsilicided resistor region
PORESg = PORES NOT INTERACT SDI
INOD          = OD NOT RPO_RPDMY
FOD           = (OD OUTSIDE NWDMY) NOT GATE  // field OD
ODRES         = FOD AND ODPO_RES_MARK	// OD unsilicided resistor region
AYRE          = ODRES OR PORES		// unsilicided OD/poly resitors
NYRE          = NP AND AYRE
PYRE          = PP AND AYRE

NP_PP_BTE     = NPOD COIN OUTSIDE EDGE PPOD
BUTT_PSTP     = PSTP TOUCH NACT
BUTT_NSTP     = NSTP TOUCH PACT
BUTT_OD       = BUTT_PSTP OR BUTT_NSTP

RNGX     = PMDMY NOT FW
SEALRING = SEALRINGi NOT RNGX
VIA_EXD  = COPY SEALRINGi
VIA1_EXD = VIA1 NOT VIA_EXD
VIA2_EXD = VIA2 NOT VIA_EXD
VIA3_EXD = VIA3 NOT VIA_EXD
VIA4_EXD = VIA4 NOT VIA_EXD
VIA5_EXD = VIA5 NOT VIA_EXD
VIA6_EXD = VIA6 NOT VIA_EXD
VIA7_EXD = VIA7 NOT VIA_EXD
VIA8_EXD = VIA8 NOT VIA_EXD
VIAD_EXD = VIAD NOT VIA_EXD

//For chip corner stress relief check
#IFDEF FULL_CHIP
  CHIP_CORE    = SIZE CHIPx BY -20
#ELSE
  CHIP_CORE    = COPY CHIP
#ENDIF

PADH = HOLES (ALL_PAD NOT CHIP_CORE)
SCORE = CHIP_CORE INSIDE PADH
CHIP_WISR = CHIPx INTERACT SCORE
SR_EDGE = CHIP_WISR NOT SCORE
CHIP_NOSR = CHIP NOT INTERACT SR_EDGE
CHIP_EDGE = CHIP_NOSR OR SCORE
  SR_RING = CHIP_WISR NOT ( SIZE (CHIP_WISR NOT SRCSR) BY 10) 

#IFDEF BigSealringCorner
  CHIP_US = SIZE CHIP_NOSR BY -157
  CHIP_EXP = EXPAND EDGE CHIP_US OUTSIDE BY 157
  CHIP_NO_CORNER = CHIP_US OR CHIP_EXP
  CHIP_CORNER = CHIP_NOSR NOT CHIP_NO_CORNER
  CORNER_TRI = EXT CHIP_NO_CORNER < 72 ABUT == 90 REGION INTERSECTING ONLY
  // without seal-ring
  EMPTY_AREA = ( CHIP_CORNER NOT CORNER_TRI ) AND CHIP_NOSR
  // with seal-ring
  CHIP_WISR_CORE = SIZE ((SIZE CHIP_WISR BY -20) NOT CSRDMY) BY 15 UNDEROVER  
  SRCSR = CHIP_WISR NOT CHIP_WISR_CORE // sealring+corner+assembly isolation
#ELSE
  #IFDEF SmallSealringCorner
  // without seal-ring
    EMPTY_AREA = INT CHIP_NOSR < 157 ABUT == 90 REGION INTERSECTING ONLY
// with seal-ring
    CHIP_WISR_CORE = SIZE ((SIZE CHIP_WISR BY -20) NOT CSRDMY) BY 15 UNDEROVER  
    SRCSR = CHIP_WISR NOT CHIP_WISR_CORE // sealring+corner+assembly isolation
  #ELSE
    #IFDEF LmarkSealringCorner
// without seal-ring
      EMPTY_AREA = INT CHIP_NOSR < 70.5 ABUT == 90 REGION INTERSECTING ONLY
      // with seal-ring
      SR_EXC = EXT SR_EDGE < 70.36 ABUT == 90 REGION INTERSECTING ONLY
      SRCSR  = SR_EDGE OR SR_EXC // sealring+corner+assembly isolation
    #ELSE  // not specify seal-ring structure, use BigSealringCorner
      CHIP_US = SIZE CHIP_NOSR BY -157
      CHIP_EXP = EXPAND EDGE CHIP_US OUTSIDE BY 157
      CHIP_NO_CORNER = CHIP_US OR CHIP_EXP
      CHIP_CORNER = CHIP_NOSR NOT CHIP_NO_CORNER
      CORNER_TRI = EXT CHIP_NO_CORNER < 72 ABUT == 90 REGION INTERSECTING ONLY
      // without seal-ring
      EMPTY_AREA = ( CHIP_CORNER NOT CORNER_TRI ) AND CHIP_NOSR
      // with seal-ring
      CHIP_WISR_CORE = SIZE((SIZE CHIP_WISR BY -20) NOT CSRDMY) BY 15 UNDEROVER  
      SRCSR = CHIP_WISR NOT CHIP_WISR_CORE // sealring+corner+assembly isolation
    #ENDIF
  #ENDIF
#ENDIF

CHIP_CHAMFERED = CHIP NOT EMPTY_AREA
CB_EXCL	 = SIZE CB BY 2
#IFDEF FULL_CHIP
  OD_DEN_EXC_L1    = ((((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY) OR EMPTY_AREA // exclude check
  OD_DEN_EXC_L2    = OD_DEN_EXC_L1 OR SRCSR // excluded region
  OD_DEN_EXC_H     = SRCSR OR EMPTY_AREA
  PO_DEN_EXC       = ((ODBLK OR POBLK) OR CB_EXCL) OR OD_DEN_EXC_L1 // SRCSR is included to check
  INDDMY_EXCL	 = SIZE INDDMY BY 18	// Waive the region nearby inddmy
  METAL_DEN_EXC = (((FWi OR LMARK) OR LOGO) OR INDDMY) OR EMPTY_AREA
  METAL_DEN_EXC_L1 = (((FWi OR LMARK) OR LOGO) OR INDDMY_EXCL) OR EMPTY_AREA // exclude check
  METAL_DEN_EXC_L2 = METAL_DEN_EXC_L1 OR SRCSR // excluded region
  METAL_DEN_EXC_H  = SRCSR OR EMPTY_AREA
#ELSE
  OD_DEN_EXC_L1    = (((NWDMY OR FWi) OR LMARK) OR LOGO) OR INDDMY
  OD_DEN_EXC_L2    = COPY OD_DEN_EXC_L1
  OD_DEN_EXC_H     = CDUDMY NOT CHIP // EMPTY
  PO_DEN_EXC       = ((ODBLK OR POBLK) OR CB_EXCL) OR OD_DEN_EXC_L1
  INDDMY_EXCL	 = SIZE INDDMY BY 18    // Waive the region nearby inddmy
  METAL_DEN_EXC = ((FWi OR LMARK) OR LOGO) OR INDDMY
  METAL_DEN_EXC_L1 = ((FWi OR LMARK) OR LOGO) OR INDDMY_EXCL
  METAL_DEN_EXC_L2 = COPY METAL_DEN_EXC_L1
  METAL_DEN_EXC_H  = CDUDMY NOT CHIP // EMPTY
#ENDIF

M1_EXC_L1 = COPY METAL_DEN_EXC_L1
M1_EXC_L2 = COPY METAL_DEN_EXC_L2
M1_EXC_H  = COPY METAL_DEN_EXC_H
M2_EXC_L1 = COPY METAL_DEN_EXC_L1
M2_EXC_L2 = COPY METAL_DEN_EXC_L2
M2_EXC_H  = COPY METAL_DEN_EXC_H
M3_EXC_L1 = COPY METAL_DEN_EXC_L1
M3_EXC_L2 = COPY METAL_DEN_EXC_L2
M3_EXC_H  = COPY METAL_DEN_EXC_H
M4_EXC_L1 = COPY METAL_DEN_EXC_L1
M4_EXC_L2 = COPY METAL_DEN_EXC_L2
M4_EXC_H  = COPY METAL_DEN_EXC_H
M5_EXC_L1 = COPY METAL_DEN_EXC_L1
M5_EXC_L2 = COPY METAL_DEN_EXC_L2
M5_EXC_H  = COPY METAL_DEN_EXC_H
M6_EXC_L1 = COPY METAL_DEN_EXC_L1
M6_EXC_L2 = COPY METAL_DEN_EXC_L2
M6_EXC_H  = COPY METAL_DEN_EXC_H

M7_EXC_L1 = METAL_DEN_EXC_L1 OR (SIZE CBMi BY 1.5)
M7_EXC_L2 = METAL_DEN_EXC_L2 OR (SIZE CBMi BY 1.5)
M7_EXC_H = COPY METAL_DEN_EXC_H
M8_EXC_L1 = COPY METAL_DEN_EXC_L1
M8_EXC_L2 = COPY METAL_DEN_EXC_L2
M8_EXC_H = (METAL_DEN_EXC_H OR WBDMY) OR LMARK
// top metal
M9_EXC_L1 = COPY METAL_DEN_EXC_L1
M9_EXC_L2 = COPY METAL_DEN_EXC_L2
M9_EXC_H = (METAL_DEN_EXC_H OR MTOP_EXC) OR LMARK
// Cu-RDL
MD_EXC_L1 = COPY METAL_DEN_EXC_L1
MD_EXC_L2 = COPY METAL_DEN_EXC_L2
MD_EXC_H = (METAL_DEN_EXC_H OR MD_HI_EXC) OR LMARK

#IFDEF LmarkSealringCorner
  SR_M1 = (M1 INTERACT SEALRING) NOT ((M1 AND CSRDMY) NOT SEALRING)
#ELSE
  SR_M1 = M1 INTERACT SEALRING
#ENDIF

  SR_M2 = M2 INTERACT SEALRING

  SR_M3 = M3 INTERACT SEALRING

  SR_M4 = M4 INTERACT SEALRING

  SR_M5 = M5 INTERACT SEALRING

  SR_M6 = M6 INTERACT SEALRING

  SR_M7 = M7 INTERACT SEALRING

  SR_M8 = M8 INTERACT SEALRING

  SR_M9 = M9 INTERACT SEALRING

  SR_MD = MD INTERACT SEALRING

SR_CO = CO INTERACT SR_M1 
SR_VIA1 = VIA1 INTERACT SEALRING 
SR_VIA2 = VIA2 INTERACT SEALRING 
SR_VIA3 = VIA3 INTERACT SEALRING 
SR_VIA4 = VIA4 INTERACT SEALRING 
SR_VIA5 = VIA5 INTERACT SEALRING 
SR_VIA6 = VIA6 INTERACT SEALRING 
SR_VIA7 = VIA7 INTERACT SEALRING 
SR_VIA8 = VIA8 INTERACT SEALRING 
SR_VIAD = VIAD INTERACT SEALRING 


// 45 degree metal edge
M1_EDGE_45 = M1 ANGLE == 45
M2_EDGE_45 = M2 ANGLE == 45
M3_EDGE_45 = M3 ANGLE == 45
M4_EDGE_45 = M4 ANGLE == 45
M5_EDGE_45 = M5 ANGLE == 45
M6_EDGE_45 = M6 ANGLE == 45
M7_EDGE_45 = M7 ANGLE == 45
M8_EDGE_45 = M8 ANGLE == 45
M9_EDGE_45 = M9 ANGLE == 45
MD_EDGE_45 = MD ANGLE == 45

// Nodal NWEL connectivity checks
ILP1i = POi NOT RPO_RPDMY	// Interconnect poly
NONWRi = NWi NOT INTERACT NWDMY 
NWRiT = (NWi INTERACT NWDMY) NOT NWDMY  //NWR terminal
RWi = PWELi INSIDE DNWi

NPODi = NPi AND ODi
PPODi = PPi AND ODi
NACTi = NPODi NOT NWi
PACTi = PPODi AND NWi
NSDi  = NACTi NOT POi		// NMOS source/drain
NSDc  = NSDi NOT RPO_RPDMY	// NMOS source/drain for connection
PSDi  = PACTi NOT POi		// PMOS source/drain
PSDc  = PSDi NOT RPO_RPDMY	// PMOS source/drain for connection
NSTPi = NPODi AND NONWRi        // Break the connection at NWR  
PSTPi = PPODi NOT NWi

APn = APi NOT INTERACT MDi
APd = APi INTERACT MDi

SRAMDMY_SRM = SRAMDMY OR SRM
SRAM_CO = CO NOT OUTSIDE SRAMDMY_SRM
SRAM_OD = OD NOT OUTSIDE SRAMDMY_SRM
SRAM_PO = POLY NOT OUTSIDE SRAMDMY_SRM
BTC = (SRAM_CO NOT OUTSIDE SRAM_OD) NOT OUTSIDE SRAM_PO

// For DFM rules

Block = ((((PMDMY OR CSRDMY) OR LOGO) OR SEALRINGi) OR LMARK) OR SRCSR






CONNECT NWEL DNW 	// For DNW.S.2 check only, not for electrical connection.
CONNECT NSTPi NWi                 
CONNECT NSTPi PSDc	// For butted pickup
CONNECT PSTPi RWi	// For DNW connection
CONNECT PSTPi PWELi	// For DNW connection
CONNECT PSTPi NSDc	// For butted pickup
CONNECT PSDc COi        // For butted CO
CONNECT NSDc COi        // For butted CO
CONNECT ILP1i COi       // For butted CO
CONNECT M1i ILP1i NSTPi PSTPi PSDc NSDc NWRiT BY COi


  CONNECT M2i M1i BY VIA1i
  CONNECT M3i M2i BY VIA2i
  CONNECT M4i M3i BY VIA3i
  CONNECT M5i M4i BY VIA4i
  CONNECT M6i M5i BY VIA5i
  CONNECT M7i M6i BY VIA6i
  CONNECT M8i CTMi CBMi M7i BY VIA7i
CONNECT M9i M8i BY VIA8i

CONNECT M9i APn BY RVi
CONNECT M9i APn BY CBi
CONNECT M9i APn BY CBDi
UBMn = UBMi NOT INTERACT Cu_PPIi
UBMd = UBMi INTERACT Cu_PPIi
CONNECT CBi M9i
CONNECT M9i APi  BY RVi
CONNECT M9i APi  BY CBi
CONNECT M9i APi  BY CBDi
CONNECT M9i MDi  BY VIADi
CONNECT CB2i APi
CONNECT MDi APi BY CBDi
CONNECT CB2i PM1i
CONNECT PM1i Cu_PPIi
CONNECT UBMd Cu_PPIi BY PM2i 

CONNECT UBMn APi
CONNECT UBMn M9i BY CBDi

NWu   = COPY NWi
RWu   = COPY RWi
PWELu = COPY PWELi
NWRuT = COPY NWRiT
POu   = COPY POi
NSDu  = COPY NSDi
PSDu  = COPY PSDi
NSTPu = NPODi AND NWi
PSTPu = COPY PSTPi
COu   = COPY COi
M1u   = COPY M1i
VIA1u = COPY VIA1i
M2u   = COPY M2i
VIA2u = COPY VIA2i
M3u   = COPY M3i
VIA3u = COPY VIA3i
M4u   = COPY M4i
VIA4u = COPY VIA4i
M5u   = COPY M5i
VIA5u = COPY VIA5i
M6u   = COPY M6i
VIA6u = COPY VIA6i
M7u   = COPY M7i
VIA7u = COPY VIA7i
M8u   = COPY M8i
VIA8u = COPY VIA8i
M9u   = COPY M9i
VIADu  = COPY VIADi
MDu    = COPY MDi
RVu   = COPY RVi
CBu   = COPY CBi
CBDu  = COPY CBDi
CB2u  = COPY CB2i 
APu   = COPY APi
/* UBMu  = COPY UBMi */
UBMnu = COPY UBMn
UBMdu = COPY UBMd
PM1u  = COPY PM1i
PM2u  = COPY PM2i
Cu_PPIu = COPY Cu_PPIi
CTMu = COPY CTMi
CBMu = COPY CBMi


CONNECT NSTPu NWu
CONNECT NSTPu PSDu	// For butted pickup
CONNECT PSTPu RWu	// For DNW connection
CONNECT PSTPu PWELu	// For DNW connection
CONNECT PSTPu NSDu	// For butted pickup
CONNECT POu   COu 	// For butted cont
CONNECT	PSDu  COu	// For butted cont
CONNECT NSDu  COu	// For butted cont
CONNECT M1u   COu
CONNECT M1u NSTPu PSTPu BY COu
CONNECT M1u NWRuT BY COu // Prevent from connection shield
CONNECT M1u POu NSTPu PSTPu PSDu NSDu BY COu

  CONNECT M2u M1u BY VIA1u
  CONNECT M3u M2u BY VIA2u
  CONNECT M4u M3u BY VIA3u
  CONNECT M5u M4u BY VIA4u
  CONNECT M6u M5u BY VIA5u
  CONNECT M7u M6u BY VIA6u
  CONNECT M8u CTMu CBMu M7u BY VIA7u
  CONNECT M9u M8u BY VIA8u

// for WB connection
CONNECT CBu M9u
CONNECT M9u APu  BY RVu
CONNECT M9u APu  BY CBu
CONNECT M9u APu  BY CBDu
CONNECT M9u MDu  BY VIADu
CONNECT CB2u APu
CONNECT MDu APu BY CBDu
CONNECT CB2u PM1u
CONNECT PM1u Cu_PPIu
CONNECT UBMdu Cu_PPIu BY PM2u 

CONNECT UBMnu APu
CONNECT UBMnu M9u BY CBDu
CONNECT UBMdu Cu_PPIu BY PM2u  

OD_RES_200ohm = (OD AND RPDMY) AND RES200  
PO_RES_200ohm = (POLY AND RPDMY) AND RES200
NW_RES_200ohm = (NWi AND NWDMY) AND RES200
NWj   = NWi NOT NW_RES_200ohm
RWj   = EMPTYi OR RWi
PWELj = EMPTYi OR PWELi
POj   = POi NOT PO_RES_200ohm
NSDj  = NSDi NOT OD_RES_200ohm
PSDj  = PSDi NOT OD_RES_200ohm
NSTPj = EMPTYi OR (NPODi AND NWi)
PSTPj = EMPTYi OR PSTPi
COj   = EMPTYi OR COi
M1j   = EMPTYi OR M1i
VIA1j = EMPTYi OR VIA1i
M2j  = EMPTYi OR M2i
VIA2j = EMPTYi OR VIA2i
M3j  = EMPTYi OR M3i
VIA3j = EMPTYi OR VIA3i
M4j  = EMPTYi OR M4i
VIA4j = EMPTYi OR VIA4i
M5j  = EMPTYi OR M5i
VIA5j = EMPTYi OR VIA5i
M6j  = EMPTYi OR M6i
VIA6j = EMPTYi OR VIA6i
M7j  = EMPTYi OR M7i
VIA7j = EMPTYi OR VIA7i
M8j  = EMPTYi OR M8i
VIA8j = EMPTYi OR VIA8i
M9j  = EMPTYi OR M9i
VIADj = EMPTYi OR VIADi
MDj   = EMPTYi OR MDi
RVj   = EMPTYi OR RVi
CBj   = EMPTYi OR CBi
CBDj  = EMPTYi OR CBDi
CB2j  = EMPTYi OR CB2i 
APj   = EMPTYi OR APi
UBMnj = EMPTYi OR UBMn
UBMdj = EMPTYi OR UBMd
PM1j  = EMPTYi OR PM1i
PM2j  = EMPTYi OR PM2i
Cu_PPIj = EMPTYi OR Cu_PPIi
CTMj = EMPTYi OR CTMi
CBMj = EMPTYi OR CBMi

CONNECT NSTPj NWj
CONNECT NSTPj PSDj	// For butted pickup
CONNECT PSTPj RWj	// For DNW connection
CONNECT PSTPj PWELj	// For DNW connection
CONNECT PSTPj NSDj	// For butted pickup
CONNECT POj   COj 	// For butted cont
CONNECT	PSDj  COj	// For butted cont
CONNECT NSDj  COj	// For butted cont
CONNECT M1j   COj
CONNECT M1j NSTPj PSTPj BY COj
CONNECT M1j POj NSTPj PSTPj PSDj NSDj BY COj
  CONNECT M2j M1j BY VIA1j
  CONNECT M3j M2j BY VIA2j
  CONNECT M4j M3j BY VIA3j
  CONNECT M5j M4j BY VIA4j
  CONNECT M6j M5j BY VIA5j
  CONNECT M7j M6j BY VIA6j
  CONNECT M8j CTMj CBMj M7j BY VIA7j
  CONNECT M9j M8j BY VIA8j

CONNECT CBj M9j
CONNECT M9j APj  BY RVj
CONNECT M9j APj  BY CBj
CONNECT M9j APj  BY CBDj
CONNECT M9j MDj  BY VIADj
CONNECT CB2j APj
CONNECT MDj APj BY CBDj
CONNECT CB2j PM1j
CONNECT PM1j Cu_PPIj
CONNECT UBMdj Cu_PPIj BY PM2j
CONNECT UBMnj APj
CONNECT UBMnj M9j BY CBDj
CONNECT UBMdj Cu_PPIj BY PM2j


ASSH = HOLES ((M1i INTERACT SR_EDGE) INTERACT SEALRING) INNER
ASS  = SIZE ASSH BY SR_S_1 UNDEROVER // remove un-wanted hole in corner
CORR = SIZE ASS BY -SR_S_1           // core region 

ISOR = ASS NOT CORR              // assembly isolation region




#IFNDEF DFM_ONLY


#IFDEF N80
G.1:RRuleRequired { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RRuleRequired CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RRuleRecommended { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RRuleRecommended CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RRuleAnalog { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RRuleAnalog CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RRuleGuideline { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RRuleGuideline CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:excludeRRuleRequired { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL excludeRRuleRequired CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:excludeRRuleRecommended { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL excludeRRuleRecommended CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:excludeRRuleAnalog { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL excludeRRuleAnalog CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:excludeRRuleGuideline { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL excludeRRuleGuideline CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RODMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RODMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DNWi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DNWi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:NWi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL NWi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:NWi_OTHERS { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL NWi_OTHERS CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:OD_18i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL OD_18i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:OD_25i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL OD_25i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:OD_2533 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL OD_2533 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:OD_33i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL OD_33i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:OD_DECAP { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL OD_DECAP CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:PPi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL PPi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:NPi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL NPi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:CBi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL CBi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RPOi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RPOi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:NT_Ni { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL NT_Ni CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:NCap_NTNi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL NCap_NTNi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:FW_APi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL FW_APi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:FW_CUi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL FW_CUi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SEALRINGi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SEALRINGi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VTH_Ni { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VTH_Ni CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VTH_Pi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VTH_Pi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ULVT_Ni { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ULVT_Ni CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ULVT_Pi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ULVT_Pi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VTL_Ni { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VTL_Ni CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VTL_Pi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VTL_Pi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RH { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RH CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ESD3 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ESD3 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VARi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VARi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:APi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL APi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RVi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RVi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SANi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SANi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:CBMi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL CBMi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:CTMi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL CTMi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SRM { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SRM CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:LMARK { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL LMARK CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:BJTDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL BJTDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DIODMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DIODMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:NWDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL NWDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RPDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RPDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DPDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DPDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:PLDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL PLDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SDI { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SDI CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:PMDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL PMDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ESD1DMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ESD1DMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ESD2DMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ESD2DMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:CDUDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL CDUDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:CSRDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL CSRDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:LOGO { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL LOGO CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:INDDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL INDDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:CTMDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL CTMDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:WBDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL WBDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:LUPWDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL LUPWDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VDDDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VDDDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VSSDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VSSDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_1 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_1 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_2 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_2 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_3 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_3 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_4 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_4 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_5 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_5 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_6 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_6 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_7 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_7 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_8 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_8 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_9 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_9 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MOMDMY_AP { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MOMDMY_AP CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RTMOMDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RTMOMDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RFDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RFDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SRAMDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SRAMDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SRAMDMY_PERI { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SRAMDMY_PERI CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SRAMDMY6_PERI { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SRAMDMY6_PERI CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:SBDDMY { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL SBDDMY CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MATCHING { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MATCHING CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M1_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M1_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M1i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M1i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM1 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM1 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM1_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM1_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M2_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M2_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M2i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M2i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM2 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM2 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM2_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM2_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M3_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M3_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M3i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M3i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM3 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM3 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM3_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM3_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M4_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M4_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M4i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M4i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM4 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM4 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM4_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM4_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M5_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M5_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M5i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M5i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM5 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM5 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM5_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM5_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M6_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M6_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M6i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M6i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM6 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM6 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM6_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM6_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M7_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M7_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M7i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M7i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM7 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM7 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM7_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM7_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M8_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M8_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M8i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M8i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM8 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM8 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM8_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM8_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M9_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M9_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M9i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M9i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM9 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM9 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUM9_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUM9_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MD_real { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MD_real CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MDi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MDi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUMD { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUMD CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DUMD_O { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DUMD_O CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM1EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM1EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM2EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM2EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM3EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM3EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM4EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM4EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM5EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM5EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM6EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM6EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM7EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM7EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM8EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM8EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DM9EXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DM9EXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DMDEXCL { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DMDEXCL CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA1i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA1i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA2i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA2i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA3i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA3i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA4i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA4i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA5i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA5i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA6i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA6i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA7i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA7i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIA8i { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIA8i CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:VIADi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL VIADi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ODi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ODi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ODi_OTHERS { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ODi_OTHERS CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ODi_RFDRAIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ODi_RFDRAIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DOD { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DOD CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:DPO { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL DPO CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:PSPOi { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL PSPOi CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ODBLK { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ODBLK CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:POBLK { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL POBLK CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:RES200 { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL RES200 CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:ESDIMP { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL ESDIMP CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M1_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M1_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M1_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M1_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M2_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M2_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M2_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M2_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M3_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M3_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M3_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M3_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M4_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M4_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M4_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M4_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M5_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M5_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M5_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M5_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M6_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M6_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M6_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M6_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M7_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M7_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M7_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M7_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M8_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M8_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M8_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M8_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M9_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M9_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:M9_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL M9_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MD_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MD_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:MD_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL MD_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:AP_PIN { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL AP_PIN CellsFor1nmGrid  
  OFFGRID X 5
}
G.1:AP_PIN_TEXT { @ grid must be an integer multiple of ^GRID um, excluding the cell-list of CellsFor1nmGrid
  X = NOT INSIDE CELL AP_PIN_TEXT CellsFor1nmGrid  
  OFFGRID X 5
}
#ELSE

G.1:RRuleRequired { @ grid must be an integer multiple of ^GRID um
  OFFGRID RRuleRequired 5
}
G.1:RRuleRecommended { @ grid must be an integer multiple of ^GRID um
  OFFGRID RRuleRecommended 5
}
G.1:RRuleAnalog { @ grid must be an integer multiple of ^GRID um
  OFFGRID RRuleAnalog 5
}
G.1:RRuleGuideline { @ grid must be an integer multiple of ^GRID um
  OFFGRID RRuleGuideline 5
}
G.1:excludeRRuleRequired { @ grid must be an integer multiple of ^GRID um
  OFFGRID excludeRRuleRequired 5
}
G.1:excludeRRuleRecommended { @ grid must be an integer multiple of ^GRID um
  OFFGRID excludeRRuleRecommended 5
}
G.1:excludeRRuleAnalog { @ grid must be an integer multiple of ^GRID um
  OFFGRID excludeRRuleAnalog 5
}
G.1:excludeRRuleGuideline { @ grid must be an integer multiple of ^GRID um
  OFFGRID excludeRRuleGuideline 5
}
G.1:RODMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RODMY 5
}
G.1:DNWi { @ grid must be an integer multiple of ^GRID um
  OFFGRID DNWi 5
}
G.1:NWi { @ grid must be an integer multiple of ^GRID um
  OFFGRID NWi 5
}
G.1:NWi_OTHERS { @ grid must be an integer multiple of ^GRID um
  OFFGRID NWi_OTHERS 5
}
G.1:OD_18i { @ grid must be an integer multiple of ^GRID um
  OFFGRID OD_18i 5
}
G.1:OD_25i { @ grid must be an integer multiple of ^GRID um
  OFFGRID OD_25i 5
}
G.1:OD_2533 { @ grid must be an integer multiple of ^GRID um
  OFFGRID OD_2533 5
}
G.1:OD_33i { @ grid must be an integer multiple of ^GRID um
  OFFGRID OD_33i 5
}
G.1:OD_DECAP { @ grid must be an integer multiple of ^GRID um
  OFFGRID OD_DECAP 5
}
G.1:PPi { @ grid must be an integer multiple of ^GRID um
  OFFGRID PPi 5
}
G.1:NPi { @ grid must be an integer multiple of ^GRID um
  OFFGRID NPi 5
}
G.1:CBi { @ grid must be an integer multiple of ^GRID um
  OFFGRID CBi 5
}
G.1:RPOi { @ grid must be an integer multiple of ^GRID um
  OFFGRID RPOi 5
}
G.1:NT_Ni { @ grid must be an integer multiple of ^GRID um
  OFFGRID NT_Ni 5
}
G.1:NCap_NTNi { @ grid must be an integer multiple of ^GRID um
  OFFGRID NCap_NTNi 5
}
G.1:FW_APi { @ grid must be an integer multiple of ^GRID um
  OFFGRID FW_APi 5
}
G.1:FW_CUi { @ grid must be an integer multiple of ^GRID um
  OFFGRID FW_CUi 5
}
G.1:SEALRINGi { @ grid must be an integer multiple of ^GRID um
  OFFGRID SEALRINGi 5
}
G.1:VTH_Ni { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTH_Ni 5
}
G.1:VTH_Pi { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTH_Pi 5
}
G.1:ULVT_Ni { @ grid must be an integer multiple of ^GRID um
  OFFGRID ULVT_Ni 5
}
G.1:ULVT_Pi { @ grid must be an integer multiple of ^GRID um
  OFFGRID ULVT_Pi 5
}
G.1:VTL_Ni { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTL_Ni 5
}
G.1:VTL_Pi { @ grid must be an integer multiple of ^GRID um
  OFFGRID VTL_Pi 5
}
G.1:RH { @ grid must be an integer multiple of ^GRID um
  OFFGRID RH 5
}
G.1:ESD3 { @ grid must be an integer multiple of ^GRID um
  OFFGRID ESD3 5
}
G.1:VARi { @ grid must be an integer multiple of ^GRID um
  OFFGRID VARi 5
}
G.1:APi { @ grid must be an integer multiple of ^GRID um
  OFFGRID APi 5
}
G.1:RVi { @ grid must be an integer multiple of ^GRID um
  OFFGRID RVi 5
}
G.1:SANi { @ grid must be an integer multiple of ^GRID um
  OFFGRID SANi 5
}
G.1:CBMi { @ grid must be an integer multiple of ^GRID um
  OFFGRID CBMi 5
}
G.1:CTMi { @ grid must be an integer multiple of ^GRID um
  OFFGRID CTMi 5
}
G.1:SRM { @ grid must be an integer multiple of ^GRID um
  OFFGRID SRM 5
}
G.1:LMARK { @ grid must be an integer multiple of ^GRID um
  OFFGRID LMARK 5
}
G.1:BJTDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID BJTDMY 5
}
G.1:DIODMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID DIODMY 5
}
G.1:NWDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID NWDMY 5
}
G.1:RPDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RPDMY 5
}
G.1:DPDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID DPDMY 5
}
G.1:PLDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID PLDMY 5
}
G.1:SDI { @ grid must be an integer multiple of ^GRID um
  OFFGRID SDI 5
}
G.1:PMDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID PMDMY 5
}
G.1:ESD1DMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID ESD1DMY 5
}
G.1:ESD2DMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID ESD2DMY 5
}
G.1:CDUDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID CDUDMY 5
}
G.1:CSRDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID CSRDMY 5
}
G.1:LOGO { @ grid must be an integer multiple of ^GRID um
  OFFGRID LOGO 5
}
G.1:INDDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID INDDMY 5
}
G.1:CTMDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID CTMDMY 5
}
G.1:WBDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID WBDMY 5
}
G.1:LUPWDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID LUPWDMY 5
}
G.1:VDDDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID VDDDMY 5
}
G.1:VSSDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID VSSDMY 5
}
G.1:MOMDMY_1 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_1 5
}
G.1:MOMDMY_2 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_2 5
}
G.1:MOMDMY_3 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_3 5
}
G.1:MOMDMY_4 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_4 5
}
G.1:MOMDMY_5 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_5 5
}
G.1:MOMDMY_6 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_6 5
}
G.1:MOMDMY_7 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_7 5
}
G.1:MOMDMY_8 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_8 5
}
G.1:MOMDMY_9 { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_9 5
}
G.1:MOMDMY_AP { @ grid must be an integer multiple of ^GRID um
  OFFGRID MOMDMY_AP 5
}
G.1:RTMOMDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RTMOMDMY 5
}
G.1:RFDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID RFDMY 5
}
G.1:SRAMDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID SRAMDMY 5
}
G.1:SRAMDMY_PERI { @ grid must be an integer multiple of ^GRID um
  OFFGRID SRAMDMY_PERI 5
}
G.1:SRAMDMY6_PERI { @ grid must be an integer multiple of ^GRID um
  OFFGRID SRAMDMY6_PERI 5
}
G.1:SBDDMY { @ grid must be an integer multiple of ^GRID um
  OFFGRID SBDDMY 5
}
G.1:MATCHING { @ grid must be an integer multiple of ^GRID um
  OFFGRID MATCHING 5
}
G.1:M1_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M1_real 5
}
G.1:M1i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M1i 5
}
G.1:DUM1 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM1 5
}
G.1:DUM1_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM1_O 5
}
G.1:M2_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M2_real 5
}
G.1:M2i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M2i 5
}
G.1:DUM2 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM2 5
}
G.1:DUM2_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM2_O 5
}
G.1:M3_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M3_real 5
}
G.1:M3i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M3i 5
}
G.1:DUM3 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM3 5
}
G.1:DUM3_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM3_O 5
}
G.1:M4_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M4_real 5
}
G.1:M4i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M4i 5
}
G.1:DUM4 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM4 5
}
G.1:DUM4_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM4_O 5
}
G.1:M5_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M5_real 5
}
G.1:M5i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M5i 5
}
G.1:DUM5 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM5 5
}
G.1:DUM5_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM5_O 5
}
G.1:M6_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M6_real 5
}
G.1:M6i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M6i 5
}
G.1:DUM6 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM6 5
}
G.1:DUM6_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM6_O 5
}
G.1:M7_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M7_real 5
}
G.1:M7i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M7i 5
}
G.1:DUM7 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM7 5
}
G.1:DUM7_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM7_O 5
}
G.1:M8_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M8_real 5
}
G.1:M8i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M8i 5
}
G.1:DUM8 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM8 5
}
G.1:DUM8_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM8_O 5
}
G.1:M9_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID M9_real 5
}
G.1:M9i { @ grid must be an integer multiple of ^GRID um
  OFFGRID M9i 5
}
G.1:DUM9 { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM9 5
}
G.1:DUM9_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUM9_O 5
}
G.1:MD_real { @ grid must be an integer multiple of ^GRID um
  OFFGRID MD_real 5
}
G.1:MDi { @ grid must be an integer multiple of ^GRID um
  OFFGRID MDi 5
}
G.1:DUMD { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUMD 5
}
G.1:DUMD_O { @ grid must be an integer multiple of ^GRID um
  OFFGRID DUMD_O 5
}
G.1:DM1EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM1EXCL 5
}
G.1:DM2EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM2EXCL 5
}
G.1:DM3EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM3EXCL 5
}
G.1:DM4EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM4EXCL 5
}
G.1:DM5EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM5EXCL 5
}
G.1:DM6EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM6EXCL 5
}
G.1:DM7EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM7EXCL 5
}
G.1:DM8EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM8EXCL 5
}
G.1:DM9EXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DM9EXCL 5
}
G.1:DMDEXCL { @ grid must be an integer multiple of ^GRID um
  OFFGRID DMDEXCL 5
}
G.1:VIA1i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA1i 5
}
G.1:VIA2i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA2i 5
}
G.1:VIA3i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA3i 5
}
G.1:VIA4i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA4i 5
}
G.1:VIA5i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA5i 5
}
G.1:VIA6i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA6i 5
}
G.1:VIA7i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA7i 5
}
G.1:VIA8i { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIA8i 5
}
G.1:VIADi { @ grid must be an integer multiple of ^GRID um
  OFFGRID VIADi 5
}
G.1:ODi { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODi 5
}
G.1:ODi_OTHERS { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODi_OTHERS 5
}
G.1:ODi_RFDRAIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODi_RFDRAIN 5
}
G.1:DOD { @ grid must be an integer multiple of ^GRID um
  OFFGRID DOD 5
}
G.1:DPO { @ grid must be an integer multiple of ^GRID um
  OFFGRID DPO 5
}
G.1:PSPOi { @ grid must be an integer multiple of ^GRID um
  OFFGRID PSPOi 5
}
G.1:ODBLK { @ grid must be an integer multiple of ^GRID um
  OFFGRID ODBLK 5
}
G.1:POBLK { @ grid must be an integer multiple of ^GRID um
  OFFGRID POBLK 5
}
G.1:RES200 { @ grid must be an integer multiple of ^GRID um
  OFFGRID RES200 5
}
G.1:ESDIMP { @ grid must be an integer multiple of ^GRID um
  OFFGRID ESDIMP 5
}
G.1:M1_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M1_PIN 5
}
G.1:M1_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M1_PIN_TEXT 5
}
G.1:M2_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M2_PIN 5
}
G.1:M2_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M2_PIN_TEXT 5
}
G.1:M3_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M3_PIN 5
}
G.1:M3_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M3_PIN_TEXT 5
}
G.1:M4_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M4_PIN 5
}
G.1:M4_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M4_PIN_TEXT 5
}
G.1:M5_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M5_PIN 5
}
G.1:M5_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M5_PIN_TEXT 5
}
G.1:M6_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M6_PIN 5
}
G.1:M6_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M6_PIN_TEXT 5
}
G.1:M7_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M7_PIN 5
}
G.1:M7_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M7_PIN_TEXT 5
}
G.1:M8_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M8_PIN 5
}
G.1:M8_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M8_PIN_TEXT 5
}
G.1:M9_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID M9_PIN 5
}
G.1:M9_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID M9_PIN_TEXT 5
}
G.1:MD_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID MD_PIN 5
}
G.1:MD_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID MD_PIN_TEXT 5
}
G.1:AP_PIN { @ grid must be an integer multiple of ^GRID um
  OFFGRID AP_PIN 5
}
G.1:AP_PIN_TEXT { @ grid must be an integer multiple of ^GRID um
  OFFGRID AP_PIN_TEXT 5
}
#ENDIF
#IFDEF N80
G.1:CO { @ 1nm grid is required for CO outside SRAM periphrial regions
  X = NOT INSIDE CELL COi CellsFor1nmGrid
  Y = X NOT SRAMDMY_PERI
  OFFGRID Y 5	
}
G.1:PO { @ 1nm grid is required for PO outside SRAM periphrial regions
  X = NOT INSIDE CELL POi CellsFor1nmGrid
  Y = X NOT SRAMDMY_PERI
  OFFGRID Y 5	
}
#ELSE

G.1:CO { @ 5nm grid is required for CO outside SRAM periphrial regions
  X = COi NOT SRAMDMY_PERI
  OFFGRID X 5	
}
G.1:PO { @ 5nm grid is required for PO outside SRAM periphrial regions
  X = POi NOT SRAMDMY_PERI
  OFFGRID X 5	
}
#ENDIF

G.2:RRuleRequired { @ RRuleRequired Shapes with acute angles between line segments are not allowed.
  INT RRuleRequired < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RRuleRequired < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RRuleRecommended { @ RRuleRecommended Shapes with acute angles between line segments are not allowed.
  INT RRuleRecommended < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RRuleRecommended < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RRuleAnalog { @ RRuleAnalog Shapes with acute angles between line segments are not allowed.
  INT RRuleAnalog < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RRuleAnalog < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RRuleGuideline { @ RRuleGuideline Shapes with acute angles between line segments are not allowed.
  INT RRuleGuideline < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RRuleGuideline < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:excludeRRuleRequired { @ excludeRRuleRequired Shapes with acute angles between line segments are not allowed.
  INT excludeRRuleRequired < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT excludeRRuleRequired < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:excludeRRuleRecommended { @ excludeRRuleRecommended Shapes with acute angles between line segments are not allowed.
  INT excludeRRuleRecommended < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT excludeRRuleRecommended < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:excludeRRuleAnalog { @ excludeRRuleAnalog Shapes with acute angles between line segments are not allowed.
  INT excludeRRuleAnalog < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT excludeRRuleAnalog < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:excludeRRuleGuideline { @ excludeRRuleGuideline Shapes with acute angles between line segments are not allowed.
  INT excludeRRuleGuideline < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT excludeRRuleGuideline < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RODMY { @ RODMY Shapes with acute angles between line segments are not allowed.
  INT RODMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RODMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DNWi { @ DNWi Shapes with acute angles between line segments are not allowed.
  INT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DNWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NWi { @ NWi Shapes with acute angles between line segments are not allowed.
  INT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NWi_OTHERS { @ NWi_OTHERS Shapes with acute angles between line segments are not allowed.
  INT NWi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD_18i { @ OD_18i Shapes with acute angles between line segments are not allowed.
  INT OD_18i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_18i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD_25i { @ OD_25i Shapes with acute angles between line segments are not allowed.
  INT OD_25i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_25i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD_2533 { @ OD_2533 Shapes with acute angles between line segments are not allowed.
  INT OD_2533 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_2533 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD_33i { @ OD_33i Shapes with acute angles between line segments are not allowed.
  INT OD_33i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_33i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:OD_DECAP { @ OD_DECAP Shapes with acute angles between line segments are not allowed.
  INT OD_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT OD_DECAP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PPi { @ PPi Shapes with acute angles between line segments are not allowed.
  INT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NPi { @ NPi Shapes with acute angles between line segments are not allowed.
  INT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NPi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:COi { @ COi Shapes with acute angles between line segments are not allowed.
  INT COi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT COi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CBi { @ CBi Shapes with acute angles between line segments are not allowed.
  INT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CB2i { @ CB2i Shapes with acute angles between line segments are not allowed.
  INT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CB2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RPOi { @ RPOi Shapes with acute angles between line segments are not allowed.
  INT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NT_Ni { @ NT_Ni Shapes with acute angles between line segments are not allowed.
  INT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NCap_NTNi { @ NCap_NTNi Shapes with acute angles between line segments are not allowed.
  INT NCap_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NCap_NTNi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:FW_APi { @ FW_APi Shapes with acute angles between line segments are not allowed.
  INT FW_APi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FW_APi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:FW_CUi { @ FW_CUi Shapes with acute angles between line segments are not allowed.
  INT FW_CUi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT FW_CUi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PMi { @ PMi Shapes with acute angles between line segments are not allowed.
  INT PMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PM1i { @ PM1i Shapes with acute angles between line segments are not allowed.
  INT PM1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PM1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PM2i { @ PM2i Shapes with acute angles between line segments are not allowed.
  INT PM2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PM2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SEALRINGi { @ SEALRINGi Shapes with acute angles between line segments are not allowed.
  INT SEALRINGi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SEALRINGi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTH_Ni { @ VTH_Ni Shapes with acute angles between line segments are not allowed.
  INT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTH_Pi { @ VTH_Pi Shapes with acute angles between line segments are not allowed.
  INT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTH_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ULVT_Ni { @ ULVT_Ni Shapes with acute angles between line segments are not allowed.
  INT ULVT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ULVT_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ULVT_Pi { @ ULVT_Pi Shapes with acute angles between line segments are not allowed.
  INT ULVT_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ULVT_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTL_Ni { @ VTL_Ni Shapes with acute angles between line segments are not allowed.
  INT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Ni < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VTL_Pi { @ VTL_Pi Shapes with acute angles between line segments are not allowed.
  INT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VTL_Pi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CBDi { @ CBDi Shapes with acute angles between line segments are not allowed.
  INT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:UBMi { @ UBMi Shapes with acute angles between line segments are not allowed.
  INT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT UBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RH { @ RH Shapes with acute angles between line segments are not allowed.
  INT RH < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RH < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ESD3 { @ ESD3 Shapes with acute angles between line segments are not allowed.
  INT ESD3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VARi { @ VARi Shapes with acute angles between line segments are not allowed.
  INT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VARi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:APi { @ APi Shapes with acute angles between line segments are not allowed.
  INT APi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT APi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:Cu_PPIi { @ Cu_PPIi Shapes with acute angles between line segments are not allowed.
  INT Cu_PPIi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT Cu_PPIi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RVi { @ RVi Shapes with acute angles between line segments are not allowed.
  INT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RVi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SANi { @ SANi Shapes with acute angles between line segments are not allowed.
  INT SANi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SANi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CBMi { @ CBMi Shapes with acute angles between line segments are not allowed.
  INT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CBMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CTMi { @ CTMi Shapes with acute angles between line segments are not allowed.
  INT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRM { @ SRM Shapes with acute angles between line segments are not allowed.
  INT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRM < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LMARK { @ LMARK Shapes with acute angles between line segments are not allowed.
  INT LMARK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LMARK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:BJTDMY { @ BJTDMY Shapes with acute angles between line segments are not allowed.
  INT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT BJTDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DIODMY { @ DIODMY Shapes with acute angles between line segments are not allowed.
  INT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DIODMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:NWDMY { @ NWDMY Shapes with acute angles between line segments are not allowed.
  INT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT NWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RPDMY { @ RPDMY Shapes with acute angles between line segments are not allowed.
  INT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DPDMY { @ DPDMY Shapes with acute angles between line segments are not allowed.
  INT DPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PLDMY { @ PLDMY Shapes with acute angles between line segments are not allowed.
  INT PLDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PLDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SDI { @ SDI Shapes with acute angles between line segments are not allowed.
  INT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SDI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PMDMY { @ PMDMY Shapes with acute angles between line segments are not allowed.
  INT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ESD1DMY { @ ESD1DMY Shapes with acute angles between line segments are not allowed.
  INT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD1DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ESD2DMY { @ ESD2DMY Shapes with acute angles between line segments are not allowed.
  INT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESD2DMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CDUDMY { @ CDUDMY Shapes with acute angles between line segments are not allowed.
  INT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CDUDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CSRDMY { @ CSRDMY Shapes with acute angles between line segments are not allowed.
  INT CSRDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CSRDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LOGO { @ LOGO Shapes with acute angles between line segments are not allowed.
  INT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LOGO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:INDDMY { @ INDDMY Shapes with acute angles between line segments are not allowed.
  INT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT INDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:CTMDMY { @ CTMDMY Shapes with acute angles between line segments are not allowed.
  INT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT CTMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:WBDMY { @ WBDMY Shapes with acute angles between line segments are not allowed.
  INT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT WBDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:LUPWDMY { @ LUPWDMY Shapes with acute angles between line segments are not allowed.
  INT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT LUPWDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VDDDMY { @ VDDDMY Shapes with acute angles between line segments are not allowed.
  INT VDDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VDDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VSSDMY { @ VSSDMY Shapes with acute angles between line segments are not allowed.
  INT VSSDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VSSDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_1 { @ MOMDMY_1 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_2 { @ MOMDMY_2 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_3 { @ MOMDMY_3 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_4 { @ MOMDMY_4 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_5 { @ MOMDMY_5 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_6 { @ MOMDMY_6 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_7 { @ MOMDMY_7 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_7 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_7 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_8 { @ MOMDMY_8 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_8 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_8 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_9 { @ MOMDMY_9 Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_9 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_9 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MOMDMY_AP { @ MOMDMY_AP Shapes with acute angles between line segments are not allowed.
  INT MOMDMY_AP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MOMDMY_AP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RTMOMDMY { @ RTMOMDMY Shapes with acute angles between line segments are not allowed.
  INT RTMOMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RTMOMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RFDMY { @ RFDMY Shapes with acute angles between line segments are not allowed.
  INT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RFDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRAMDMY { @ SRAMDMY Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRAMDMY_PERI { @ SRAMDMY_PERI Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY_PERI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY_PERI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SRAMDMY6_PERI { @ SRAMDMY6_PERI Shapes with acute angles between line segments are not allowed.
  INT SRAMDMY6_PERI < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SRAMDMY6_PERI < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:SBDDMY { @ SBDDMY Shapes with acute angles between line segments are not allowed.
  INT SBDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT SBDDMY < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MATCHING { @ MATCHING Shapes with acute angles between line segments are not allowed.
  INT MATCHING < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MATCHING < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M1_real { @ M1_real Shapes with acute angles between line segments are not allowed.
  INT M1_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M1i { @ M1i Shapes with acute angles between line segments are not allowed.
  INT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM1 { @ DUM1 Shapes with acute angles between line segments are not allowed.
  INT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM1 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM1_O { @ DUM1_O Shapes with acute angles between line segments are not allowed.
  INT DUM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM1_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M2_real { @ M2_real Shapes with acute angles between line segments are not allowed.
  INT M2_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M2i { @ M2i Shapes with acute angles between line segments are not allowed.
  INT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM2 { @ DUM2 Shapes with acute angles between line segments are not allowed.
  INT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM2 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM2_O { @ DUM2_O Shapes with acute angles between line segments are not allowed.
  INT DUM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM2_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M3_real { @ M3_real Shapes with acute angles between line segments are not allowed.
  INT M3_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M3i { @ M3i Shapes with acute angles between line segments are not allowed.
  INT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM3 { @ DUM3 Shapes with acute angles between line segments are not allowed.
  INT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM3 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM3_O { @ DUM3_O Shapes with acute angles between line segments are not allowed.
  INT DUM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM3_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M4_real { @ M4_real Shapes with acute angles between line segments are not allowed.
  INT M4_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M4i { @ M4i Shapes with acute angles between line segments are not allowed.
  INT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM4 { @ DUM4 Shapes with acute angles between line segments are not allowed.
  INT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM4 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM4_O { @ DUM4_O Shapes with acute angles between line segments are not allowed.
  INT DUM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM4_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M5_real { @ M5_real Shapes with acute angles between line segments are not allowed.
  INT M5_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M5i { @ M5i Shapes with acute angles between line segments are not allowed.
  INT M5i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM5 { @ DUM5 Shapes with acute angles between line segments are not allowed.
  INT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM5_O { @ DUM5_O Shapes with acute angles between line segments are not allowed.
  INT DUM5_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM5_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M6_real { @ M6_real Shapes with acute angles between line segments are not allowed.
  INT M6_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M6i { @ M6i Shapes with acute angles between line segments are not allowed.
  INT M6i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM6 { @ DUM6 Shapes with acute angles between line segments are not allowed.
  INT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM6_O { @ DUM6_O Shapes with acute angles between line segments are not allowed.
  INT DUM6_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM6_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M7_real { @ M7_real Shapes with acute angles between line segments are not allowed.
  INT M7_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M7i { @ M7i Shapes with acute angles between line segments are not allowed.
  INT M7i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM7 { @ DUM7 Shapes with acute angles between line segments are not allowed.
  INT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM7 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM7_O { @ DUM7_O Shapes with acute angles between line segments are not allowed.
  INT DUM7_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM7_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M8_real { @ M8_real Shapes with acute angles between line segments are not allowed.
  INT M8_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M8_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M8i { @ M8i Shapes with acute angles between line segments are not allowed.
  INT M8i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M8i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM8 { @ DUM8 Shapes with acute angles between line segments are not allowed.
  INT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM8 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM8_O { @ DUM8_O Shapes with acute angles between line segments are not allowed.
  INT DUM8_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM8_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M9_real { @ M9_real Shapes with acute angles between line segments are not allowed.
  INT M9_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M9i { @ M9i Shapes with acute angles between line segments are not allowed.
  INT M9i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM9 { @ DUM9 Shapes with acute angles between line segments are not allowed.
  INT DUM9 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM9 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUM9_O { @ DUM9_O Shapes with acute angles between line segments are not allowed.
  INT DUM9_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUM9_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MD_real { @ MD_real Shapes with acute angles between line segments are not allowed.
  INT MD_real < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MD_real < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MDi { @ MDi Shapes with acute angles between line segments are not allowed.
  INT MDi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MDi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUMD { @ DUMD Shapes with acute angles between line segments are not allowed.
  INT DUMD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUMD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DUMD_O { @ DUMD_O Shapes with acute angles between line segments are not allowed.
  INT DUMD_O < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DUMD_O < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM1EXCL { @ DM1EXCL Shapes with acute angles between line segments are not allowed.
  INT DM1EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM1EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM2EXCL { @ DM2EXCL Shapes with acute angles between line segments are not allowed.
  INT DM2EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM2EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM3EXCL { @ DM3EXCL Shapes with acute angles between line segments are not allowed.
  INT DM3EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM3EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM4EXCL { @ DM4EXCL Shapes with acute angles between line segments are not allowed.
  INT DM4EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM4EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM5EXCL { @ DM5EXCL Shapes with acute angles between line segments are not allowed.
  INT DM5EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM5EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM6EXCL { @ DM6EXCL Shapes with acute angles between line segments are not allowed.
  INT DM6EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM6EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM7EXCL { @ DM7EXCL Shapes with acute angles between line segments are not allowed.
  INT DM7EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM7EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM8EXCL { @ DM8EXCL Shapes with acute angles between line segments are not allowed.
  INT DM8EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM8EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DM9EXCL { @ DM9EXCL Shapes with acute angles between line segments are not allowed.
  INT DM9EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DM9EXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DMDEXCL { @ DMDEXCL Shapes with acute angles between line segments are not allowed.
  INT DMDEXCL < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DMDEXCL < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA1i { @ VIA1i Shapes with acute angles between line segments are not allowed.
  INT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA1i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA2i { @ VIA2i Shapes with acute angles between line segments are not allowed.
  INT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA2i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA3i { @ VIA3i Shapes with acute angles between line segments are not allowed.
  INT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA3i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA4i { @ VIA4i Shapes with acute angles between line segments are not allowed.
  INT VIA4i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA4i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA5i { @ VIA5i Shapes with acute angles between line segments are not allowed.
  INT VIA5i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA5i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA6i { @ VIA6i Shapes with acute angles between line segments are not allowed.
  INT VIA6i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA6i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA7i { @ VIA7i Shapes with acute angles between line segments are not allowed.
  INT VIA7i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA7i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIA8i { @ VIA8i Shapes with acute angles between line segments are not allowed.
  INT VIA8i < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIA8i < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:VIADi { @ VIADi Shapes with acute angles between line segments are not allowed.
  INT VIADi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT VIADi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODi { @ ODi Shapes with acute angles between line segments are not allowed.
  INT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODi_OTHERS { @ ODi_OTHERS Shapes with acute angles between line segments are not allowed.
  INT ODi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODi_RFDRAIN { @ ODi_RFDRAIN Shapes with acute angles between line segments are not allowed.
  INT ODi_RFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODi_RFDRAIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DOD { @ DOD Shapes with acute angles between line segments are not allowed.
  INT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DOD < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POi { @ POi Shapes with acute angles between line segments are not allowed.
  INT POi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POi_OTHERS { @ POi_OTHERS Shapes with acute angles between line segments are not allowed.
  INT POi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POi_OTHERS < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:DPO { @ DPO Shapes with acute angles between line segments are not allowed.
  INT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT DPO < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:PSPOi { @ PSPOi Shapes with acute angles between line segments are not allowed.
  INT PSPOi < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT PSPOi < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ODBLK { @ ODBLK Shapes with acute angles between line segments are not allowed.
  INT ODBLK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ODBLK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:POBLK { @ POBLK Shapes with acute angles between line segments are not allowed.
  INT POBLK < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT POBLK < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:RES200 { @ RES200 Shapes with acute angles between line segments are not allowed.
  INT RES200 < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT RES200 < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:ESDIMP { @ ESDIMP Shapes with acute angles between line segments are not allowed.
  INT ESDIMP < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT ESDIMP < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M1_PIN { @ M1_PIN Shapes with acute angles between line segments are not allowed.
  INT M1_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M1_PIN_TEXT { @ M1_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M1_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M1_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M2_PIN { @ M2_PIN Shapes with acute angles between line segments are not allowed.
  INT M2_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M2_PIN_TEXT { @ M2_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M2_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M2_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M3_PIN { @ M3_PIN Shapes with acute angles between line segments are not allowed.
  INT M3_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M3_PIN_TEXT { @ M3_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M3_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M3_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M4_PIN { @ M4_PIN Shapes with acute angles between line segments are not allowed.
  INT M4_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M4_PIN_TEXT { @ M4_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M4_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M4_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M5_PIN { @ M5_PIN Shapes with acute angles between line segments are not allowed.
  INT M5_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M5_PIN_TEXT { @ M5_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M5_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M5_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M6_PIN { @ M6_PIN Shapes with acute angles between line segments are not allowed.
  INT M6_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M6_PIN_TEXT { @ M6_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M6_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M6_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M7_PIN { @ M7_PIN Shapes with acute angles between line segments are not allowed.
  INT M7_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M7_PIN_TEXT { @ M7_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M7_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M7_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M8_PIN { @ M8_PIN Shapes with acute angles between line segments are not allowed.
  INT M8_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M8_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M8_PIN_TEXT { @ M8_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M8_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M8_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M9_PIN { @ M9_PIN Shapes with acute angles between line segments are not allowed.
  INT M9_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:M9_PIN_TEXT { @ M9_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT M9_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT M9_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MD_PIN { @ MD_PIN Shapes with acute angles between line segments are not allowed.
  INT MD_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MD_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:MD_PIN_TEXT { @ MD_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT MD_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT MD_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:AP_PIN { @ AP_PIN Shapes with acute angles between line segments are not allowed.
  INT AP_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT AP_PIN < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.2:AP_PIN_TEXT { @ AP_PIN_TEXT Shapes with acute angles between line segments are not allowed.
  INT AP_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
  EXT AP_PIN_TEXT < 0.1 ABUT < 90 INTERSECTING ONLY
}
G.3:RRuleRequired { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RRuleRequired >0 <90    
  NOT ANGLE A == 45
}
G.3:RRuleRecommended { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RRuleRecommended >0 <90    
  NOT ANGLE A == 45
}
G.3:RRuleAnalog { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RRuleAnalog >0 <90    
  NOT ANGLE A == 45
}
G.3:RRuleGuideline { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RRuleGuideline >0 <90    
  NOT ANGLE A == 45
}
G.3:excludeRRuleRequired { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE excludeRRuleRequired >0 <90    
  NOT ANGLE A == 45
}
G.3:excludeRRuleRecommended { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE excludeRRuleRecommended >0 <90    
  NOT ANGLE A == 45
}
G.3:excludeRRuleAnalog { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE excludeRRuleAnalog >0 <90    
  NOT ANGLE A == 45
}
G.3:excludeRRuleGuideline { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE excludeRRuleGuideline >0 <90    
  NOT ANGLE A == 45
}
G.3:RODMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RODMY >0 <90    
  NOT ANGLE A == 45
}
G.3:DNWi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DNWi >0 <90    
  NOT ANGLE A == 45
}
G.3:NWi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE NWi >0 <90    
  NOT ANGLE A == 45
}
G.3:NWi_OTHERS { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE NWi_OTHERS >0 <90    
  NOT ANGLE A == 45
}
G.3:OD_18i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE OD_18i >0 <90    
  NOT ANGLE A == 45
}
G.3:OD_25i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE OD_25i >0 <90    
  NOT ANGLE A == 45
}
G.3:OD_2533 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE OD_2533 >0 <90    
  NOT ANGLE A == 45
}
G.3:OD_33i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE OD_33i >0 <90    
  NOT ANGLE A == 45
}
G.3:OD_DECAP { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE OD_DECAP >0 <90    
  NOT ANGLE A == 45
}
G.3:PPi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE PPi >0 <90    
  NOT ANGLE A == 45
}
G.3:NPi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE NPi >0 <90    
  NOT ANGLE A == 45
}
G.3:COi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE COi >0 <90    
  NOT ANGLE A == 45
}
G.3:CBi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE CBi >0 <90    
  NOT ANGLE A == 45
}
G.3:RPOi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RPOi >0 <90    
  NOT ANGLE A == 45
}
G.3:NT_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE NT_Ni >0 <90    
  NOT ANGLE A == 45
}
G.3:NCap_NTNi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE NCap_NTNi >0 <90    
  NOT ANGLE A == 45
}
G.3:FW_APi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE FW_APi >0 <90    
  NOT ANGLE A == 45
}
G.3:FW_CUi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE FW_CUi >0 <90    
  NOT ANGLE A == 45
}
G.3:SEALRINGi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SEALRINGi >0 <90    
  NOT ANGLE A == 45
}
G.3:VTH_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VTH_Ni >0 <90    
  NOT ANGLE A == 45
}
G.3:VTH_Pi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VTH_Pi >0 <90    
  NOT ANGLE A == 45
}
G.3:ULVT_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ULVT_Ni >0 <90    
  NOT ANGLE A == 45
}
G.3:ULVT_Pi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ULVT_Pi >0 <90    
  NOT ANGLE A == 45
}
G.3:VTL_Ni { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VTL_Ni >0 <90    
  NOT ANGLE A == 45
}
G.3:VTL_Pi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VTL_Pi >0 <90    
  NOT ANGLE A == 45
}
G.3:RH { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RH >0 <90    
  NOT ANGLE A == 45
}
G.3:ESD3 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ESD3 >0 <90    
  NOT ANGLE A == 45
}
G.3:VARi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VARi >0 <90    
  NOT ANGLE A == 45
}
G.3:APi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE APi >0 <90    
  NOT ANGLE A == 45
}
G.3:Cu_PPIi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE Cu_PPIi >0 <90    
  NOT ANGLE A == 45
}
G.3:RVi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RVi >0 <90    
  NOT ANGLE A == 45
}
G.3:SANi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SANi >0 <90    
  NOT ANGLE A == 45
}
G.3:CBMi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE CBMi >0 <90    
  NOT ANGLE A == 45
}
G.3:CTMi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE CTMi >0 <90    
  NOT ANGLE A == 45
}
G.3:SRM { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SRM >0 <90    
  NOT ANGLE A == 45
}
G.3:LMARK { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE LMARK >0 <90    
  NOT ANGLE A == 45
}
G.3:BJTDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE BJTDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:DIODMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DIODMY >0 <90    
  NOT ANGLE A == 45
}
G.3:NWDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE NWDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:RPDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RPDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:DPDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DPDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:PLDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE PLDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:SDI { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SDI >0 <90    
  NOT ANGLE A == 45
}
G.3:ESD1DMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ESD1DMY >0 <90    
  NOT ANGLE A == 45
}
G.3:ESD2DMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ESD2DMY >0 <90    
  NOT ANGLE A == 45
}
G.3:CDUDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE CDUDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:CSRDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE CSRDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:LOGO { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE LOGO >0 <90    
  NOT ANGLE A == 45
}
G.3:INDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE INDDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:CTMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE CTMDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:WBDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE WBDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:LUPWDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE LUPWDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:VDDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VDDDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:VSSDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VSSDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_1 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_1 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_2 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_2 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_3 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_3 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_4 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_4 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_5 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_5 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_6 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_6 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_7 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_7 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_8 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_8 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_9 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_9 >0 <90    
  NOT ANGLE A == 45
}
G.3:MOMDMY_AP { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MOMDMY_AP >0 <90    
  NOT ANGLE A == 45
}
G.3:RTMOMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RTMOMDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:RFDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RFDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:SRAMDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SRAMDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:SRAMDMY_PERI { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SRAMDMY_PERI >0 <90    
  NOT ANGLE A == 45
}
G.3:SRAMDMY6_PERI { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SRAMDMY6_PERI >0 <90    
  NOT ANGLE A == 45
}
G.3:SBDDMY { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE SBDDMY >0 <90    
  NOT ANGLE A == 45
}
G.3:MATCHING { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MATCHING >0 <90    
  NOT ANGLE A == 45
}
G.3:M1_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M1_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M1i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M1i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM1 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM1 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM1_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM1_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M2_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M2_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M2i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M2i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM2 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM2 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM2_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM2_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M3_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M3_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M3i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M3i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM3 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM3 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM3_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM3_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M4_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M4_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M4i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M4i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM4 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM4 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM4_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM4_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M5_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M5_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M5i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M5i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM5 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM5 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM5_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM5_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M6_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M6_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M6i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M6i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM6 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM6 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM6_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM6_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M7_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M7_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M7i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M7i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM7 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM7 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM7_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM7_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M8_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M8_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M8i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M8i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM8 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM8 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM8_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM8_O >0 <90    
  NOT ANGLE A == 45
}
G.3:M9_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M9_real >0 <90    
  NOT ANGLE A == 45
}
G.3:M9i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M9i >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM9 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM9 >0 <90    
  NOT ANGLE A == 45
}
G.3:DUM9_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUM9_O >0 <90    
  NOT ANGLE A == 45
}
G.3:MD_real { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MD_real >0 <90    
  NOT ANGLE A == 45
}
G.3:MDi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MDi >0 <90    
  NOT ANGLE A == 45
}
G.3:DUMD { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUMD >0 <90    
  NOT ANGLE A == 45
}
G.3:DUMD_O { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DUMD_O >0 <90    
  NOT ANGLE A == 45
}
G.3:DM1EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM1EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM2EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM2EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM3EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM3EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM4EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM4EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM5EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM5EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM6EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM6EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM7EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM7EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM8EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM8EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DM9EXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DM9EXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:DMDEXCL { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DMDEXCL >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA1i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA1i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA2i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA2i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA3i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA3i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA4i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA4i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA5i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA5i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA6i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA6i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA7i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA7i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIA8i { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIA8i >0 <90    
  NOT ANGLE A == 45
}
G.3:VIADi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE VIADi >0 <90    
  NOT ANGLE A == 45
}
G.3:ODi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ODi >0 <90    
  NOT ANGLE A == 45
}
G.3:ODi_OTHERS { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ODi_OTHERS >0 <90    
  NOT ANGLE A == 45
}
G.3:ODi_RFDRAIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ODi_RFDRAIN >0 <90    
  NOT ANGLE A == 45
}
G.3:DOD { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DOD >0 <90    
  NOT ANGLE A == 45
}
G.3:POi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE POi >0 <90    
  NOT ANGLE A == 45
}
G.3:POi_OTHERS { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE POi_OTHERS >0 <90    
  NOT ANGLE A == 45
}
G.3:DPO { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE DPO >0 <90    
  NOT ANGLE A == 45
}
G.3:PSPOi { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE PSPOi >0 <90    
  NOT ANGLE A == 45
}
G.3:ODBLK { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ODBLK >0 <90    
  NOT ANGLE A == 45
}
G.3:POBLK { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE POBLK >0 <90    
  NOT ANGLE A == 45
}
G.3:RES200 { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE RES200 >0 <90    
  NOT ANGLE A == 45
}
G.3:ESDIMP { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE ESDIMP >0 <90    
  NOT ANGLE A == 45
}
G.3:M1_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M1_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M1_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M1_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M2_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M2_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M2_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M2_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M3_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M3_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M3_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M3_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M4_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M4_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M4_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M4_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M5_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M5_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M5_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M5_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M6_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M6_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M6_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M6_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M7_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M7_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M7_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M7_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M8_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M8_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M8_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M8_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:M9_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M9_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:M9_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE M9_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:MD_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MD_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:MD_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE MD_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.3:AP_PIN { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE AP_PIN >0 <90    
  NOT ANGLE A == 45
}
G.3:AP_PIN_TEXT { @ Shapes must be orthogonal or on a 45 degree angle.
  A = ANGLE AP_PIN_TEXT >0 <90    
  NOT ANGLE A == 45
}
G.4:NOTUSEM1 { @ Do not use NOTUSEM1 which is reserved for tsmc internal mask making
    COPY NOTUSEM1
}
G.4:NOTUSEM2 { @ Do not use NOTUSEM2 which is reserved for tsmc internal mask making
    COPY NOTUSEM2
}
G.4:NOTUSEM3 { @ Do not use NOTUSEM3 which is reserved for tsmc internal mask making
    COPY NOTUSEM3
}
G.4:NOTUSEM4 { @ Do not use NOTUSEM4 which is reserved for tsmc internal mask making
    COPY NOTUSEM4
}
G.4:NOTUSEM5 { @ Do not use NOTUSEM5 which is reserved for tsmc internal mask making
    COPY NOTUSEM5
}
G.4:NOTUSEM6 { @ Do not use NOTUSEM6 which is reserved for tsmc internal mask making
    COPY NOTUSEM6
}
G.4:NOTUSEM7 { @ Do not use NOTUSEM7 which is reserved for tsmc internal mask making
    COPY NOTUSEM7
}
G.4:NOTUSEM8 { @ Do not use NOTUSEM8 which is reserved for tsmc internal mask making
    COPY NOTUSEM8
}
G.4:NOTUSEM9 { @ Do not use NOTUSEM9 which is reserved for tsmc internal mask making
    COPY NOTUSEM9
}
G.4:NOTUSEMD { @ Do not use NOTUSEMD which is reserved for tsmc internal mask making
    COPY NOTUSEMD
}
G.4:NOTUSEOD { @ Do not use NOTUSEOD which is reserved for tsmc internal mask making
    COPY NOTUSEOD
}
G.4:NOTUSEPO { @ Do not use NOTUSEPO which is reserved for tsmc internal mask making
    COPY NOTUSEPO
}

USER_GUIDE.M1 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM1
}    
USER_GUIDE.M2 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM2
}    
USER_GUIDE.M3 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM3
}    
USER_GUIDE.M4 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM4
}    
USER_GUIDE.M5 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM5
}    
USER_GUIDE.M6 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM6
}    
USER_GUIDE.M7 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM7
}    
USER_GUIDE.M8 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM8
}    
USER_GUIDE.M9 { @ Metal layers with forbidden datatypes.
  COPY NOUSEM9
}    
USER_GUIDE.MD { @ Metal layers with forbidden datatypes.
  COPY NOUSEMD
}    
USER_GUIDE.2 { @ Dummy metal,poly,od can't be used to connect
  DUM1 INTERACT COi
  DUM1 INTERACT VIA1i
  DUM2 INTERACT VIA1i
  DUM2 INTERACT VIA2i
  DUM3 INTERACT VIA2i
  DUM3 INTERACT VIA3i
  DUM4 INTERACT VIA3i
  DUM4 INTERACT VIA4i
  DUM5 INTERACT VIA4i
  DUM5 INTERACT VIA5i
  DUM6 INTERACT VIA5i
  DUM6 INTERACT VIA6i
  DUM7 INTERACT VIA6i
  DUM7 INTERACT VIA7i
  DUM8 INTERACT VIA7i
  DUM8 INTERACT VIA8i
  DUM9 INTERACT VIA8i
  DUM9 INTERACT VIADi
  DUMD INTERACT VIADi
  DPO INTERACT COi
  DOD INTERACT COi
}

#IFDEF DATATYPE_WARNING
NW_DATATYPE:WARNING1 { @ It is strongly recommended to use NW;drawing (3;0) layer to define NW region 
  COPY NWi_OTHERS
}
OD_DATATYPE:WARNING1 { @ It is strongly recommended to use only OD;drawing (6;0) and OD;dummy (6;1) layers , 
                       @ which default MT form considers only, to define OD and DOD regions, respectively. 
  		 @ When using any other layer(s) such as pdiff (7;0), ndiff (8;0) or any layer(s) other than (6;0), 
  		 @ and (6;1) to create OD mask, special care must be taken. 
  		 @ The tapeout engineer must explicitly explain the equivalence of those non-default layers to OD 
  		 @ and include them in the MT form to ensure complete and successful mask fabrication. 
  COPY ODi_OTHERS
}

OD_DATATYPE:WARNING3 { @ RFMOS DRAIN OD (6;3) lvs dummy layer are only allowed in RFDMY region. 
   ODi_RFDRAIN NOT RFDMY
}
OD_DATATYPE:WARNING4 { @ Layer (6;3) is for recognition purpose of RF devices, please take care if this layer is adopted for non-RF designs and not for masking purpose of diffusion regions together with OD (6;0). 
  COPY ODi_RFDRAIN 
}
PO_DATATYPE:WARNING1 { @ It is strongly recommended to use PO;drawing (17;0) layer to define PO region and PO;dummy (17;1)layer to define DPO region. 
  COPY POi_OTHERS
}
#ENDIF

#IFDEF RODMY_WARNING
RODMY_DRAWING:WARNING1 { @ RODMY should inside SRM
  RODMY NOT SRM
}
#ENDIF
#IFDEF N80
#IFDEF UTM
N80.OPTION.UTM:WARNING1 { @ N80 doesn't support UTM process.
  COPY CHIP
}
#ENDIF
#ENDIF
#IFDEF UTM
#IFNDEF LmarkSealringCorner
UTM.OPTION:WARNING1 { @ Please turn on LmarkSealringCorner switch if UTM switch is on
  COPY CHIP
}
#ENDIF
#ENDIF
#IFNDEF MSRF
MSRF.OPTION:WARNING1 { @ Please turn on MSRF when N90 MS/RF design is applied.
  CHIP INTERACT CTM
  CHIP INTERACT CBM
  CHIP INTERACT INDDMY
  CHIP INTERACT CTMDMY
  CHIP INTERACT RFDMY
  CHIP INTERACT SBDDMY
}
#ENDIF
#IFNDEF UTM
#IFDEF MSRF_SEALRING
MSRF_SEALRING.OPTION:WARNING1 { @ Please turn on MSRF_SEALRING when UTM design is applied.
  COPY CHIP
}
#ENDIF
#ENDIF

#IFDEF WLCSPSealringCorner 
#IFNDEF LmarkSealringCorner
WLCSP.OPTION:WARNING1 { @ Please turn on LmarkSealringCorner switch if WLCSPSealringCorner switch is on
  COPY CHIP
}
#ENDIF
#ENDIF



DRM.R.1 { @ DRM.R.1 is a warning message to remind the users to check the related DRMs. Please refer to DRM.R.1 in the DRM for details.
  COPY CHIPx
}


//NW CHECKS
//=========

NW2V = NWEL AND OD2
NW1V = NWEL NOT OD2

NW.W.1 { @ Width >= ^NW_W_1 um 
  (INT NWEL < NW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.1 { @ Space >= ^NW_S_1 um 
  (EXT NWEL < NW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.2 { @ Space of two NW1V with different potentials >= ^NW_S_2 um 
  NW1V_NODAL = STAMP NW1V BY NWi
  (EXT NW1V_NODAL < NW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.3 { @ NW1V space to NW2V with different potentials >= ^NW_S_3 um 
  NW1Vc = STAMP NW1V BY NWi 
  NW2Vc = STAMP NW2V BY NWi 
  (EXT NW1Vc NW2Vc < NW_S_3 ABUT < 90 > 0 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NW.S.4 { @ Space of 2 NW2V with different potentials (*) >= ^NW_S_4 um 
  NW2V_NODAL = STAMP NW2V BY NWi
  (EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

#IFDEF SUGGESTED

NW.R.1:SUGGESTED { @ Recommend not to use unintentional NW
  (NWi OUTSIDE NPODi) NOT LOGO
}

NW.S.3__NW.S.4:SUGGESTED { @ A more conservative way to check NW.S.3, NW.S.4 with 
		          @ varied operating voltages determination of nwels.
  NW1V = NWEL OUTSIDE OD2
  NW2V = NWEL NOT OUTSIDE OD2
  EXT NW1V NW2V < NW_S_3 ABUT < 90 > 0 SINGULAR REGION
  NW2V_NODAL = STAMP NW2V BY NWi
  EXT NW2V_NODAL < NW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}

#ENDIF
NW.S.5 { @ Space to PW STRAP >= ^NW_S_5 um 
  EXT NWi PPOD < NW_S_5 ABUT < 90 SINGULAR REGION
  PPOD CUT NWi
}
NW.S.6 { @ Space to N+ ACTIVE >= ^NW_S_6 um 
  A = NPOD NOT INTERACT RNWEL
  EXT NWi A < NW_S_6 ABUT < 90 SINGULAR REGION
  A CUT NWi
}
NW.S.7 { @ Space to {N+ ACTIVE interact with OD2} >= ^NW_S_7 um 
  EXT NWi NACT2 < NW_S_7 ABUT < 90 SINGULAR REGION
}
NW.EN.1 { @ Enclosure of NW STRAP >= ^NW_EN_1 um 
  ENC NPOD NONWR < NW_EN_1 ABUT < 90 SINGULAR REGION
}
NW.EN.2 { @ Enclosure of P+ ACTIVE >= ^NW_EN_2 um 
  ENC PPOD NONWR < NW_EN_2 ABUT < 90 SINGULAR REGION
}
NW.EN.3 { @ Enclosure of {P+ ACTIVE interact with OD2} >= ^NW_EN_3 um 
  ENC PACT2 NWi < NW_EN_3 ABUT < 90 SINGULAR REGION
}
NW.A.1 { @ Area >= ^NW_A_1 um2
  AREA NWEL < NW_A_1
}


VARIABLE NW_A_2pre ((NW_A_2 + (NW_S_1 * NW_S_1 * 3.142))/(2 * NW_S_1))*((NW_A_2 + (NW_S_1 * NW_S_1 * 3.142))/(2 * NW_S_1))/3.141

NW.A.2 { @ Enclosed Area >= ^NW_A_2 um2
  A = HOLES NWEL INNER < NW_A_2pre
  B = A NOT NWEL
  (AREA B < NW_A_2) NOT INSIDE SRAM_EXCLUDE
}





//NWROD CHECKS
//=============

NWROD.W.1 { @ Width >= ^NWROD_W_1 um
  INT RNWEL < NWROD_W_1 ABUT < 90 SINGULAR REGION
}
NWROD.S.1 { @ Space to NWROD or to NW >= ^NWROD_S_1 um
  EXT RNWEL < NWROD_S_1 ABUT < 90 NOTCH SINGULAR REGION
  EXT RNWEL NWEL < NWROD_S_1 ABUT < 90 SINGULAR REGION 
}  
NWROD.S.2 { @ Space to RPO >= ^NWROD_S_2 um 
  EXT NWRES RPO < NWROD_S_2 ABUT < 90 SINGULAR REGION
}
NWROD.EN.1 { @ Enclosure by OD >= ^NWROD_EN_1 um 
  ENC NWRES ODWR < NWROD_EN_1 ABUT < 90 SINGULAR REGION
  NWRES CUT ODWR
}
NWROD.EN.2 { @ Enclosure of CO >= ^NWROD_EN_2 um 
  X = RHWR AND NWRES	// Terminal
  ENC COWR X < NWROD_EN_2 ABUT < 90 SINGULAR REGION
  COWR NOT X
}
NWROD.O.1 { @ RPO overlap of NP. Use exact value (0.4um) on sides touching NWDMY. >= ^NWROD_O_1 um 
  INT NPWR RPO < NWROD_O_1 ABUT < 90 SINGULAR REGION
  A = RHWR INSIDE EDGE NWEL
  B = EXPAND EDGE A OUTSIDE BY NWROD_O_1
  ((NPWR AND RPO) AND NWRES) NOT B
  RHWR NOT NPWR
}
NWROD.O.2 { @ {OD AND NWDMY} overlap of {NP, PP, VTH_N, VTH_P, VTL_N, VTL_P} (all implant layers except NW) is not allowed.
  A = OD AND NWDMY
  A AND NP
  A AND PP
  A AND VTHN
  A AND VTHP
  A AND VTLN
  A AND VTLP
}
NWROD.R.4 { @ Only one NW in NWROD is allowed in one OD
  A = OD INTERACT (NWRES AND OD) > 1
  NWRES INTERACT A
}
NWROD.R.5 { @ Only two NPs in NWROD are allowed in one OD
  A = OD INTERACT (NP INTERACT NWRES) != 2
  NP INTERACT A
}
NWROD.R.6 { @ Only two polygons of RPO hole(Salicide) in NWROD are allowed in the same OD
  OD_RNW = OD INTERACT NWRES
  RPO_HOLE = HOLES RPO
  A = OD_RNW INTERACT RPO_HOLE != 2
  B = OD_RNW NOT INTERACT RPO_HOLE
  RPO INTERACT (A OR B)
}
NWROD.R.7 { @ OD space for NW with parallel length > 0 if NW space <= 5um
  ((EXT NWRES <= 5 NOTCH OPPOSITE REGION) NOT NWRES) INSIDE OD
}


//NWRSTI CHECKS
//=============

//NWRSTI.W.1 is checked by NWROD.W.1
//NWRSTI.S.1 is checked by NWROD.S.1

NWRSTI.EN.1 { @ NP enclosure of OD >= ^NWRSTI_EN_1 um
  ENC ODWR_STI NPWR_STI < NWRSTI_EN_1 ABUT < 90 SINGULAR REGION
  ODWR_STI NOT NPWR_STI
}
NWRSTI.EN.2 { @ OD enclosure of CO >= ^NWRSTI_EN_2 um
  X = ODWR_STI AND NWRES_STI	// Terminal
  ENC COWR_STI X < NWRSTI_EN_2 ABUT < 90 SINGULAR REGION
  COWR_STI NOT X
}

// NWRSTI.EN.3 is checked by NWRSTI.EN.2

NWRSTI.EX.1 { @ OD extension on NWRSTI >= ^NWRSTI_EX_1 um
  ENC NWRES_STI ODWR_STI < NWRSTI_EX_1 ABUT < 90 SINGULAR REGION
  A = ODWR_STI INSIDE EDGE NWRES_STI
  INT A < OD_W_1 ABUT == 90 REGION INTERSECTING ONLY
  ANGLE A == 45
}
NWRSTI.O.1 { @ {NP interact with NWDMY} overlap of {PP, VTH_P, VTL_P} (all p-type implant layers) is not allowed
  A = NP INTERACT NWDMY
  A AND PP
  A AND VTHP
  A AND VTLP
}  


//DNW CHECKS
//==========

DNW.W.1 { @ Width >= ^DNW_W_1 um
  (INT DNW < DNW_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
//DNW.S.1.S80 is checked by DNW.S.1
DNW.S.1 { @ In 90nm process, space >= 4.8 um; in 80nm process, space >= 5.28 um.
  (EXT DNW < DNW_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

//DNW.S.2.S80 is checked by DNW.S.2
DNW.S.2 { @ Space to NW with different potential >= ^DNW_S_2 um
  (EXT DNW NWEL < DNW_S_2 ABUT < 90 NOT CONNECTED SINGULAR REGION MEASURE ALL) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.3 { @ Space to N+ACTIVE(DNW cut N+ACTIVE is not allowe) >= 1.82 um
  A = NACT OUTSIDE DNW
  EXT DNW A < DNW_S_3 ABUT < 90 SINGULAR REGION
  NACT CUT DNW
}

RW   = PWEL INSIDE DNW
RW1V = RW OUTSIDE OD2
RW2V = RW NOT OUTSIDE OD2
RW1V_NODAL = STAMP RW1V BY RWi
RW2V_NODAL = STAMP RW2V BY RWi
PWELx = PWEL NOT INSIDE DNW
PWEL_NODAL = STAMP PWELx BY PWELi

DNW.S.4 { @ RW space to {RW OR PW} with different potential >= 1.0 um 
  (EXT RW1V_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW1V_NODAL PWEL_NODAL < DNW_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.S.5 { @ {RW OR PW} space to {RW interact with OD2} with different potential >= 1.2 um
  (EXT RW2V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL RW1V_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (EXT RW2V_NODAL PWEL_NODAL < DNW_S_5 ABUT < 90 NOT CONNECTED SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.EN.2 { @ Enclosure of N+ACTIVE >= 0.62 um
  (ENC NACT DNW < DNW_EN_2 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
DNW.O.1 { @ Overlap of NW >= 0.4 um
  (INT DNW NWEL < DNW_O_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

// DNW.R.3 can not be checked by DRC
// DNW.R.4U can not be checked by DRC


//OD CHECKS
//=========

OD.W.1 { @ Width >= ^OD_W_1 um 
  INT OD < OD_W_1 ABUT < 90 SINGULAR REGION
}
OD.W.2 { @ Width of MOS (<= 1.2V) [for core device] >= ^OD_W_2 um
  LENGTH GATE_W < OD_W_2
}
OD.W.3 { @ Width of MOS (> 1.2V to <= 3.3V) [for I/O device] >= ^OD_W_3 um
  LENGTH HV_GATE_W < OD_W_3
}

OD_EDGE_45 = OD ANGLE == 45

OD.W.4 { @ Width of 45 degree OD >= ^OD_W_4 um.
  INT OD_EDGE_45 < OD_W_4 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
//OD.W.4.R is checked by RR:OD.W.4  
    RR:OD.W.4 { @ Width of 45 degree OD >= ^OD_W_4R um
      INT OD_EDGE_45 < OD_W_4R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF
OD.S.1 { @ Space >= ^OD_S_1 um 
  EXT OD < OD_S_1 ABUT < 90 SINGULAR REGION
}

HV_OD_E = OD INSIDE EDGE OD2

OD.S.2 { @ Space of {OD AND OD2} >= ^OD_S_2 um	
  EXT HV_OD_E < OD_S_2 ABUT < 90 REGION
}  
OD.S.3 { @ Space between 2 ODs with a parallel run length (L) >= 0.3 um and at least one of the corresponding OD regions has width (W) > 0.23um
		 @ (a) if crossed by a common PO, or (b) if PO is crossing one of the ODs. Rule applies up to the other OD with a space <= 0.16 um away from the gate >= ^OD_S_3 um
  Wide_OD = SIZE OD BY OD_S_3_W /2 UNDEROVER TRUNCATE OD_S_3_W /2
  OD_SPACE = EXT Wide_OD OD < OD_S_3 ABUT < 90 OPPOSITE REGION
  OD_SPACE_L = ENCLOSE RECTANGLE OD_SPACE OD_S_1 OD_S_3_L
  OD_EDGE = OD COIN OUTSIDE EDGE OD_SPACE_L
  EXT OD_EDGE GATE_L <= OD_S_3 ABUT > 0 < 90 REGION
}
OD.S.4 { @ Space to 45-degree OD >= ^OD_S_4 um
  X = EXPAND EDGE OD_EDGE_45 OUTSIDE BY OD_S_4
  X AND OD
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
//OD.S.4.R is checked by RR:OD.S.4  
    RR:OD.S.4 { @ OD space to 45-degree OD >= ^OD_S_4R um
      X = EXPAND EDGE OD_EDGE_45 OUTSIDE BY OD_S_4R
      X AND OD
    }
  #ENDIF
#ENDIF


OD.S.5 { @ Space between two segments of a U-shape or an O-shape OD (notch only) >= ^OD_S_5 um
  CONVEX EDGE OD ANGLE1 == 270 ANGLE2 == 270 WITH LENGTH < OD_S_5
}  
OD.A.1 { @ Area >= ^OD_A_1 um2
  (AREA ODs < OD_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE OD_A_2pre ((OD_A_2 + (OD_S_1 * OD_S_1 * 3.142))/(2 * OD_S_1))*((OD_A_2 + (OD_S_1 * OD_S_1 * 3.142))/(2 * OD_S_1))/3.141

//OD.A.2.S80 is checked by OD.A.2
OD.A.2 { @ Enclosed area >= ^OD_A_2 um2
  A = HOLES OD INNER < OD_A_2pre
  B = A NOT OD
  AREA B < OD_A_2
}



OD.L.1 { @ Maximum length of {ACTIVE (source) [width < 0.15 um] interacts with butted_STRAP} if no CO on O region <= ^OD_L_1 um
  BUTTED_EDGE = LENGTH NP_PP_BTE < OD_L_1_W
  CHECK_SD = SD WITH EDGE BUTTED_EDGE
  NARROW_SD_pre = INT (CHECK_SD COIN INSIDE EDGE OD) < OD_L_1_W ABUT < 90 OPPOSITE REGION 
  NARROW_SD = NARROW_SD_pre NOT ENCLOSE CO
  CHECK_OD = (NARROW_SD WITH EDGE BUTTED_EDGE) OR (NARROW_SD WITH EDGE GATE_W)
  PATH LENGTH (OD COIN INSIDE EDGE CHECK_OD) > OD_L_1
} 
OD.L.2 { @ Maximum OD length [OD width is < 0.15 um] between two contacts as well as between one contact and the OD line-end <= ^OD_L_2 um
  LONGP = AREA INOD > OD_W_1 * OD_L_2	
  X = LONGP INTERACT COOD
  CHECK_COOD = COOD INTERACT X
  A = SIZE CHECK_COOD BY OD_L_2 / 2 INSIDE OF X STEP OD_S_1*0.7
  LINEN = X INTERACT A == 1
  P2P = X INTERACT A > 1
  B = A INTERACT LINEN
  C = SIZE B BY OD_L_2 / 2 INSIDE OF LINEN STEP OD_S_1*0.7
  BAD = (LINEN NOT C) OR (P2P NOT A)
  BAD_EDGE = BAD COIN INSIDE EDGE OD
  ERR = INT BAD_EDGE < OD_L_2_W ABUT < 90 REGION
  X INTERACT ERR
}
OD.R.1 { @ OD must be fully covered by {NP OR PP} except for DOD/LOGO/NW resistor within OD/SBDDMY region
  (((OD NOT INTERACT NWRES) NOT LOGO) NOT IMP) NOT SBDDMY
}

#IFDEF N80


#IFDEF HS
// OD_DECAP CHECKS
//=================
  OD_DECAP.W.1 { @ OD_DECAP width >= 0.47 um
    INT OD_DECAP < OD_DECAP_W_1 ABUT < 90 SINGULAR REGION
  }  
  OD_DECAP.W.2 { @ Channel width in OD_DECAP >= 0.52 um
    GATE_L_OD_DECAP = GATE_L INSIDE EDGE OD_DECAP
    INT GATE_L_OD_DECAP < OD_DECAP_W_2 ABUT < 90 REGION
  }  
  OD_DECAP.S.1 { @ OD_DECAP space >= 0.47 um
    EXT OD_DECAP < OD_DECAP_S_1 ABUT < 90 SINGULAR REGION
  }
  OD_DECAP.S.2 { @ OD_DECAP space to GATE >= 0.22 um
    EXT OD_DECAP GATE < OD_DECAP_S_2 ABUT < 90 SINGULAR REGION
  }
  OD_DECAP.S.3 { @ OD_DECAP space to OD >= 0.07 um
    EXT OD_DECAP ODs < OD_DECAP_S_3 ABUT < 90 SINGULAR REGION    
  }
  OD_DECAP.S.4 { @ OD_DECAP space to {VAR AND OD} >= 0.27 um
    VAR_OD = VAR AND ODs
    EXT OD_DECAP VAR_OD < OD_DECAP_S_4 ABUT < 90 SINGULAR REGION
    OD_DECAP AND VAR_OD
  }
  OD_DECAP.S.5 { @ OD_DECAP space to OD2 >= 0.47 um
    EXT OD_DECAP OD2 < OD_DECAP_S_5 ABUT < 90 SINGULAR REGION
    OD_DECAP AND OD2   
  }
  OD_DECAP.EN.1 { @ Enclosure of OD by OD_DECAP >= 0.07 um
    ENC ODs OD_DECAP < OD_DECAP_EN_1 ABUT < 90 SINGULAR REGION
    OD_DECAP INSIDE ODs
  }
  OD_DECAP.R.1 { @ OD_DECAP must fully cover {GATE sizing 0.22um}
    OD_DECAP_GATE = GATE NOT OUTSIDE OD_DECAP 
    A = SIZE OD_DECAP_GATE BY OD_DECAP_R_1
    A NOT OD_DECAP
  }
  // OD_DECAP.R.2 can not check by drc
  OD_DECAP.R.3 { @ OD_DECAP cut OD is not allowed
    ODs CUT OD_DECAP
  }
#ELSE
  OD_DECAP.WARN.1 { @ Layer OD_DECAP is only allowed for high-speed(HS) design
    COPY OD_DECAP
  }
#ENDIF
#ENDIF


//DUMMY OD RULE
//================

DOD.W.1 { @ Width >= ^DOD_W_1 um
  INT DOD < DOD_W_1 ABUT < 90 SINGULAR REGION
}
DOD.S.1 { @ Space >= ^DOD_S_1 um
  EXT DOD < DOD_S_1 ABUT < 90 SINGULAR REGION
}
DOD.S.2 { @ Space to OD (Overlap is not allowed) >= ^DOD_S_2 um
  EXT ODi DOD < DOD_S_2 ABUT < 90 SINGULAR REGION 
  ODi AND DOD
}
DOD.S.3 { @ Space to PO (Overlap is not allowed) >= ^DOD_S_3 um
  EXT POi DOD < DOD_S_3 ABUT < 90 SINGULAR REGION 
  POi AND DOD 
}
DOD.S.5 { @ Space to NW >= ^DOD_S_5 um
  EXT NWi DOD < DOD_S_5 ABUT < 90 SINGULAR REGION 
}
DOD.S.6 { @ Space to FW (Overlap is not allowed) >= ^DOD_S_6 um
  EXT FWi DOD < DOD_S_6 ABUT < 90 SINGULAR REGION 
  FWi AND DOD
}
// DOD.S.7.0 is checked by either DOD.S.7 or DOD.S.7.1
// for solid L-mark (old)
DOD.S.7 { @ Space to LMARK (Overlap is not allowed) >= ^DOD_S_7 um
  EXT LMARK_SOLID DOD < DOD_S_7 ABUT < 90 SINGULAR REGION 
  LMARK_SOLID AND DOD
}
// for hollow L-mark (new)
DOD.S.7.1 { @ Space to L-slot (Overlap is not allowed) >= ^DOD_S_7_1 um
  EXT LSLOT DOD < DOD_S_7_1 ABUT < 90 SINGULAR REGION 
  LSLOT AND DOD
}
DOD.S.8 { @ Space to NWDMY (Overlap is not allowed) >= ^DOD_S_8 um
  EXT NWDMY DOD < DOD_S_8 ABUT < 90 SINGULAR REGION 
  NWDMY AND DOD
}
DOD.S.9 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DOD
}
DOD.S.10 { @ Space to INDDMY (Overlap is not allowed) >= ^DOD_S_10 um
  EXT INDDMY DOD < DOD_S_10 ABUT < 90 SINGULAR REGION 
  INDDMY AND DOD
}

DOD.EN.1 { @ Enclosure by NW (fully outside is allowed) >= ^DOD_EN_1 um
  ENC DOD NWi < DOD_EN_1 ABUT < 90 SINGULAR REGION
  DOD CUT NWi
}

#IFDEF FULL_CHIP

DOD.EN.2 { @ Enclosure by chip edge >= ^DOD_EN_2 um
  DOD NOT (SIZE CHIP_CHAMFERED BY -DOD_EN_2)
}
// OD.DN.1 is checked by OD.DN.1:L
// OD.DN.1a is checked by OD.DN.1:L
OD.DN.1:L { @ {OD OR DOD} density across full chip >= 25%
  DENSITY ALL_OD < 0.25 INSIDE OF LAYER CHIP PRINT OD.DN.1:L.density
}
// OD.DN.1 is checked by OD.DN.1:H
// OD.DN.1b is checked by OD.DN.1:H
OD.DN.1:H { @ {OD OR DOD} density across full chip <= 75%
  DENSITY ALL_OD > 0.75 INSIDE OF LAYER CHIP PRINT OD.DN.1:H.density
}  
#ENDIF

ODx_L = ALL_OD NOT OD_DEN_EXC_L1 // for low density check
ODx_H = ALL_OD NOT OD_DEN_EXC_H  // for high density check
CHIP_NOT_ODEXC_L = CHIP NOT OD_DEN_EXC_L1 // for low density check
CHIP_NOT_ODEXC_H = CHIP NOT OD_DEN_EXC_H  // for high density check

#IFDEF DENSITY_IN_BLOCKAGE

OD_ODBLK_L = ODx_L AND ODBLK
OD_ODBLK_H = ODx_H AND ODBLK
CHIP_ODBLK_L = CHIP_NOT_ODEXC_L AND ODBLK
CHIP_ODBLK_H = CHIP_NOT_ODEXC_H AND ODBLK
// OD.DN.3 is checked by OD.DN.3:L
// OD.DN.3a is checked by OD.DN.3:L
OD.DN.3:L { @ Min. OD density over window 150 step 75 >= 20% (within ODBLK)
  ERR_WIN = DENSITY OD_ODBLK_L CHIP_ODBLK_L < 0.2 WINDOW 150 STEP 75 BACKUP PRINT OD.DN.3:L.density
		[ AREA(OD_ODBLK_L)/AREA(CHIP_ODBLK_L) ]
  SIZE ((ERR_WIN AND ODBLK) NOT OD_DEN_EXC_L2) BY (37.5-0.002)/2 UNDEROVER TRUNCATE (37.5-0.002)/2
}
// OD.DN.3 is checked by OD.DN.3:H_IO
// OD.DN.3c is checked by OD.DN.3:H_IO
OD.DN.3:H_IO { @ Max. OD density over window 150 step 75 <= 90% (within ODBLK)
  ERR_WIN = DENSITY OD_ODBLK_H CHIP_ODBLK_H > 0.9 WINDOW 150 STEP 75 BACKUP PRINT OD.DN.3:H_IO.density
		[ AREA(OD_ODBLK_H)/AREA(CHIP_ODBLK_H) ]
  SIZE ((ERR_WIN AND ODBLK) NOT OD_DEN_EXC_H) BY (37.5-0.002)/2 UNDEROVER TRUNCATE (37.5-0.002)/2
}

ODx_MAX_CORE = OD_ODBLK_H NOT OD2
CHIP_MAX_CORE = CHIP_ODBLK_H NOT OD2

// OD.DN.3 is checked by OD.DN.3:H_CORE
// OD.DN.3b is checked by OD.DN.3:H_CORE
OD.DN.3:H_CORE { @ Max. OD density over window 150 step 75 <= 80% in core (with ODBLK)
  ERR_WIN = DENSITY ODx_MAX_CORE CHIP_MAX_CORE > 0.8 WINDOW 150 STEP 75 BACKUP PRINT OD.DN.3:H_CORE.density
		[ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
  SIZE (((ERR_WIN NOT OD2) AND ODBLK) NOT OD_DEN_EXC_H) BY (37.5-0.002)/2 UNDEROVER TRUNCATE (37.5-0.002)/2
}

#ELSE
// OD.DN.2 is checked by OD.DN.2__OD.DN.3:L
// OD.DN.3 is checked by OD.DN.2__OD.DN.3:L
// OD.DN.2a is checked by OD.DN.2__OD.DN.3:L
OD.DN.2__OD.DN.3:L { @ Min. OD density over window 150 step 75 >= 20% 
  ERR_WIN = DENSITY ODx_L CHIP_NOT_ODEXC_L < 0.2 WINDOW 150 STEP 75 BACKUP PRINT OD.DN.2:L.density
		[ AREA(ODx_L)/AREA(CHIP_NOT_ODEXC_L) ]
  SIZE (ERR_WIN NOT OD_DEN_EXC_L2) BY (37.5-0.002)/2 UNDEROVER TRUNCATE (37.5-0.002)/2 
}
// OD.DN.2 is checked by OD.DN.2__OD.DN.3:H_IO 
// OD.DN.3 is checked by OD.DN.2__OD.DN.3:H_IO 
// OD.DN.2c is checked by OD.DN.2__OD.DN.3:H_IO
OD.DN.2__OD.DN.3:H_IO { @ Max. OD density over window 150 step 75 <= 90% 
  ERR_WIN = DENSITY ODx_H CHIP_NOT_ODEXC_H > 0.9 WINDOW 150 STEP 75 BACKUP PRINT OD.DN.2:H_IO.density
		[ AREA(ODx_H)/AREA(CHIP_NOT_ODEXC_H) ]
  SIZE (ERR_WIN NOT OD_DEN_EXC_H) BY (37.5-0.002)/2 UNDEROVER TRUNCATE (37.5-0.002)/2 
}

ODx_MAX_CORE = ODx_H NOT OD2
CHIP_MAX_CORE = CHIP_NOT_ODEXC_H NOT OD2

// OD.DN.2 is checked by OD.DN.2__OD.DN.3:H_CORE
// OD.DN.3 is checked by OD.DN.2__OD.DN.3:H_CORE
// OD.DN.2b is checked by OD.DN.2__OD.DN.3:H_CORE
OD.DN.2__OD.DN.3:H_CORE { @ Max. OD density over window 150 step 75 <= 80% in core 
  ERR_WIN = DENSITY ODx_MAX_CORE CHIP_MAX_CORE > 0.8 WINDOW 150 STEP 75 BACKUP PRINT OD.DN.2:H_CORE.density
		[ AREA(ODx_MAX_CORE)/AREA(CHIP_MAX_CORE) ]
  SIZE ((ERR_WIN NOT OD2) NOT OD_DEN_EXC_H) BY (37.5-0.002)/2 UNDEROVER TRUNCATE (37.5-0.002)/2
}

#ENDIF

#IFDEF FULL_CHIP

DOD.R.1 { @ DOD is a must. DOD CAD layer (TSMC default, 6;1) must be different from OD's. 
  CHIP_CHAMFERED NOT INTERACT DOD
}

#ENDIF

// DOD.R.2 is checked by CSR.R.1:DOD

DOD.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DOD
  HOLES DOD
}


//NT_N RULES CHECK
//================
 
NTN_OD      = NTN AND OD
NTN_PO      = NTN AND POLY
NTN_GATE_W  = NTN_PO INSIDE EDGE NTN_OD
NTN_2_3V_GATE_W = NTN_GATE_W INSIDE EDGE OD2533
NTN_18V_GATE_W   = NTN_GATE_W INSIDE EDGE OD_18
NT_N.W.1 { @ Width >= ^NT_N_W_1 um
  INT NTN < NT_N_W_1 ABUT < 90 SINGULAR REGION
}
//NT_N.W.2.S80 is checked by NT_N.W.2
NT_N.W.2 { @ Channel length of 1.2V core native device (CLN80GT) >= ^NT_N_W_2 um
  INT NTN_GATE_W < NT_N_W_2 ABUT < 90 REGION
}
#IFDEF LP
NTN_GATE_W1.2 = LENGTH NTN_GATE_W >= 1.2
NT_N.W.2.1 { @ Channel length of 1.2V LP nactive device [channel width >= 1.2um] >= ^NT_N_W_2_1 um
  INT NTN_GATE_W1.2 < NT_N_W_2_1 ABUT < 90 REGION
}
#ENDIF
#IFDEF N80
#IFDEF GC
// NT_N.W.2.2.S80 is checked by NT_N.W.2.2:GC
NT_N.W.2.2:GC { @ Channel length of 1.0V core native device (CLN80GC) >= ^NT_N_W_2_2 um
  INT NTN_GATE_W < NT_N_W_2_2 ABUT < 90 REGION
}
#ENDIF
#IFDEF HS
NTN_GATE_W_0.5_1.0 = LENGTH NTN_GATE_W > 0.5 <= 1.0
NTN_GATE_W_0.5_1.0M = ENC [NTN_GATE_W_0.5_1.0] NTN_OD <= 0.79 OPPOSITE
NTN_GATE_W_0.5 = LENGTH NTN_GATE_W == 0.5   
NTN_GATE_W_else1 = NTN_GATE_W NOT COIN EDGE NTN_GATE_W_0.5_1.0M
NTN_GATE_W_else  = NTN_GATE_W_else1 NOT COIN EDGE NTN_GATE_W_0.5
// NT_N.W.2.2.S80 is checked by NT_N.W.2.2:HS
NT_N.W.2.2:HS { @ Channel length of 1.05V core native device (CLN80HS) >= ^NT_N_W_2_2 um
  INT NTN_GATE_W_else NTN_GATE_W < NT_N_W_2_2 ABUT < 90 REGION
}
// NT_N.W.2.3.S80 is checked by NT_N.W.2.3:HS
NT_N.W.2.3:HS { @ Channel length of 1.05V core native device (CLN80HS) [with (0.5<E<=1.0,M<=0.79) or (E=0.5)] >= ^NT_N_W_2_3 um 
  INT NTN_GATE_W_0.5_1.0M < NT_N_W_2_3 ABUT < 90 REGION
  INT NTN_GATE_W_0.5 < NT_N_W_2_3 ABUT < 90 REGION  
}
#ENDIF
#ENDIF


//NT_N.W.3.S80 is checked by NT_N.W.3
NT_N.W.3 { @ Channel length of 2.5V or 3.3V native device >= ^NT_N_W_3 um 
  INT NTN_2_3V_GATE_W < NT_N_W_3 ABUT < 90 REGION
}
//NT_N.W.4.S80 is checked by NT_N.W.4
NT_N.W.4 { @ Channel length of 1.8V native device >= ^NT_N_W_4 um 
  INT NTN_18V_GATE_W < NT_N_W_4 ABUT < 90 REGION
}
NT_N.W.5 { @ Channel width >= ^NT_N_W_5 um
  X = NTN_OD INTERACT POLY  
  INT X < NT_N_W_5 ABUT < 90 SINGULAR REGION
}  
NT_N.S.1 { @ Space >= ^NT_N_S_1 um 
  EXT NTN < NT_N_S_1 ABUT < 90 SINGULAR REGION
}
#IFDEF MSRF
NTN_exc_ind = NTN NOT INDDMY 
//NT_N.S.2.S80 is checked by NT_N.S.2
NT_N.S.2 { @ Space to [ACTIVE outside NT_N] >= ^NT_N_S_2 um 
  A = DACT NOT NTN
  EXT NTN_exc_ind A < NT_N_S_2 ABUT < 90 SINGULAR REGION
}
#ELSE



NT_N.S.2 { @ Space to [ACTIVE outside NT_N] >= ^NT_N_S_2
  A = DACT NOT NTN
  EXT NTN A < NT_N_S_2 ABUT < 90 SINGULAR REGION
}
#ENDIF



//NT_N.S.3.S80 is checked by NT_N.S.3
NT_N.S.3 { @ Space to NW >= ^NT_N_S_3 um 
  EXT NTN NWi < NT_N_S_3 ABUT < 90 SINGULAR REGION
}
#IFDEF N80
#IFDEF MSRF
//NT_N.EN.1.S80 is checked by NT_N.EN.1
NT_N.EN.1 { @ Extension from NT_N region beyond an NP OD region ^NT_N_EN_1 um (maximum = minimum)
  A = NTN_exc_ind INTERACT NPOD
  B = NPOD INTERACT NTN_exc_ind
  C = SIZE B BY NT_N_EN_1
  D = SIZE A BY -NT_N_EN_1
  A XOR C
  B XOR D
}
#ELSE

NT_N.EN.1 { @ Extension from NT_N region beyond an NP OD region ^NT_N_EN_1 um (maximum = minimum)
  A = NTN INTERACT NPOD
  B = NPOD INTERACT NTN
  C = SIZE B BY NT_N_EN_1
  D = SIZE A BY -NT_N_EN_1
  A XOR C
  B XOR D
}
#ENDIF

#ELSE

#IFDEF MSRF
//NT_N.EN.1.S80 is checked by NT_N.EN.1
NT_N.EN.1 { @ Extension range from NT_N region beyond an NP OD region ^NT_N_EN_1 um ~ ^NT_N_EN_1b um 
  A = NTN_exc_ind INTERACT NPOD
  B = NPOD INTERACT NTN_exc_ind
  ENC B A < NT_N_EN_1 ABUT < 90 SINGULAR REGION
  B CUT A
  A NOT (SIZE B BY NT_N_EN_1b)
}
#ELSE



// NT_N.EN.1a is checked by NT_N.EN.1
// NT_N.EN.1b is checked by NT_N.EN.1
NT_N.EN.1 { @ Extension range from NT_N region beyond an NP OD region ^NT_N_EN_1 um ~ ^NT_N_EN_1b um 
  A = NTN INTERACT NPOD
  B = NPOD INTERACT NTN
  ENC B A < NT_N_EN_1 ABUT < 90 SINGULAR REGION
  B CUT A
  A NOT (SIZE B BY NT_N_EN_1b)
}
#ENDIF

#ENDIF


//NT_N.EX.1.S80 is checked by NT_N.EX.1
NT_N.EX.1 { @ PO extension on {OD inside NT_N}(PO endcap) >= ^NT_N_EX_1 um 
  ENC NTN_OD POLY < NT_N_EX_1 ABUT < 90 SINGULAR REGION
}
NT_N.R.1 { @ Overlap of {NW OR DNW} is not allowed
  NTN AND DNW
  NTN AND NWEL
}
NT_N.R.2 { @ P+ gate is not allowed in NT_N
  (NTN AND GATE_PP) NOT INDDMY
}
#IFDEF MSRF
NT_N.R.3 { @ Only one OD is allowed to be put in an NT_N region 
  A = NTN_exc_ind CUT DACT > 1
  A NOT INTERACT NCap_NTN
  B = A INTERACT NCap_NTN
  C = OD INTERACT B
  NCap_NTN NOT OD // OD of NMOS cap sould be exactly covered by NCapNTN
  C NOT NCap_NTN  // Mixture of NMOS cap and normal device is not allowed
  NCap_NTN NOT NTN // NCapNTN must be fully inside NTN 
  A INTERACT NSDc > 1 BY NET // all source and drain of all Nmos caps in the same NT_N must be connected together
}
#ELSE


NT_N.R.3 { @ Only one OD is allowed to be put in an NT_N region 
  A = NTN CUT DACT > 1
  A NOT INTERACT NCap_NTN
  B = A INTERACT NCap_NTN
  C = OD INTERACT B
  NCap_NTN NOT OD // OD of NMOS cap sould be exactly covered by NCapNTN
  C NOT NCap_NTN  // Mixture of NMOS cap and normal device is not allowed
  NCap_NTN NOT NTN // NCapNTN must be fully inside NTN 
  A INTERACT NSDc > 1 BY NET // all source and drain of all Nmos caps in the same NT_N must be connected together
}
#ENDIF




//THICK OXIDE CHECKS
//==================

OD2.W.1 { @ Width >= ^OD2_W_1 um
  INT OD_18 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD_25 < OD2_W_1 ABUT < 90 SINGULAR REGION
  INT OD_33 < OD2_W_1 ABUT < 90 SINGULAR REGION
}  
OD2.S.1 { @ Space >= ^OD2_S_1 um 
  EXT OD2 < OD2_S_1 ABUT < 90 SINGULAR REGION
}
OD2.S.2 { @ Space to {ACTIVE OR GATE} >= ^OD2_S_2 um 
  DACTG = DACT OR GATE
  EXT OD2 DACTG < OD2_S_2 ABUT < 90 SINGULAR REGION
}
OD2.S.3 { @ Space to 1.0V or 1.2V GATE >= ^OD2_S_3 um 
  A = OD_18 INSIDE EDGE DACT
  EXT A GATE_W < OD2_S_3 ABUT < 90 REGION
  B = OD_25 INSIDE EDGE DACT
  EXT B GATE_W < OD2_S_3 ABUT < 90 REGION
  C = OD_33 INSIDE EDGE DACT
  EXT C GATE_W < OD2_S_3 ABUT < 90 REGION
  GATE CUT OD2
}
OD2.S.4 { @ Space to NW. Space = 0 is allowed >= ^OD2_S_4 um 
  EXT OD_18 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD_25 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
  EXT OD_33 NWEL < OD2_S_4 ABUT < 90 > 0 SINGULAR REGION
}
OD2.S.5 { @ OD_18 overlap OD_33 is not allowed.
  OD_18 AND OD_33
// Spacing is checked by OD2.S.1
} 
OD2.EN.1 { @ Enclosure of 1.8V, 2.5V, or 3.3V Gate in S/D direction >= ^OD2_EN_1 um 
  ENC GATE_W OD_18 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
  ENC GATE_W OD_25 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
  ENC GATE_W OD_33 < OD2_EN_1 ABUT < 90 OPPOSITE REGION
}
OD2.EX.1 { @ NW extension on OD2. Extension = 0 is allowed >= ^OD2_EX_1 um 
  ENC OD_18 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD_25 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
  ENC OD_33 NWEL < OD2_EX_1 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.2 { @ Extension on NW. Extension = 0 is allowed >= ^OD2_EX_2 um 
  ENC NWEL OD_18 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD_25 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
  ENC NWEL OD_33 < OD2_EX_2 ABUT < 90 > 0 SINGULAR REGION
}
OD2.EX.3 { @ Extension on {ACTIVE OR Gate} >= ^OD2_EX_3 um 
   DACTG = DACT OR GATE 
   CHECK_EDGE_18 = ENC [DACTG] OD_18 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE_18 NOT COIN OUTSIDE EDGE DSTP
   CHECK_EDGE_25 = ENC [DACTG] OD_25 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE_25 NOT COIN OUTSIDE EDGE DSTP
   CHECK_EDGE_33 = ENC [DACTG] OD_33 < OD2_EX_3 ABUT < 90 SINGULAR
   CHECK_EDGE_33 NOT COIN OUTSIDE EDGE DSTP
   OD_18 INSIDE DACTG
   GATE CUT OD_18 
   OD_25 INSIDE DACTG
   GATE CUT OD_25   
   OD_33 INSIDE DACTG
   GATE CUT OD_33   
}
OD2.O.1 { @ Overlap of NW. Overlap = 0 is allowed >= ^OD2_O_1 um 
  X = OD_18 AND NWEL
  INT X < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Y = OD_25 AND NWEL
  INT Y < OD2_O_1 ABUT < 89.5 SINGULAR REGION
  Z = OD_33 AND NWEL
  INT Z < OD2_O_1 ABUT < 89.5 SINGULAR REGION
}
OD2.R.1 { @ OD_33 and OD_25 can't be used on same die. OD_18 and OD_25 can't be used on same die
  X = CHIP INTERACT OD_25
  X INTERACT OD_33
  X INTERACT OD_18
}



//PO CHECKS
//=========

18V_GATE_W   = HV_GATE_W INSIDE EDGE OD_18
25V_GATE_W   = HV_GATE_W INSIDE EDGE OD_25
33V_GATE_W   = HV_GATE_W INSIDE EDGE OD_33
POLY_EDGE_45 = POLY ANGLE == 45

PO.W.1 { @ Width >= ^PO_W_1 um 
  INT POLY < PO_W_1 ABUT < 90 SINGULAR REGION
}
//PO.W.2.S80 is checked by PO.W.2
PO.W.2 { @ Channel length of 2.5V MOS >= ^PO_W_2 um 
  INT 25V_GATE_W < PO_W_2 ABUT < 90 REGION
}
//PO.W.3.S80 is checked by PO.W.3
PO.W.3 { @ Channel length of 3.3 V MOS >= ^PO_W_3 um 
  INT 33V_GATE_W < PO_W_3 ABUT < 90 REGION
}
//PO.W.4.S80 is checked by PO.W.4
PO.W.4 { @ Channel length of 1.8 V MOS >= ^PO_W_4 um 
  INT 18V_GATE_W < PO_W_4 ABUT < 90 REGION
}
PO.W.5 { @ Width of 45-degree FIELD PO >= ^PO_W_5 um 
  INT POLY_EDGE_45 < PO_W_5 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// PO.W.5.R is checked by RR:PO.W.5
    RR:PO.W.5 { @ Width of 45 degree FIELD PO >= ^PO_W_5R um 
      INT POLY_EDGE_45 < PO_W_5R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF

PO.S.1 { @ Space >= ^PO_S_1 um 
  EXT POLY < PO_S_1 ABUT < 90 SINGULAR REGION
}
PO.S.2 { @ GATE space in the same OD >= ^PO_S_2 um. 
  EXT GATE_W < PO_S_2 ABUT < 90 REGION
  EXT GATE < PO_S_2 ABUT < 90 REGION CORNER TO CORNER
}
PO.S.3 { @ {GATE inside OD2} space in the same OD >= ^PO_S_3 um 
  EXT HV_GATE_W < PO_S_3 ABUT < 90 REGION
}
PO.S.4 { @ FIELD PO space to OD >= ^PO_S_4 um 
  EXT POLY OD < PO_S_4 ABUT < 89.5 SINGULAR REGION
}

S_GATE_W1 = LENGTH GATE_W < PO_S_5_W
EX_GATEW_EDGE = EXPAND EDGE S_GATE_W1 INSIDE BY GRID EXTEND BY OD_S_1
EX_GATEW_EDGE_T = EX_GATEW_EDGE COIN INSIDE EDGE POLY

PO.S.5 { @ Space to L-shape OD when PO and OD are in the same MOS [channel width (W) < 0.2 um] >= ^PO_S_5 um
  EXT OD EX_GATEW_EDGE_T < PO_S_5 ABUT < 90 OPPOSITE REGION
}

SU_GATE = GATE WITH EDGE S_GATE_W1	// Use the same setting of PO_S_5_W for PO_S_6_W
OD_GATE_EDGE = OD COIN INSIDE EDGE SU_GATE
EX_ODGATE_EDGE = EXPAND EDGE OD_GATE_EDGE INSIDE BY GRID EXTEND BY PO_S_1
EX_ODGATE_EDGE_T = OD COIN INSIDE EDGE EX_ODGATE_EDGE

PO.S.6 { @ L-shape PO space to OD when PO and OD are in the same MOS [channel width (W) < 0.2 um] >= ^PO_S_6 um 
  EXT POLY EX_ODGATE_EDGE_T < PO_S_6 ABUT < 90 OPPOSITE REGION
}
PO.S.7 { @ Space if at least one PO width is > 0.23 um, and the PO parallel run length is > 0.3 um >= ^PO_S_7 um
  Wide_POLY = (SIZE POLY BY PO_S_7_W /2 UNDEROVER TRUNCATE PO_S_7_W /2) AND POLY
  X = EXT Wide_POLY POLY < PO_S_7 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X PO_S_1 - GRID PO_S_7_L + GRID	
}  
PO.S.8 { @ Space to 45-degree FIELD PO >= ^PO_S_8 um 
  X = EXPAND EDGE POLY_EDGE_45 OUTSIDE BY PO_S_8
  X AND POLY
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
//PO.S.8.R is checked by RR:PO.S.8  
    RR:PO.S.8 { @ PO space to 45-degree FIELD PO >= 0.205
      X = EXPAND EDGE POLY_EDGE_45 OUTSIDE BY PO_S_8R
      X AND POLY
    }
  #ENDIF
#ENDIF

PO.S.9 { @ Space of {PO AND RPO} >= ^PO_S_9 um
  A = POLY INSIDE EDGE RPO
  EXT A < PO_S_9 ABUT < 90 REGION
}  
PO.EX.1 { @ Extension on OD (end-cap) >= ^PO_EX_1 um 
  ((ENC ODs POLYs < PO_EX_1 ABUT < 89.5 OPPOSITE SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE) NOT INSIDE LOGO
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// PO.EX.1.R is checked by RR:PO.EX.1  
    RR:PO.EX.1 { @ PO extension on OD (end-cap) >= ^PO_EX_1R um 
      (ENC ODs POLYs < PO_EX_1R ABUT < 89.5 OPPOSITE SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
    }
  #ENDIF
#ENDIF

PO.EX.2 { @ OD extension on PO >= ^PO_EX_2 um 
  (ENC POLY OD < PO_EX_2 ABUT < 89.5 SINGULAR REGION) NOT INSIDE LOGO
}
PO.EX.3 { @ Extension on OD (end-cap) when the PO space to L-shape OD (in the same MOS) is < 0.1 um, and the channel width (W) is >= 0.2 um >= ^PO_EX_3 um
  A = LENGTH GATE_W >= PO_EX_3_W
  B = EXPAND EDGE A INSIDE BY GRID EXTEND BY PO_EX_3
  C = EXPAND EDGE A OUTSIDE BY GRID EXTEND BY PO_EX_3 
  D = B COIN OUTSIDE EDGE C
  E = EXT D OD < PO_EX_3_S ABUT < 90 OPPOSITE REGION
  F = E COIN OUTSIDE EDGE FPO1
  G = EXPAND EDGE F OUTSIDE BY GRID
  H = GATE_L TOUCH OUTSIDE EDGE G
  I = EXPAND EDGE H OUTSIDE BY PO_EX_3
  J = I INTERACT E
  (J NOT POLY) NOT INSIDE LOGO
}  
PO.L.1 { @ Maximum PO length between 2 contacts without gate, as well as the length from any point inside PO gate to nearest CO, when the PO width is < 0.13 um except RTMOM region (RTMOMDMY, CAD layer:155;21) <= ^PO_L_1 um
  LONGP = AREA ILP1 > PO_W_1 * PO_L_1	
  X = LONGP INTERACT COPO
  CHECK_COPO = COPO INTERACT X
  A = SIZE CHECK_COPO BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  P2P = X INTERACT A > 1
  BAD = P2P NOT A
  BAD_EDGE = BAD COIN INSIDE EDGE POLY
  ERR = INT BAD_EDGE < PO_L_1_W ABUT < 90 REGION
  X1 = (X INTERACT ERR) NOT GATE
  CHECK_COPO1 = CHECK_COPO INTERACT X1
  A1 = SIZE CHECK_COPO1 BY PO_L_1 / 2 INSIDE OF X1 STEP PO_S_1*0.7
  P2P1 = X1 INTERACT A1 > 1
  BAD1 = (P2P1 NOT A1) INTERACT A1 > 1
  BAD_EDGE1 = BAD1 COIN INSIDE EDGE POLY
  ERR1 = INT BAD_EDGE1 < PO_L_1_W ABUT < 90 REGION
  (X1 INTERACT ERR1) NOT INTERACT RTMOMDMY
  NARROW_GATE = (GATE WITH EDGE (LENGTH GATE_L < PO_L_1_W)) AND X
  B = SIZE A BY PO_L_1 / 2 INSIDE OF X STEP PO_S_1*0.7
  (NARROW_GATE NOT B) NOT INTERACT RTMOMDMY
}  
PO.A.1 { @ Area >= ^PO_A_1 um2
  (AREA POLYs < PO_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE PO_A_2pre ((PO_A_2 + (PO_S_1 * PO_S_1 * 3.142))/(2 * PO_S_1))*((PO_A_2 + (PO_S_1 * PO_S_1 * 3.142))/(2 * PO_S_1))/3.141
PO.A.2 { @ Enclosed area >= ^PO_A_2 um2
  A = HOLES POLY INNER < PO_A_2pre
  B = A NOT POLY
  AREA B < PO_A_2
}
#IFDEF FULL_CHIP
// PO.DN.1 is checked by PO.DN.1:L
// PO.DN.1a is checked by PO.DN.1:L
PO.DN.1:L { @ Min. POLY density across full chip 14% 
  DENSITY ALL_POLY < 0.14 INSIDE OF LAYER CHIP PRINT PO.DN.1:L.density
}
// PO.DN.1 is checked by PO.DN.1:H
// PO.DN.1b is checked by PO.DN.1:H
PO.DN.1:H { @ Max. poly density across full chip 50%
  DENSITY ALL_POLY > 0.5 INSIDE OF LAYER CHIP PRINT PO.DN.1:H.density
}
#ENDIF
ALL_POD = ALL_OD OR ALL_POLY
PO.DN.2 { @ {OD OR DOD OR PO OR DPO } local density (minimun) over window 20um x 20um stepping 10um >= 0.1%

  ERR_WIN = DENSITY ALL_POD CHIP < 0.001 WINDOW 20 STEP 10 BACKUP
    [ AREA(ALL_POD)/AREA(CHIP) ]
  K = SIZE (ERR_WIN NOT PO_DEN_EXC) BY (5-0.002)/2 UNDEROVER TRUNCATE (5-0.002)/2
  DENSITY K ALL_POD CHIP < 0.001 WINDOW 20 STEP 10 BACKUP PRINT PO_DN_2.density 
    [ !AREA(K)+AREA(ALL_POD)/AREA(CHIP) ]
}
PO.R.1 { @ GATE must be a rectangle orthogonal to grid. (Bent GATE is not allowed) 
  ( NOT RECTANGLE GATE ORTHOGONAL ONLY ) NOT INSIDE LOGO
}

// PO.R.2U can not be checked by DRC

PO.R.3 { @ No cut-out corner of any size in PO at PO end-cap [PO end-cap < 0.18 um and channel length < 0.14 um]
  A = INT [GATE_W] < PO_R_3_W ABUT < 90 
  B = POLY WITH EDGE A
  BG = (GATE WITH EDGE A) COIN INSIDE EDGE OD
  C = ENC BG B < PO_R_3_E ABUT < 90 OPPOSITE REGION
  D = C INTERACT OD < 2
  NOT RECTANGLE D
  CE = ENC [BG] B < PO_R_3_E ABUT < 90 OPPOSITE
  X = EXPAND EDGE CE OUTSIDE BY PO_R_3_E
  Y = EXPAND EDGE (GATE_L TOUCH EDGE CE) OUTSIDE BY PO_R_3_E
  Z = (Y NOT X) INTERACT D
  BZ = B INTERACT Z  // poly with cut-out corner
  B1 = CONVEX EDGE BZ ANGLE1 == 90 ANGLE2 == 270 // cut-out corner
  P1 = LENGTH B1 < PO_W_1
  B2 = CONVEX EDGE BZ ANGLE1 == 90 ANGLE2 == 90  // end-cap
  P2 = LENGTH B2 < PO_R_3_W
  ZPE = EXT P1 < PO_W_1 ABUT == 90 INTERSECTING ONLY REGION
  ZPI = (INT P2 P1 < PO_R_3_W ABUT == 90 INTERSECTING ONLY REGION) AND Z
  (ZPE INTERACT ZPI) INTERACT D
}  
PO.R.4 { @ PO intersecting OD must form 2 or more diffusions except LOGO and RTMOM region (RTMOMDMY, CAD layer:155;21)
  GATEW = GATE INSIDE EDGE OD
  X = GATE NOT WITH EDGE GATEW == 2
  (X NOT LOGO) NOT RTMOMDMY
  Y = EXPAND EDGE GATEW BY 0.005
  Z = VERTEX Y > 4
  (Z NOT LOGO) NOT RTMOMDMY
}
GATEi  = POi AND ODi
GATEu  = STAMP GATEi BY POu
NSDu_g  = NSDu INTERACT POu 
PSDu_g  = PSDu INTERACT POu 
Float_GATE = NET AREA RATIO GATEu PSTPu NSTPu PSDu_g NSDu_g CBu CB2u UBMnu UBMdu COu > 0 
	[!AREA(PSTPu)*!AREA(NSTPu)*!AREA(PSDu_g)*!AREA(NSDu_g)*!AREA(CBu)*!AREA(CB2u)*!AREA(UBMnu)*!AREA(UBMdu)+!AREA(COu)]
Float_NSD = NET AREA RATIO NSDu_g PSDu_g GATEu PSTPu NSTPu CBu CB2u UBMnu UBMdu > 0
	[~(COUNT(NSDu_g)-1)*!AREA(PSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(CBu)*!AREA(CB2u)*!AREA(UBMnu)]
Float_PSD = NET AREA RATIO PSDu_g NSDu_g GATEu PSTPu NSTPu CBu CB2u UBMnu UBMdu > 0
	[~(COUNT(PSDu_g)-1)*!AREA(NSDu_g)*!AREA(GATEu)*!AREA(PSTPu)*!AREA(NSTPu)*!AREA(CBu)*!AREA(CB2u)*!AREA(UBMdu)]

effective_NSD = NSDu_g NOT Float_NSD
effective_PSD = PSDu_g NOT Float_PSD

Float_NSD_a = Float_NSD NOT ((SIZE (Float_NSD OR GATE) BY GRID) INTERACT effective_NSD > 1 BY NET)
Float_PSD_a = Float_PSD NOT ((SIZE (Float_PSD OR GATE) BY GRID) INTERACT effective_PSD > 1 BY NET)


Float_GATE_check = Float_GATE NOT INTERACT (Float_NSD_a OR Float_PSD_a) 


#IFDEF FULL_CHIP
PO.R.8 { @ It is prohibited for Floating Gate if the effective source/drain is not connected together 
  Float_GATE_check INTERACT NSDu > 1 BY NET
  Float_GATE_check INTERACT PSDu > 1 BY NET    
}
#ENDIF


//DUMMY POLY RULE
//================

DPO.W.1 { @ Width >= ^DPO_W_1 um
  INT DPO < DPO_W_1 ABUT < 90 SINGULAR REGION
}
DPO.S.1 { @ Space >= ^DPO_S_1 um
  EXT DPO < DPO_S_1 ABUT < 90 SINGULAR REGION
}
DPO.S.2 { @ Space to OD (Overlap is not allowed) >= ^DPO_S_2 um
  EXT ODi DPO < DPO_S_2 ABUT < 90 SINGULAR REGION
  ODi AND DPO
}
DPO.S.3 { @ Space to PO (Overlap is not allowed) >= ^DPO_S_3 um
  EXT POi DPO < DPO_S_3 ABUT < 90 SINGULAR REGION
  POi AND DPO
}
DPO.S.5 { @ Space to FW (Overlap is not allowed) >= ^DPO_S_5 um
  EXT FWi DPO < DPO_S_5 ABUT < 90 SINGULAR REGION
  FWi AND DPO
}
// DPO.S.6.0 is checked by either DPO.S.6 or DPO.S.6.1
// for solid L-mark (old)
DPO.S.6 { @ Space to LMARK (Overlap is not allowed) >= ^DPO_S_6 um
  EXT LMARK_SOLID DPO < DPO_S_6 ABUT < 90 SINGULAR REGION
  LMARK_SOLID AND DPO
}
// for hollow L-mark (new)
DPO.S.6.1 { @ Space to L-slot (Overlap is not allowed) >= ^DPO_S_6_1 um
  EXT LSLOT DPO < DPO_S_6_1 ABUT < 90 SINGULAR REGION
  LSLOT AND DPO
}
DPO.S.8 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DPO
}
DPO.S.9 { @ Space to INDDMY (Overlap is not allowed) >= ^DPO_S_9 um
  EXT INDDMY DPO < DPO_S_9 ABUT < 90 SINGULAR REGION
  INDDMY AND DPO
}


#IFDEF FULL_CHIP
DPO.EN.1 { @ Enclosure by chip edge >= ^DPO_EN_1 um
  DPO NOT (SIZE CHIP_CHAMFERED BY -DPO_EN_1)
}
DPO.R.1 { @ DPO is a must. DPO CAD layer (TSMC default, 17;1) must be a different layer from the PO CAD layer
  CHIP_CHAMFERED NOT INTERACT DPO
}
#ENDIF

// DPO.R.2 is checked by CSR.R.1:DPO

DPO.R.3 { @ Only square (or rectangular) and solid shpaes are allowed. 
  NOT RECTANGLE DPO
  HOLES DPO
}

//PSPO CHECKS
//============

#IFDEF LP
PSPO.EN.1 { @ Enclosure of gate >= ^PSPO_EN_1 um
  ENC GATE PSPOi < PSPO_EN_1 ABUT < 90 SINGULAR REGION
  GATE CUT PSPOi
}
PSPO.S.1 { @ Space to gate >= ^PSPO_S_1 um
  EXT PSPOi GATE < PSPO_S_1 ABUT < 90 SINGULAR REGION
}  
PSPO.R.1 { @ Overlap of VTH_N, VTH_P, NT_N, or OD2 is not allowed
  PSPOi AND VTHN
  PSPOi AND VTHP
  PSPOi AND NTN
  PSPOi AND OD2
}
#ENDIF


//VTH_N CHECKS
//============

VTHN_R = VTHNs WITH WIDTH >= VTH_N_R_2
// waive one track overlap 	  
VTHN_A1 = INT VTHNs < VTH_N_W_1 ABUT < 90 REGION PROJ==0
VTHN_B1 = VTHN_R NOT (EXPAND EDGE VTHN_R INSIDE BY VTH_N_R_3/2)	
VTHN_C1 = EXT VTHN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTHN_D1 = VTHN_A1 ENCLOSE VTHN_C1
// waive one track space
VTHN_A2 = EXT VTHNs < VTH_N_S_1 ABUT < 90 REGION PROJ==0
VTHN_B2 = VTHN_R OR (EXPAND EDGE VTHN_R OUTSIDE BY VTH_N_R_3/2)
VTHN_C2 = EXT VTHN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTHN_D2  = VTHN_A2 ENCLOSE VTHN_C2
// waive point touch
VTHN_P = EXT VTHN_R < VTH_N_S_1 SINGULAR INTERSECTING ONLY REGION

VTH_N.W.1 { @ Width >= ^VTH_N_W_1. One-track(^VTH_N_R_3) overlap is allowed [width>=^VTH_N_R_2] 
  X = INT VTHNs < VTH_N_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTHN_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.S.1 { @ Space >= ^VTH_N_S_1. Point touch of corners is allowed [width>=^VTH_N_R_2]. One-track(^VTH_N_R_3) space is allowed [width>=^VTH_N_R_2]
  X = EXT VTHNs < VTH_N_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTHN_D2 OR VTHN_P))) NOT INSIDE SRAM_EXCLUDE
}
VTH_N.S.2 { @ Space to gate >= ^VTH_N_S_2 um
  EXT VTHN GATE < VTH_N_S_2 ABUT < 90 SINGULAR REGION
} 
VTH_N.S.3 { @ Space to unsilicided PO/OD >= ^VTH_N_S_3 um
  EXT VTHN AYRE < VTH_N_S_3 ABUT < 90 SINGULAR
  AND VTHN AYRE    
}

VTH_N.EN.1 { @ Enclosure of gate >= ^VTH_N_EN_1 um
  ENC GATE VTHN < VTH_N_EN_1 ABUT < 90 SINGULAR REGION
  GATE CUT VTHN
}
VTH_N.A.1 { @ Area >= ^VTH_N_A_1 um
  (AREA VTHNs < VTH_N_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTH_N_A_2pre ((VTH_N_A_2 + (VTH_N_S_1 * VTH_N_S_1 * 3.142))/(2 * VTH_N_S_1))*((VTH_N_A_2 + (VTH_N_S_1 * VTH_N_S_1 * 3.142))/(2 * VTH_N_S_1))/3.141

VTH_N.A.2 { @ Enclosed area >= ^VTH_N_A_2 um 
  A = HOLES VTHN INNER < VTH_N_A_2pre
  B = A NOT VTHN
  AREA B < VTH_N_A_2
}

VTH_N.R.1 { @ Overlap of OD2, NTN, PACT or VTLN is not allowed.
  VTHN AND OD2
  VTHN AND NTN
  VTHN AND PACT
  VTHN AND VTLN
}
// VTH_N.R.2 and VTH_N.R.3 are checked by VTH_N.W.1 and VTH_N.S.1

//VTH_P CHECKS
//============

VTHP_R = VTHPs WITH WIDTH >= VTH_P_R_2
// waive one track overlap 	  
VTHP_A1 = INT VTHPs < VTH_P_W_1 ABUT < 90 REGION PROJ==0
VTHP_B1 = VTHP_R NOT (EXPAND EDGE VTHP_R INSIDE BY VTH_P_R_3/2)	
VTHP_C1 = EXT VTHP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTHP_D1 = VTHP_A1 ENCLOSE VTHP_C1
// waive one track space
VTHP_A2 = EXT VTHPs < VTH_P_S_1 ABUT < 90 REGION PROJ==0
VTHP_B2 = VTHP_R OR (EXPAND EDGE VTHP_R OUTSIDE BY VTH_P_R_3/2)
VTHP_C2 = EXT VTHP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTHP_D2  = VTHP_A2 ENCLOSE VTHP_C2
// waive point touch
VTHP_P = EXT VTHP_R < VTH_P_S_1 SINGULAR INTERSECTING ONLY REGION

VTH_P.W.1 { @ Width >= ^VTH_P_W_1. One-track(^VTH_P_R_3) overlap is allowed [width>=^VTH_P_R_2] 
  X = INT VTHPs < VTH_P_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTHP_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.S.1 { @ Space >= ^VTH_P_S_1. Point touch of corners is allowed [width>=^VTH_P_R_2]. One-track(^VTH_P_R_3) space is allowed [width>=^VTH_P_R_2]
  X = EXT VTHPs < VTH_P_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTHP_D2 OR VTHP_P))) NOT INSIDE SRAM_EXCLUDE
}
VTH_P.S.2 { @ Space to gate >= ^VTH_P_S_2 um
  EXT VTHP GATE < VTH_P_S_2 ABUT < 90 SINGULAR REGION
} 
VTH_P.S.3 { @ Space to unsilicided PO/OD >= ^VTH_P_S_3 um
  EXT VTHP AYRE < VTH_P_S_3 ABUT < 90 SINGULAR
  AND VTHP AYRE    
}

VTH_P.EN.1 { @ Enclosure of gate >= ^VTH_P_EN_1 um
  ENC GATE VTHP < VTH_P_EN_1 ABUT < 90 SINGULAR REGION
  GATE CUT VTHP
}
VTH_P.A.1 { @ Area >= ^VTH_P_A_1 um
  (AREA VTHPs < VTH_P_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTH_P_A_2pre ((VTH_P_A_2 + (VTH_P_S_1 * VTH_P_S_1 * 3.142))/(2 * VTH_P_S_1))*((VTH_P_A_2 + (VTH_P_S_1 * VTH_P_S_1 * 3.142))/(2 * VTH_P_S_1))/3.141

VTH_P.A.2 { @ Enclosed area >= ^VTH_P_A_2 um 
  A = HOLES VTHP INNER < VTH_P_A_2pre
  B = A NOT VTHP
  AREA B < VTH_P_A_2
}

VTH_P.R.1 { @ Overlap of OD2, NTN, NACT or VTLP is not allowed.
  VTHP AND OD2
  VTHP AND NTN
  VTHP AND NACT
  VTHP AND VTLP
}
// VTH_P.R.2 and VTH_P.R.3 are checked by VTH_P.W.1 and VTH_P.S.1


//VTL_N CHECKS
//============

VTLN_R = VTLNs WITH WIDTH >= VTL_N_R_2
// waive one track overlap 	  
VTLN_A1 = INT VTLNs < VTL_N_W_1 ABUT < 90 REGION PROJ==0
VTLN_B1 = VTLN_R NOT (EXPAND EDGE VTLN_R INSIDE BY VTL_N_R_3/2)	
VTLN_C1 = EXT VTLN_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTLN_D1 = VTLN_A1 ENCLOSE VTLN_C1
// waive one track space
VTLN_A2 = EXT VTLNs < VTL_N_S_1 ABUT < 90 REGION PROJ==0
VTLN_B2 = VTLN_R OR (EXPAND EDGE VTLN_R OUTSIDE BY VTL_N_R_3/2)
VTLN_C2 = EXT VTLN_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTLN_D2  = VTLN_A2 ENCLOSE VTLN_C2
// waive point touch
VTLN_P = EXT VTLN_R < VTL_N_S_1 SINGULAR INTERSECTING ONLY REGION

VTL_N.W.1 { @ Width >= ^VTL_N_W_1. One-track(^VTL_N_R_3) overlap is allowed [width>=^VTL_N_R_2] 
  X = INT VTLNs < VTL_N_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTLN_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.S.1 { @ Space >= ^VTL_N_S_1. Point touch of corners is allowed [width>=^VTL_N_R_2]. One-track(^VTL_N_R_3) space is allowed [width>=^VTL_N_R_2]
  X = EXT VTLNs < VTL_N_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTLN_D2 OR VTLN_P))) NOT INSIDE SRAM_EXCLUDE
}
VTL_N.S.2 { @ Space to gate >= ^VTL_N_S_2 um
  EXT VTLN GATE < VTL_N_S_2 ABUT < 90 SINGULAR REGION
} 
VTL_N.S.3 { @ Space to unsilicided PO/OD >= ^VTL_N_S_3 um
  EXT VTLN AYRE < VTL_N_S_3 ABUT < 90 SINGULAR
  AND VTLN AYRE    
}

VTL_N.EN.1 { @ Enclosure of gate >= ^VTL_N_EN_1 um
  ENC GATE VTLN < VTL_N_EN_1 ABUT < 90 SINGULAR REGION
  GATE CUT VTLN
}
VTL_N.A.1 { @ Area >= ^VTL_N_A_1 um
  (AREA VTLNs < VTL_N_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTL_N_A_2pre ((VTL_N_A_2 + (VTL_N_S_1 * VTL_N_S_1 * 3.142))/(2 * VTL_N_S_1))*((VTL_N_A_2 + (VTL_N_S_1 * VTL_N_S_1 * 3.142))/(2 * VTL_N_S_1))/3.141

VTL_N.A.2 { @ Enclosed area >= ^VTL_N_A_2 um 
  A = HOLES VTLN INNER < VTL_N_A_2pre
  B = A NOT VTLN
  AREA B < VTL_N_A_2
}

VTL_N.R.1 { @ Overlap of OD2, NTN, PACT or VTHN is not allowed.
  VTLN AND OD2
  VTLN AND NTN
  VTLN AND PACT
  VTLN AND VTHN
}
// VTL_N.R.2 and VTL_N.R.3 are checked by VTL_N.W.1 and VTL_N.S.1

//VTL_P CHECKS
//============

VTLP_R = VTLPs WITH WIDTH >= VTL_P_R_2
// waive one track overlap 	  
VTLP_A1 = INT VTLPs < VTL_P_W_1 ABUT < 90 REGION PROJ==0
VTLP_B1 = VTLP_R NOT (EXPAND EDGE VTLP_R INSIDE BY VTL_P_R_3/2)	
VTLP_C1 = EXT VTLP_B1 < GRID SINGULAR INTERSECTING ONLY REGION
VTLP_D1 = VTLP_A1 ENCLOSE VTLP_C1
// waive one track space
VTLP_A2 = EXT VTLPs < VTL_P_S_1 ABUT < 90 REGION PROJ==0
VTLP_B2 = VTLP_R OR (EXPAND EDGE VTLP_R OUTSIDE BY VTL_P_R_3/2)
VTLP_C2 = EXT VTLP_B2 < GRID SINGULAR INTERSECTING ONLY REGION
VTLP_D2  = VTLP_A2 ENCLOSE VTLP_C2
// waive point touch
VTLP_P = EXT VTLP_R < VTL_P_S_1 SINGULAR INTERSECTING ONLY REGION

VTL_P.W.1 { @ Width >= ^VTL_P_W_1. One-track(^VTL_P_R_3) overlap is allowed [width>=^VTL_P_R_2] 
  X = INT VTLPs < VTL_P_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT VTLP_D1)) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.S.1 { @ Space >= ^VTL_P_S_1. Point touch of corners is allowed [width>=^VTL_P_R_2]. One-track(^VTL_P_R_3) space is allowed [width>=^VTL_P_R_2]
  X = EXT VTLPs < VTL_P_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (VTLP_D2 OR VTLP_P))) NOT INSIDE SRAM_EXCLUDE
}
VTL_P.S.2 { @ Space to gate >= ^VTL_P_S_2 um
  EXT VTLP GATE < VTL_P_S_2 ABUT < 90 SINGULAR REGION
} 
VTL_P.S.3 { @ Space to unsilicided PO/OD >= ^VTL_P_S_3 um
  EXT VTLP AYRE < VTL_P_S_3 ABUT < 90 SINGULAR
  AND VTLP AYRE    
}

VTL_P.EN.1 { @ Enclosure of gate >= ^VTL_P_EN_1 um
  ENC GATE VTLP < VTL_P_EN_1 ABUT < 90 SINGULAR REGION
  GATE CUT VTLP
}
VTL_P.A.1 { @ Area >= ^VTL_P_A_1 um
  (AREA VTLPs < VTL_P_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE VTL_P_A_2pre ((VTL_P_A_2 + (VTL_P_S_1 * VTL_P_S_1 * 3.142))/(2 * VTL_P_S_1))*((VTL_P_A_2 + (VTL_P_S_1 * VTL_P_S_1 * 3.142))/(2 * VTL_P_S_1))/3.141

VTL_P.A.2 { @ Enclosed area >= ^VTL_P_A_2 um 
  A = HOLES VTLP INNER < VTL_P_A_2pre
  B = A NOT VTLP
  AREA B < VTL_P_A_2
}

VTL_P.R.1 { @ Overlap of OD2, NTN, NACT or VTHP is not allowed.
  VTLP AND OD2
  VTLP AND NTN
  VTLP AND NACT
  VTLP AND VTHP
}
// VTL_P.R.2 and VTL_P.R.3 are checked by VTL_P.W.1 and VTL_P.S.1

//VTUH_N, VTUH_P WARNING
//==============

VTUH_N:WARNING1 { @ WARNING: Layer VTUH_N should not exist!
    COPY VTUH_Ni
}	
VTUH_P:WARNING1 { @ WARNING: Layer VTUH_P should not exist! 
    COPY VTUH_Pi
}

//ULVT_N, ULVT_P CHECKS
//============
#IFDEF N80
ULVT:WARNING1 { @ Please turn off N80 switch when using ULVT DRC.
  COPY ULVT_Ni
  COPY ULVT_Pi
}
#ENDIF // N80
#IFDEF LP
ULVT_N_R = ULVT_Ns WITH WIDTH >= ULVT_N_R_2
// waive one track overlap 	  
ULVT_N_A1 = INT ULVT_Ns < ULVT_N_W_1 ABUT < 90 REGION PROJ==0
ULVT_N_B1 = ULVT_N_R NOT (EXPAND EDGE ULVT_N_R INSIDE BY ULVT_N_R_3/2)	
ULVT_N_C1 = EXT ULVT_N_B1 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_N_D1 = ULVT_N_A1 ENCLOSE ULVT_N_C1
// waive one track space
ULVT_N_A2 = EXT ULVT_Ns < ULVT_N_S_1 ABUT < 90 REGION PROJ==0
ULVT_N_B2 = ULVT_N_R OR (EXPAND EDGE ULVT_N_R OUTSIDE BY ULVT_N_R_3/2)
ULVT_N_C2 = EXT ULVT_N_B2 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_N_D2  = ULVT_N_A2 ENCLOSE ULVT_N_C2
// waive point touch
ULVT_N_P = EXT ULVT_N_R < ULVT_N_S_1 SINGULAR INTERSECTING ONLY REGION

ULVT_N.W.1 { @ Width >= ^ULVT_N_W_1. One-track(^ULVT_N_R_3) overlap is allowed [width>=^ULVT_N_R_2] 
  X = INT ULVT_Ns < ULVT_N_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT ULVT_N_D1)) NOT INSIDE SRAM_EXCLUDE
}
ULVT_N.S.1 { @ Space >= ^ULVT_N_S_1. Point touch of corners is allowed [width>=^ULVT_N_R_2]. One-track(^ULVT_N_R_3) space is allowed [width>=^ULVT_N_R_2]
  X = EXT ULVT_Ns < ULVT_N_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (ULVT_N_D2 OR ULVT_N_P))) NOT INSIDE SRAM_EXCLUDE
}
ULVT_N.S.2 { @ Space to gate >= ^ULVT_N_S_2 um
  EXT ULVT_N GATE < ULVT_N_S_2 ABUT < 90 SINGULAR REGION
} 
ULVT_N.S.3 { @ Space to unsilicided PO/OD >= ^ULVT_N_S_3 um
  EXT ULVT_N AYRE < ULVT_N_S_3 ABUT < 90 SINGULAR
  AND ULVT_N AYRE    
}

ULVT_N.EN.1 { @ Enclosure of gate >= ^ULVT_N_EN_1 um
  ENC GATE ULVT_N < ULVT_N_EN_1 ABUT < 90 SINGULAR REGION
  GATE CUT ULVT_N
}
ULVT_N.A.1 { @ Area >= ^ULVT_N_A_1 um
  (AREA ULVT_Ns < ULVT_N_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE ULVT_N_A_2pre ((ULVT_N_A_2 + (ULVT_N_S_1 * ULVT_N_S_1 * 3.142))/(2 * ULVT_N_S_1))*((ULVT_N_A_2 + (ULVT_N_S_1 * ULVT_N_S_1 * 3.142))/(2 * ULVT_N_S_1))/3.141

ULVT_N.A.2 { @ Enclosed area >= ^ULVT_N_A_2 um 
  A = HOLES ULVT_N INNER < ULVT_N_A_2pre
  B = A NOT ULVT_N
  AREA B < ULVT_N_A_2
}

ULVT_N.R.1 { @ Overlap of OD2, NTN, PACT or VTHN is not allowed.
  ULVT_N AND OD2
  ULVT_N AND NTN
  ULVT_N AND PACT
  ULVT_N AND VTHN
}
// ULVT_N.R.2 and ULVT_N.R.3 are checked by ULVT_N.W.1 and ULVT_N.S.1
ULVT_N.R.4 { @ ULVT_N AND GATE must inside PSPO
  A = ULVT_N AND GATE
  A NOT PSPOi  
}
ULVT_P_R = ULVT_Ps WITH WIDTH >= ULVT_P_R_2
// waive one track overlap 	  
ULVT_P_A1 = INT ULVT_Ps < ULVT_P_W_1 ABUT < 90 REGION PROJ==0
ULVT_P_B1 = ULVT_P_R NOT (EXPAND EDGE ULVT_P_R INSIDE BY ULVT_P_R_3/2)	
ULVT_P_C1 = EXT ULVT_P_B1 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_P_D1 = ULVT_P_A1 ENCLOSE ULVT_P_C1
// waive one track space
ULVT_P_A2 = EXT ULVT_Ps < ULVT_P_S_1 ABUT < 90 REGION PROJ==0
ULVT_P_B2 = ULVT_P_R OR (EXPAND EDGE ULVT_P_R OUTSIDE BY ULVT_P_R_3/2)
ULVT_P_C2 = EXT ULVT_P_B2 < GRID SINGULAR INTERSECTING ONLY REGION
ULVT_P_D2  = ULVT_P_A2 ENCLOSE ULVT_P_C2
// waive point touch
ULVT_P_P = EXT ULVT_P_R < ULVT_P_S_1 SINGULAR INTERSECTING ONLY REGION

ULVT_P.W.1 { @ Width >= ^ULVT_P_W_1. One-track(^ULVT_P_R_3) overlap is allowed [width>=^ULVT_P_R_2] 
  X = INT ULVT_Ps < ULVT_P_W_1 ABUT < 90 REGION
  (X INTERACT (X NOT ULVT_P_D1)) NOT INSIDE SRAM_EXCLUDE
}
ULVT_P.S.1 { @ Space >= ^ULVT_P_S_1. Point touch of corners is allowed [width>=^ULVT_P_R_2]. One-track(^ULVT_P_R_3) space is allowed [width>=^ULVT_P_R_2]
  X = EXT ULVT_Ps < ULVT_P_S_1 ABUT < 90 REGION SINGULAR
  (X INTERACT (X NOT (ULVT_P_D2 OR ULVT_P_P))) NOT INSIDE SRAM_EXCLUDE
}
ULVT_P.S.2 { @ Space to gate >= ^ULVT_P_S_2 um
  EXT ULVT_P GATE < ULVT_P_S_2 ABUT < 90 SINGULAR REGION
} 
ULVT_P.S.3 { @ Space to unsilicided PO/OD >= ^ULVT_P_S_3 um
  EXT ULVT_P AYRE < ULVT_P_S_3 ABUT < 90 SINGULAR
  AND ULVT_P AYRE    
}

ULVT_P.EN.1 { @ Enclosure of gate >= ^ULVT_P_EN_1 um
  ENC GATE ULVT_P < ULVT_P_EN_1 ABUT < 90 SINGULAR REGION
  GATE CUT ULVT_P
}
ULVT_P.A.1 { @ Area >= ^ULVT_P_A_1 um
  (AREA ULVT_Ps < ULVT_P_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE ULVT_P_A_2pre ((ULVT_P_A_2 + (ULVT_P_S_1 * ULVT_P_S_1 * 3.142))/(2 * ULVT_P_S_1))*((ULVT_P_A_2 + (ULVT_P_S_1 * ULVT_P_S_1 * 3.142))/(2 * ULVT_P_S_1))/3.141

ULVT_P.A.2 { @ Enclosed area >= ^ULVT_P_A_2 um 
  A = HOLES ULVT_P INNER < ULVT_P_A_2pre
  B = A NOT ULVT_P
  AREA B < ULVT_P_A_2
}

ULVT_P.R.1 { @ Overlap of OD2, NTN, NACT or VTHP is not allowed.
  ULVT_P AND OD2
  ULVT_P AND NTN
  ULVT_P AND NACT
  ULVT_P AND VTHP
}
// ULVT_P.R.2 and ULVT_P.R.3 are checked by ULVT_P.W.1 and ULVT_P.S.1
ULVT_P.R.4 { @ ULVT_P AND GATE must inside PSPO
  A = ULVT_P AND GATE
  A NOT PSPOi  
}
#ENDIF // LP


//PP CHECKS
//=========

PP_CORE  = ((PP NOT CSRDMY) NOT SR_EDGE) NOT INSIDE SRCSR
IMP1     = NP OR PP_CORE
ODIMP1   = OD COINCIDENT INSIDE EDGE IMP1 
PP_BEDGE = PP INSIDE EDGE OD   

PP.W.1 { @ Width >= ^PP_W_1 um 
  (INT PP < PP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
PP.S.1 { @ Space >= ^PP_S_1 um 
  (EXT PP < PP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
PP.S.2 { @ Space to N+ACTIVE (non-butted) >= ^PP_S_2 um 
  EXT PP NACT < PP_S_2 ABUT < 90 > 0 SINGULAR REGION
  X = EXT PP [NACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}

// PP.S.3 is checked by PP.S.2 and PP.R.2

PP.S.4 { @ Space to NW STRAP (non-butted) >= ^PP_S_4 um 
  EXT PP NSTP < PP_S_4 ABUT < 90 > 0 SINGULAR REGION
  X = EXT PP [NSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
}
PP.S.5 { @ {PP edge on OD} space to NMOS GATE >= ^PP_S_5 um 
  EXT GATEN_W PP_BEDGE < PP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEN = EXPAND EDGE GATEN_W OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J

PP.S.6 { @ Butted PW STRAP space to PO in the same OD [the butted N+ ACTIVE extending 0 < J1 < 0.22 um] >= ^PP_S_6 um 
  A = EX_GATEN AND BUTT_PSTP
  B = EX_GATEN AND NACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEN_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY PP_S_6 EXTEND BY PP_S_6_J
  C AND F
}
PP.S.7 { @ Space to N-type unsilicided OD/PO >= ^PP_S_7 um 
  EXT PP NYRE < PP_S_7 ABUT < 90 SINGULAR REGION
}
PP.EN.1 { @ {NP OR PP} enclosure of PO (except DPO/LOGO) >= ^PP_EN_1 um 
  (ENC POLY IMP < PP_EN_1 ABUT < 90 SINGULAR REGION) NOT INSIDE LOGO
  ((POLY NOT SRAM_EXCLUDE) NOT LOGO) NOT IMP
}
PP.EX.1 { @ Extension on P+ACTIVE (except SBDDMY region) >= ^PP_EX_1 um
  (ENC PACT PP_CORE < PP_EX_1 ABUT < 90 > 0 SINGULAR REGION ) NOT INSIDE SBDDMY
  X = ENC [PACT] PP_CORE < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  (Y NOT INTERACT NPOD) NOT INSIDE SBDDMY
  ((EXPAND EDGE ODIMP1 INSIDE BY 0.001) AND PACT) NOT INSIDE SBDDMY
}
PP.EX.2 { @ Extension on PW STRAP	>=	^PP_EX_2 um
  ENC PSTP PP_CORE < PP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [PSTP] PP_CORE < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
  (EXPAND EDGE ODIMP1 INSIDE BY 0.001) AND PSTP
}
PP.EX.3 { @ Extension on P-type unsilicided OD/PO >= ^PP_EX_3 um 
  ENC AYRE PP < PP_EX_3 ABUT < 90 SINGULAR
}
PP.EX.4 { @ {PP edge on OD} extension on PMOS GATE >= ^PP_EX_4 um 
  ENC GATEP_W PP_BEDGE < PP_EX_4 ABUT < 90 OPPOSITE REGION
}
PP.O.1 { @ Overlap of OD >= ^PP_O_1 um 
  INT OD PP < PP_O_1 ABUT < 90 > 0 SINGULAR REGION
}
PP.A.1 { @ Area >= ^PP_A_1 um2
  AREA PP < PP_A_1
}

VARIABLE PP_A_2pre ((PP_A_2 + (PP_S_1 * PP_S_1 * 3.142))/(2 * PP_S_1))*((PP_A_2 + (PP_S_1 * PP_S_1 * 3.142))/(2 * PP_S_1))/3.141

PP.A.2 { @ Enclosed area >= ^PP_A_2 um2
  A = HOLES PP INNER < PP_A_2pre
  B = A NOT PP
  (AREA B < PP_A_2) NOT INSIDE SRAM_EXCLUDE
}


PP.A.3 { @ Area of butted PW STRAP >= ^PP_A_3 um2
  AREA BUTT_PSTP < PP_A_3
}  

EXGATE_PP = SIZE GATE_PP BY PP_R_1

PP.R.1 { @ PP must fully cover {PMOS GATE SIZING 0.22 um} >= ^PP_R_1 um
  EXGATE_PP NOT PP
}
PP.R.2 { @ Overlap of NP is not allowed 
  PP AND NP
}

// PP.R.3 is checked by OD.R.1



//NP CHECKS
//=========

NP_BEDGE = NP INSIDE EDGE OD   

NP.W.1 { @ Width >= ^NP_W_1 um 
  (INT NP < NP_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NP.S.1 { @ Space >= ^NP_S_1 um 
  (EXT NP < NP_S_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
NP.S.2 { @ Space to P+ACTIVE (non-butted) >= ^NP_S_2 um 
  EXT NP PACT < NP_S_2 ABUT < 90 > 0 SINGULAR REGION
  X = EXT NP [PACT] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}
// NP.S.3 is checked by NP.S.2 and PP.R.2

NP.S.4 { @ Space to PW STRAP (non-butted) >= ^NP_S_4 um 
  EXT NP PSTP < NP_S_4 ABUT < 90 > 0 SINGULAR REGION
  X = EXT NP [PSTP] < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT NPOD
}
NP.S.5 { @ {NP edge on OD} space to PMOS GATE >= ^NP_S_5 um 
  EXT GATEP_W NP_BEDGE < NP_S_5 ABUT < 90 OPPOSITE REGION
}

EX_GATEP = EXPAND EDGE GATEP_W OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J

NP.S.6 { @ Butted NW STRAP space to PO in the same OD [the butted P+ ACTIVE extending 0 < J1 < 0.22 um] >= ^NP_S_6 um
  A = EX_GATEP AND BUTT_NSTP
  B = EX_GATEP AND PACT
  C = A INTERACT B
  D = SD INTERACT C
  E = GATEP_W COIN OUTSIDE EDGE D
  F = EXPAND EDGE E OUTSIDE BY NP_S_6 EXTEND BY NP_S_6_J
  C AND F
}
NP.S.7 { @ Space to P-type unsilicided OD/PO >= ^NP_S_7 um 
  EXT NP PYRE < NP_S_7 ABUT < 90 SINGULAR REGION
}

// NP.EN.1 is checked by PP.EN.1

NP.EX.1 { @ Extension on N+ACTIVE >= ^NP_EX_1 um 
  A = NACT NOT ODWR
  ENC A NP < NP_EX_1 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [A] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
  (EXPAND EDGE ODIMP1 INSIDE BY 0.001) AND NACT
}
NP.EX.2 { @ Extension on NW STRAP >= ^NP_EX_2 um 
  ENC NSTP NP < NP_EX_2 ABUT < 90 > 0 SINGULAR REGION
  X = ENC [NSTP] NP < 0.001 ABUT == 0
  Y = EXPAND EDGE X OUTSIDE BY 0.001
  Y NOT INTERACT PPOD
  (EXPAND EDGE ODIMP1 INSIDE BY 0.001) AND NSTP
}
NP.EX.3 { @ Extension on N-type unsilicided OD/PO >= ^NP_EX_3 um 
  ENC AYRE NP < NP_EX_3 ABUT < 90 SINGULAR REGION
}
NP.EX.4 { @ {NP edge on OD} extension on NMOS GATE >= ^NP_EX_4 um 
  ENC GATEN_W NP_BEDGE < NP_EX_4 ABUT < 90 OPPOSITE REGION
}
NP.O.1 { @ Overlap of OD >= ^NP_O_1 um 
  INT OD NP < NP_O_1  ABUT < 90 > 0 SINGULAR REGION
}
NP.A.1 { @ Area >= ^NP_A_1 um2
  AREA NP < NP_A_1
}

VARIABLE NP_A_2pre ((NP_A_2 + (NP_S_1 * NP_S_1 * 3.142))/(2 * NP_S_1))*((NP_A_2 + (NP_S_1 * NP_S_1 * 3.142))/(2 * NP_S_1))/3.141
NP.A.2 { @ Enclosed area >= ^NP_A_2 um2
  A = HOLES NP INNER < NP_A_2pre 
  B = A NOT NP
  (AREA B < NP_A_2) NOT INSIDE SRAM_EXCLUDE
}




NP.A.3 { @ Area of butted NW STRAP >= ^NP_A_3 um
  AREA BUTT_NSTP < NP_A_3
}  

EXGATE_NP = SIZE GATE_NP BY NP_R_1

NP.R.1 { @ NP must fully cover {NMOS GATE SIZING 0.22 um} >= ^NP_R_1 um
  EXGATE_NP NOT NP
}

// NP.R.2 is checked by PP.R.2
// NP.R.3 is checked by OD.R.1



//LOGICAL OPERATION RULE
//======================

VARIABLE  VTCN_SU     0.27
VARIABLE  VTCN_SD     0.54
VARIABLE  NLDDN1V_SU  0.11
VARIABLE  NLDDN1V_SD  0.22
VARIABLE  NLDDN2V_SU  0.11
VARIABLE  NLDDN2V_SD  0.22
VARIABLE  VTLN_SU     0.11
VARIABLE  VTLN_SD     0.22
VARIABLE  PLDDP1V_SU  0.11
VARIABLE  PLDDP1V_SD  0.22
VARIABLE  PLDDP2V_SU  0.11
VARIABLE  PLDDP2V_SD  0.22
VARIABLE  VTLP_SU     0.11
VARIABLE  VTLP_SD     0.22

VTLND = SIZE VTLN BY -0.06
VTLPD = SIZE VTLP BY -0.06


VTC_N = SIZE (SIZE (SIZE (SRM NOT NWi) BY VTCN_SU) BY -VTCN_SD) BY VTCN_SU

NP_NOT_NW = NP NOT NWEL
NLDDN1 = ((NP_NOT_NW NOT OD2) NOT RH) NOT VAR
NLDDN1V = SIZE (SIZE (SIZE NLDDN1 BY NLDDN1V_SU) BY -NLDDN1V_SD) BY NLDDN1V_SU

NLDDN2 = ((NP_NOT_NW AND OD2) NOT RH) NOT VAR
NLDDN2V = SIZE (SIZE (SIZE NLDDN2 BY NLDDN2V_SU) BY -NLDDN2V_SD) BY NLDDN2V_SU

VTL_N_LD = SIZE (SIZE (SIZE ((OD2 OR NWEL) OR VTLND) BY VTLN_SU) BY -VTLN_SD) BY VTLN_SU

PP_AND_NW = PP AND NWEL
PLDDP1 = ((PP_AND_NW NOT OD2) NOT RH) NOT VAR
PLDDP1V = SIZE (SIZE (SIZE PLDDP1 BY PLDDP1V_SU) BY -PLDDP1V_SD) BY PLDDP1V_SU
PLDDP2 = ((PP_AND_NW AND OD2) NOT RH) NOT VAR
PLDDP2V = SIZE (SIZE (SIZE PLDDP2 BY PLDDP2V_SU) BY -PLDDP2V_SD) BY PLDDP2V_SU

VTL_P_LD = SIZE (SIZE (SIZE ((NWEL NOT OD2) NOT VTLPD) BY VTLP_SU) BY -VTLP_SD) BY VTLP_SU

LDN.EX.1 { @ NP extension on OD2/NW/RH/VAR ^LDN_EX_1 um. 
  A = INT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN1V < LDN_EX_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.2 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.2 LDN_EX_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN1V < LDN_EX_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
LDN.O.1 { @ NP overlap of OD2/NW/RH/VAR ^LDN_O_1 um. 
  A = INT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  B = EXT NLDDN2V < LDN_O_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.2 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.2 LDN_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT NLDDN2V < LDN_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDN.EX.2 is checked by LDN.EX.1
// LDN.EX.3 is checked by LDN.EX.1 and LDN.O.1
// LDN.EX.4 is checked by LDN.EX.1 and LDN.O.1

LDP.EX.1 { @ PP extension on OD2/NW/RH/VAR ^LDP_EX_2 um. 
  A = INT PLDDP1V < LDP_EX_2 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP1V < LDP_EX_2 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.2 LDP_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.2 LDP_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP1V < LDP_EX_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP1V < LDP_EX_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP1V < LDP_EX_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDP.EX.2 is checked by LDP.EX.1
// LDP.EX.3 is checked by LDP.EX.1

LDP.O.1 { @ PP overlap of OD2/NW/RH/VAR ^LDP_O_1 um. 
  A = INT PLDDP2V < LDP_O_1 ABUT < 90 OPPOSITE REGION
  B = EXT PLDDP2V < LDP_O_1 ABUT < 90 OPPOSITE REGION
  (NOT ENCLOSE RECTANGLE A 0.2 LDP_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.2 LDP_O_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT PLDDP2V < LDP_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT PLDDP2V < LDP_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT PLDDP2V < LDP_O_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}

// LDP.O.2 is checked by LDP.O.1

VT.S.1 { @ VTL_ND space to {OD2 OR NW} >= ^VT_S_1 um.
  A = INT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION
  B_1 = (EXT VTL_N_LD < VT_S_1 ABUT < 90 OPPOSITE REGION) NOT VTLN_D1  
  B = B_1 NOT INTERACT VTLN_P
  (NOT ENCLOSE RECTANGLE A 0.2 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.2 VT_S_1 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (INT VTL_N_LD < VT_S_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE  
  (INT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  C = (EXT VTL_N_LD < VT_S_1 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  C NOT INTERACT VTLN_P
  (EXT VTL_N_LD < VT_S_1 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}
VT.EX.2 { @ NW extension on {OD2 OR VTL_PD} >= >= ^VT_EX_2 um. 
  A = INT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION
  B = (EXT VTL_P_LD < VT_EX_2 ABUT < 90 OPPOSITE REGION) NOT VTLP_D1
  (NOT ENCLOSE RECTANGLE A 0.2 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  (NOT ENCLOSE RECTANGLE B 0.2 VT_EX_2 ORTHOGONAL ONLY) NOT INSIDE SRAM_EXCLUDE
  C = (INT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  C NOT INTERACT VTLP_P
  (INT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTL_P_LD < VT_EX_2 ABUT < 90 CORNER SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE 
  (EXT VTL_P_LD < VT_EX_2 ABUT < 90 PROJ == 0 REGION) NOT INSIDE SRAM_EXCLUDE
}



//RPO CHECKS
//==========

NOGT       = GATE NOT SDI
FPO1A      = (FPO1 NOT ESD1DMY) NOT ESD2DMY
Wide_RPO   = RPO INTERACT (SIZE RPO BY - RPO_EX_3_W /2)

RPO.W.1 { @ Width >= ^RPO_W_1 um 
  INT RPO < RPO_W_1 ABUT < 90 SINGULAR REGION
}
RPO.S.1 { @ Space >= ^RPO_S_1 um 
  EXT RPO < RPO_S_1 ABUT < 90 SINGULAR REGION
}
RPO.S.2 { @ Space to OD >= ^RPO_S_2 um 
  EXT RPO OD < RPO_S_2 ABUT < 90 SINGULAR REGION
}
RPO.S.3 { @ Space to CO (overlap of CO is not allowed.) >= ^RPO_S_3 um 
  EXT RPO CO < RPO_S_3 ABUT < 90 SINGULAR REGION
  RPO AND CO
}
RPO.S.4 { @ Space to GATE (overlap of GATE is not allowed except ESD circuit.) >= ^RPO_S_4 um 
  EXT RPO NOGT < RPO_S_4 ABUT < 90 SINGULAR REGION
  RPO AND NOGT
}
RPO.S.5 { @ Space to PO >= ^RPO_S_5 um 
  EXT RPO FPO1 < RPO_S_5 ABUT < 90 SINGULAR REGION
}
RPO.EX.1 { @ Extension on unsilicided OD/PO >= ^RPO_EX_1 um 
  ENC OD RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  ENC FPO1A RPO < RPO_EX_1 ABUT < 90 SINGULAR REGION
  RPO INSIDE OD
  RPO INSIDE FPO1A
}
RPO.EX.2 { @ OD extension on RPO >= ^RPO_EX_2 um 
  ENC RPO OD < RPO_EX_2 ABUT < 90 SINGULAR REGION
}
RPO.EX.3 { @ Extension on unsilicided OD/PO [RPO both width and length > 10um]	>= ^RPO_EX_3 um
  ENC OD Wide_RPO < RPO_EX_3 ABUT < 90 SINGULAR REGION
  ENC FPO1A Wide_RPO < RPO_EX_3 ABUT < 90 SINGULAR REGION
}
RPO.A.1 { @ Area >= ^RPO_A_1 um*um 
  (AREA RPOs < RPO_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE RPO_A_2pre ((RPO_A_2 + (RPO_S_1 * RPO_S_1 * 3.142))/(2 * RPO_S_1))*((RPO_A_2 + (RPO_S_1 * RPO_S_1 * 3.142))/(2 * RPO_S_1))/3.141
RPO.A.2 { @ Enclosed area >= ^RPO_A_2 um2
  A = HOLES RPO INNER < RPO_A_2pre 
  B = A NOT RPO
  AREA B < RPO_A_2
}  


RPO.R.1 { @ Butted NP/PP on unsilicided OD/PO is not allowed
  X = (RPO AND POLY) OR (RPO AND OD)
  NX = X AND NP
  PX = X AND PP    
  Y  = NX INTERACT PX
  X INTERACT Y
}  


#IFDEF GUIDELINE_RES
// RES.2g is checked by RES.2g:OD
RES.2g:OD { @ Recommended width >= 0.4um and length >= 0.8um for unsilicided OD resistor
  INT ODRES < RES_2G_OD_W ABUT < 90 SINGULAR REGION
  RES_L = ODRES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_2G_OD_L
  CHECK_RES = ODRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_2G_OD_L/2 - GRID*2) INSIDE OF ODRES STEP OD_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
// RES.2g is checked by RES.2g:PO
RES.2g:PO { @ Recommended width >= 0.4um and length >= 0.8um for unsilicided PO resistor
  INT PORESg < RES_2G_PO_W ABUT < 90 SINGULAR REGION
  RES_L = PORESg INSIDE EDGE RPO
  X = PATH LENGTH RES_L < RES_2G_PO_L
  CHECK_RES = PORESg WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY (RES_2G_PO_L/2 - GRID*2) INSIDE OF PORESg STEP PO_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

RES.8g { @ For unsilicided OD resistor in the s/d of MOS, RH space to gate >= ^RES_8G um
  RH_RES = RH NOT OUTSIDE AYRE
  EXT RH_RES GATE < RES_8G ABUT < 90 SINGULAR REGION
  RH_RES AND GATE
  GATE INSIDE RH // RH can not fully cover GATE
}
RES.9g { @ For unsilicided OD resistor in the s/d of MOS, RH extension on {RPO AND OD} >= ^RES_9G um
  ODRES_SD = ODRES AND SD  
  ENC ODRES_SD RH < RES_9G ABUT < 90 SINGULAR REGION
  ODRES_SD NOT RH
}

RES.10g { @ RH enclosure of unsilicided OD/PO resistor >= ^RES_10G um.
   ENC AYRE RH < RES_10G ABUT < 90 SINGULAR REGION
}

RES.13g { @ {RPO AND PO} must be fully covered by RH except for BJT or ESD circuits
   PORESg NOT RH 
}

RES.14g { @ {RPO AND OD} must be fully covered by RH except for BJT or ESD circuits
   ODRES NOT RH 
}
#ENDIF

RES.8 { @ For unsilicided OD/PO resistor, RH space to Gate(Overlap is not allowed) >= ^RES_8 um
  EXT RH GATE < RES_8 ABUT < 90 SINGULAR REGION
  RH AND GATE
}
RES.11 { @ RPO intersecting (PO AND RH) must form two or more POs
  X = ((POLY AND RH) OUTSIDE BJTDMY) OUTSIDE SDI
  A = RPO AND X
  B = (POLY INTERACT X) NOT RPO
  A NOT INTERACT B >= 2
}
RES.12 { @ RPO intersecting (OD AND RH) must form two or more ODs
  X = ((OD AND RH) OUTSIDE BJTDMY) OUTSIDE SDI
  A = RPO AND X
  B = (OD INTERACT X) NOT RPO
  A NOT INTERACT B >= 2
}  
RES.22 { @ Common rule for unsilicided/silicided OD resistors NP OD resistor is not allowed interacting with NW. DRC will flag {(((OD AND NP) AND RH) AND RPDMY) INTERACT NW}
  X = (NPOD AND RH) AND RPDMY
  X INTERACT NWEL
}
RES.23 { @ Common rule for unsilicided/silicided OD resistors PP OD resistor is only allowed inside NW. DRC will flag {(((OD AND PP) AND RH) AND RPDMY) NOT INSIDE NW}
  X = (PPOD AND RH) AND RPDMY
  X NOT INSIDE NWEL
}


//VAR CHECKS
//==========

VAR_GATE = GATE NOT OUTSIDE VAR
VAR.W.1 { @ Width of {gate AND VAR}	>= ^VAR_W_1 um
  INT VAR_GATE < VAR_W_1 ABUT < 90 SINGULAR REGION
}
VAR.S.1 { @ Space to Active	>= ^VAR_S_1 um
  EXT VAR DACT < VAR_S_1 ABUT < 90 SINGULAR REGION
}
VAR.EN.1 { @ Enclosure of OD	>= ^VAR_EN_1 um
  ENC OD VAR < VAR_EN_1 ABUT < 90 SINGULAR REGION
  OD CUT VAR
}
VAR.R.1 { @ VAR layer must be drawn to fully cover the varactor devices.
  VAR_GATE NOT VAR
}
VAR.R.2 { @ Overlap of VTL_N, VTL_P, VTH_N, VTH_P, NT_N, PSPO, PW, or RPO is not allowed.
  VAR AND VTLN
  VAR AND VTLP
  VAR AND VTHN
  VAR AND VTHP
  VAR AND NTN
  VAR AND PSPOi
  VAR NOT NWEL
  VAR AND RPO
}
VAR.R.3 { @ PP overlap of {gate AND VAR} is not allowed.
  VAR_GATE AND PP
}
VAR.R.4 { @ Overlap to {(PO AND ACTIVE) SIZING 0.22 um} is not allowed
  VAR_E = SIZE VAR BY VAR_W_1 	// For filtering only
  VAR_EXG = (GATE INTERACT VAR_E) OUTSIDE VAR
  VAR_EXGS = SIZE VAR_EXG BY VAR_R_4
  VAR AND VAR_EXGS
}
VAR.R.5 { @ NP must fully cover {(((VAR AND GATE) sizing 0.19) AND OD) sizing 0.13}
  VAR_GATE_a = SIZE VAR_GATE BY VAR_R_5a  
  VAR_GATE_a_OD_b = SIZE (VAR_GATE_a AND OD) BY VAR_R_5b
  VAR_GATE_a_OD_b NOT NP
}
#IFDEF N80
  #IFDEF HS
    VAR.R.6.S80 { @ VAR outside OD2 is not allowed (CLN80HS)
      VAR OUTSIDE OD2  
    }
  #ENDIF
#ENDIF



//CO CHECKS
//=========

CO.W.1 { @ Width (square) (maximum = minimum) = ^CO_W_1 um 
  A = NOT RECTANGLE COs == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  ((A NOT VIA_EXD) NOT SR_M1) NOT INSIDE SRAM_EXCLUDE
}
#IFDEF LmarkSealringCorner
CO.W.2 { @ Width of CO bar. CO bar is only allowed in seal ring. = ^CO_W_2 um
  INT SR_CO < CO_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY
  A = SIZE SR_CO BY CO_W_2 /2 + GRID UNDEROVER TRUNCATE CO_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 1 0.005 
}
#ELSE
CO.W.2 { @ Width of CO bar. CO bar is only allowed in seal-ring = ^CO_W_2 um
  INT SR_CO < CO_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY 
  SIZE SR_CO BY CO_W_2 /2 + GRID UNDEROVER TRUNCATE CO_W_2 /2 + GRID
}
#ENDIF
CO.S.1 { @ Space >= ^CO_S_1 um 
  EXT CO < CO_S_1 ABUT < 90 SINGULAR REGION
}

CO.S.2 { @ Space to 3-neighboring CO (< 0.18 um distance) >= 0.16 um
  COx = RECTANGLE COs == CO_W_1 BY == CO_W_1 ORTHOGONAL ONLY
  X = WITH NEIGHBOR COx > 2 SPACE < CO_S_2_N
  EXT X COx < CO_S_2 ABUT < 90 SINGULAR REGION
}

CO.S.3 { @ {CO inside OD} space to GATE (Overlap of GATE is not allowed) [space can be >= 0.058 um inside SRAM word line decoder covered by layer 186;4] >= ^CO_S_3 um
  A = EXT COOD GATE < CO_S_3 ABUT < 90 SINGULAR REGION
  A NOT INSIDE SRAMDMY_PERI
  B = COOD INTERACT SRAMDMY_PERI
  EXT B GATE < CO_S_3_S ABUT < 90 SINGULAR REGION
  CO AND GATE
}

CO.S.4 { @ {CO inside PO} space to OD >= ^CO_S_4 um 
  EXT COPO OD < CO_S_4 ABUT < 90 SINGULAR REGION
}
CO.S.5 { @ {CO inside OD} space to 1.8V, 2.5V, or 3.3V GATE >= ^CO_S_5 um 
  EXT COOD HV_GATE < CO_S_5 ABUT < 90 SINGULAR REGION
}
CO.S.6 { @ Space to butted PP/NP edge on OD (overlap of NP/PP boundary on OD is not allowed.)(Except SBDDMY region) >= 0.06 
  (EXT NP_PP_BTE COOD < CO_S_6 ABUT < 90 REGION) NOT INSIDE SBDDMY
  (ENC COOD NP_PP_BTE < CO_S_6 ABUT < 90 REGION) NOT INSIDE SBDDMY 
  (EXT BUTT_OD COOD < GRID ABUT < 90 SINGULAR REGION) NOT INSIDE SBDDMY
  (ENC COOD BUTT_OD < GRID ABUT < 90 SINGULAR REGION) NOT INSIDE SBDDMY
  (COOD CUT PP) NOT INSIDE SBDDMY
}
CO.EN.1 { @ Enclosure by OD >= ^CO_EN_1 um 
  ENC COOD OD < CO_EN_1 ABUT < 90 SINGULAR REGION
}
CO.EN.2 { @ Enclosure by PO >= ^CO_EN_2 um 
  ENC COPO POLY < CO_EN_2 ABUT < 90 SINGULAR REGION
  COPO NOT POi
}
CO.EN.3 { @ Enclosure by PO [at least 2 opposite sides] >= ^CO_EN_3 um 
  X = RECTANGLE ENCLOSURE CO POLY ABUT < 90 SINGULAR GOOD CO_EN_2 CO_EN_3 OPPOSITE CO_EN_2 CO_EN_3 OPPOSITE
  Y = ENC [X] POLY < CO_EN_3 ABUT < 90 OPPOSITE
  Z = CO TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}

// CO.R.2 is checked by RPO.S.3
// CO.R.3 is checked by CO.W.1
// CO.R.4 is checked by M1.EN.1 and CO.EN.2
CO.R.6 { @ (CO and (PO interact (RH or RPDMY))) must be fully covered by (NP or PP)
	A = (POLY INTERACT (RH OR RPDMY)) AND CO
	A NOT IMP
}


//M1 CHECKS
//=========
M1Wide_first = (SIZE M1 BY M1_S_2_W /2 UNDEROVER TRUNCATE M1_S_2_W /2) AND M1 
M1Wide_1.5 = (SIZE M1Wide_first BY M1_S_3_W /2 UNDEROVER TRUNCATE M1_S_3_W /2) AND M1Wide_first
M1Wide_4.5 = (SIZE M1Wide_1.5 BY M1_S_4_W /2 UNDEROVER TRUNCATE M1_S_4_W /2) AND M1Wide_1.5
M11 = M1Wide_first NOT CB_NON_CUP
M12 = M1Wide_1.5 NOT CB_NON_CUP
M13 = M1Wide_4.5 NOT CB_NON_CUP

M1AS3 = AREA M1 > M1_S_3_L*M1_W_1  // filter small metal for M1.S.3
M1AS4 = AREA M1AS3 > M1_S_4_L*M1_W_1  // filter small metal for M1.S.4

#IFDEF N80
  M1Wide_N80first = (SIZE M1 BY M1_S_2_1_W /2 UNDEROVER TRUNCATE M1_S_2_1_W /2) AND M1 
  M1A = M1Wide_N80first NOT CB_NON_CUP
#ENDIF

M1.W.1 { @ Width >= ^M1_W_1 um 
  (INT M1s < M1_W_1 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
M1.W.2 { @ Width of 45-degree bent metal >= ^M1_W_2 um 
  INT M1_EDGE_45 < M1_W_2 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M1.W.2.R is checked by RR:M1.W.2 
    RR:M1.W.2 { @ Width of 45-degree bent metal >= ^M1_W_2R um 
      INT M1_EDGE_45 < M1_W_2R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF

M1.W.3 { @ Maximum width <= ^M1_W_3 um 
  SIZE M1 BY M1_W_3 /2 UNDEROVER TRUNCATE M1_W_3 /2
}
M1.S.1 { @ Space >= ^M1_S_1 um 
  EXT M1 < M1_S_1 ABUT < 90 SINGULAR REGION
}
//M1.S.2.S80 is checked by M1.S.2
M1.S.2 { @ Space [at least one metal line width > ^M1_S_2_W um and the parallel metal run length > ^M1_S_2_L um] >= ^M1_S_2 um
  X = EXT M11 M1 < M1_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_L+GRID
}
#IFDEF N80
  M1.S.2.1.S80 { @ Space [at least one metal line width > 0.3um(W1) and the parallel metal run length > 0.8um(L1)] >= 0.13um
  X = EXT M1A M1 < M1_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_2_1_L+GRID
  }
#ENDIF


//M1.S.3.S80 is checked by M1.S.3
M1.S.3 { @ Space [at least one metal line width > ^M1_S_3_W um and the parallel metal run length > ^M1_S_3_L um] >= ^M1_S_3 um
  X = EXT M12 M1AS3 < M1_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_3_L+GRID
}
//M1.S.4.S80 is checked by M1.S.4
M1.S.4 { @ Space [at least one metal line width > ^M1_S_4_W um and the parallel metal run length > ^M1_S_4_L um] >= ^M1_S_4 um
  X = EXT M13 M1AS4 < M1_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M1
  ENCLOSE RECTANGLE Y GRID M1_S_4_L+GRID
}
M1.S.5 { @ Space to 45-degree bent metal >= ^M1_S_5 um 
  X = EXPAND EDGE M1_EDGE_45 OUTSIDE BY M1_S_5
  X AND M1
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
//M1.S.5.R is checked by RR:M1.S.5
    RR:M1.S.5 { @ M1 space to 45-degree bent M1 >= ^M1_S_5R
      X = EXPAND EDGE M1_EDGE_45 OUTSIDE BY M1_S_5R
      X AND M1
    }
  #ENDIF
#ENDIF


// M1.EN.0 is checked by M1.EN.1 and M1.EN.2__M1.EN.3

M1.EN.1 { @ Enclosure of CO >= 0.0
  COs NOT M1s
}
// M1.EN.2 is checked by M1.EN.2__M1.EN.3
// M1.EN.3 is checked by M1.EN.2__M1.EN.3
M1.EN.2__M1.EN.3 { @ Enclosure of CO at least two opposite sides ^M1_EN_2 um/Enclosure of CO ^M1_EN_3 um 
  A = RECTANGLE ENCLOSURE COs M1s ABUT > 0 < 90 GOOD 0 M1_EN_2 OPPOSITE 0 M1_EN_2 OPPOSITE
  (ENC A M1s < M1_EN_3 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}

M1.A.1 { @ Area >= ^M1_A_1 um2
  (AREA M1s < M1_A_1) NOT INSIDE SRAM_EXCLUDE
}

VARIABLE M1_A_2pre ((M1_A_2 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))*((M1_A_2 + (M1_S_1 * M1_S_1 * 3.142))/(2 * M1_S_1))/3.141

M1HO = HOLES M1s INNER < M1_A_2pre

M1HOC = M1HO NOT M1i

M1.A.2 { @ Enclosed area >= ^M1_A_2 um2
  (AREA M1HOC < M1_A_2) NOT INSIDE SRAM_EXCLUDE
}


CHIP_NOT_M1_EXC_HIGH = CHIP NOT M1_EXC_H  // for high density check
M1_NOT_EXC_HIGH = M1x NOT M1_EXC_H       // for high density check 
CHIP_NOT_M1_EXC_L = CHIP NOT M1_EXC_L1    // for low density check
M1_NOT_EXC_L = M1x NOT M1_EXC_L1         // for low density check

// For density check in DMxEXCL
CHIP_AND_DM1EXCL_HIGH = CHIP_NOT_M1_EXC_HIGH AND DM1EXCL  // for high density check
M1_AND_DM1EXCL_HIGH = M1_NOT_EXC_HIGH AND DM1EXCL        // for high density check
CHIP_AND_DM1EXCL = CHIP_NOT_M1_EXC_L AND DM1EXCL 	     // for low density check
M1_AND_DM1EXCL = M1_NOT_EXC_L AND DM1EXCL                // for low density check

#IFDEF DENSITY_IN_BLOCKAGE
// M1.DN.3 is checked by M1.DN.3:L
// M1.DN.3a is checked by M1.DN.3:L
M1.DN.3:L { @ M1 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um (with DM1EXCL region)
  ERR1 = DENSITY M1_AND_DM1EXCL CHIP_AND_DM1EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]
  ERR2 = DENSITY M1_NOT_EXC_L CHIP_NOT_M1_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_NOT_EXC_L)/AREA(CHIP_NOT_M1_EXC_L) ]	
  K = SIZE (((ERR1 AND DM1EXCL) INSIDE ERR2) NOT M1_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M1_AND_DM1EXCL CHIP_AND_DM1EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M1.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]

}
// M1.DN.3 is checked by M1.DN.3:H 
// M1.DN.3d is checked by M1.DN.3:H 
M1.DN.3:H { @ M1 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 umx ^Mx_DN_W2 um step 50um (with DM1EXCL region)
  ERR1 = DENSITY M1_AND_DM1EXCL_HIGH CHIP_AND_DM1EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_AND_DM1EXCL_HIGH)/AREA(CHIP_AND_DM1EXCL_HIGH) ]
  ERR2 = DENSITY M1_NOT_EXC_HIGH CHIP_NOT_M1_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_NOT_EXC_HIGH)/AREA(CHIP_NOT_M1_EXC_HIGH) ]
  K = SIZE (((ERR1 AND DM1EXCL) INSIDE ERR2) NOT M1_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M1_AND_DM1EXCL_HIGH CHIP_AND_DM1EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M1.DN.3H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*(AREA(M1_AND_DM1EXCL_HIGH)/AREA(CHIP_AND_DM1EXCL_HIGH)) ]
}
#ELSE
#IFDEF FULL_CHIP
// M1.DN.1 is checked by M1.DN.1__M1.DN.3:L
// M1.DN.3 is checked by M1.DN.1__M1.DN.3:L
// M1.DN.1a is checked by M1.DN.1__M1.DN.3:L
// M1.DN.3a is checked by M1.DN.1__M1.DN.3:L
M1.DN.1__M1.DN.3:L { @ M1 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M1_NOT_EXC_L CHIP_NOT_M1_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
[ AREA(M1_NOT_EXC_L)/AREA(CHIP_NOT_M1_EXC_L) ]
  K = SIZE (ERR_WIN NOT M1_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M1_NOT_EXC_L CHIP_NOT_M1_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M1.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M1_NOT_EXC_L)/AREA(CHIP_NOT_M1_EXC_L) ]
}
#ELSE  // IP/macro/block level
#IFDEF DENSITY_FOR_NONFULLCHIP
// M1.DN.1 is checked by M1.DN.1__M1.DN.3:L
// M1.DN.3 is checked by M1.DN.1__M1.DN.3:L
// M1.DN.1a is checked by M1.DN.1__M1.DN.3:L
// M1.DN.3a is checked by M1.DN.1__M1.DN.3:L
M1.DN.1__M1.DN.3:L { @ M1 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M1_NOT_EXC_L CHIP_NOT_M1_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_NOT_EXC_L)/AREA(CHIP_NOT_M1_EXC_L) ]
  K = SIZE (ERR_WIN NOT M1_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M1_NOT_EXC_L CHIP_NOT_M1_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M1.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M1_NOT_EXC_L)/AREA(CHIP_NOT_M1_EXC_L) ]
}
#ELSE
// M1.DN.3 is checked by M1.DN.3:L
// M1.DN.3a is checked by M1.DN.3:L
M1.DN.3:L { @ M1 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um (with DM1EXCL region)
  ERR1 = DENSITY M1_AND_DM1EXCL CHIP_AND_DM1EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]
  ERR2 = DENSITY M1_NOT_EXC_L CHIP_NOT_M1_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_NOT_EXC_L)/AREA(CHIP_NOT_M1_EXC_L) ]
  K = SIZE (((ERR1 AND DM1EXCL) INSIDE ERR2) NOT M1_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2 
  DENSITY K M1_AND_DM1EXCL CHIP_AND_DM1EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M1.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M1_AND_DM1EXCL)/AREA(CHIP_AND_DM1EXCL) ]
}
#ENDIF
#ENDIF
// M1.DN.1 is checked by M1.DN.1__M1.DN.3:H
// M1.DN.3 is checked by M1.DN.1__M1.DN.3:H
// M1.DN.1d is checked by M1.DN.1__M1.DN.3:H
// M1.DN.3d is checked by M1.DN.1__M1.DN.3:H
M1.DN.1__M1.DN.3:H { @ M1 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 um x ^Mx_DN_W2 um step 50um 
  ERR_WIN = DENSITY M1_NOT_EXC_HIGH CHIP_NOT_M1_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M1_NOT_EXC_HIGH)/AREA(CHIP_NOT_M1_EXC_HIGH) ]
  K = SIZE (ERR_WIN NOT M1_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M1_NOT_EXC_HIGH CHIP_NOT_M1_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M1.DN.1H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*AREA(M1_NOT_EXC_HIGH)/AREA(CHIP_NOT_M1_EXC_HIGH) ]
}
#ENDIF

M1.DN.2 { @ M1 local density must be < 90% range over 20umx20um step 10um
  DENSITY M1x CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M1.DN.2.density 
    [ AREA(M1x)/AREA(CHIP) ]
}  

//M1.R.1 can't be checked


//VIA1 CHECKS
//===========
#IFDEF N80
  M2Wide_N80first = (SIZE M2 BY M2_S_2_1_W /2 UNDEROVER TRUNCATE M2_S_2_1_W /2) AND M2
#ENDIF

M2Wide_first = (SIZE M2 BY M2_S_2_W /2 UNDEROVER TRUNCATE M2_S_2_W /2) AND M2
M2Wide_1.5 = (SIZE M2Wide_first BY M2_S_3_W /2 UNDEROVER TRUNCATE M2_S_3_W /2) AND M2Wide_first
M2Wide_4.5 = (SIZE M2Wide_1.5 BY M2_S_4_W /2 UNDEROVER TRUNCATE M2_S_4_W /2) AND M2Wide_1.5

M1Wide_0.42_VIA1 = (SIZE M1Wide_first BY VIA1_R_2_W /2 UNDEROVER TRUNCATE VIA1_R_2_W /2) AND M1Wide_first 
M1Wide_0.7_VIA1 = (SIZE M1Wide_0.42_VIA1 BY VIA1_R_4_W /2 UNDEROVER TRUNCATE VIA1_R_4_W /2) AND M1Wide_0.42_VIA1
M1Wide_1.14_VIA1 = (SIZE M1Wide_0.7_VIA1 BY VIA1_R_3_W /2 UNDEROVER TRUNCATE VIA1_R_3_W /2) AND M1Wide_0.7_VIA1
M1Wide_2_VIA1 = (SIZE M1Wide_1.14_VIA1 BY VIA1_R_5_W /2 UNDEROVER TRUNCATE VIA1_R_5_W /2) AND M1Wide_1.14_VIA1
M1Wide_3_VIA1 = (SIZE M1Wide_2_VIA1 BY VIA1_R_6_W /2 UNDEROVER TRUNCATE VIA1_R_6_W /2) AND M1Wide_2_VIA1
M2Wide_0.42_VIA1 = (SIZE M2Wide_first BY VIA1_R_2_W /2 UNDEROVER TRUNCATE VIA1_R_2_W /2) AND M2Wide_first 
M2Wide_0.7_VIA1 = (SIZE M2Wide_0.42_VIA1 BY VIA1_R_4_W /2 UNDEROVER TRUNCATE VIA1_R_4_W /2) AND M2Wide_0.42_VIA1
M2Wide_1.14_VIA1 = (SIZE M2Wide_0.7_VIA1 BY VIA1_R_3_W /2 UNDEROVER TRUNCATE VIA1_R_3_W /2) AND M2Wide_0.7_VIA1 
M2Wide_2_VIA1 = (SIZE M2Wide_1.14_VIA1 BY VIA1_R_5_W /2 UNDEROVER TRUNCATE VIA1_R_5_W /2) AND M2Wide_1.14_VIA1
M2Wide_3_VIA1 = (SIZE M2Wide_2_VIA1 BY VIA1_R_6_W /2 UNDEROVER TRUNCATE VIA1_R_6_W /2) AND M2Wide_2_VIA1 

VIA1.W.1 { @ Width (square) (maximum = minimum) = ^VIA1_W_1 um
  A = NOT RECTANGLE VIA1s == VIA1_W_1 BY == VIA1_W_1 ORTHOGONAL ONLY
  (A NOT VIA_EXD) NOT SRAM_EXCLUDE
}
#IFDEF LmarkSealringCorner
VIA1.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA1_W_2 um
  INT SR_VIA1 < VIA1_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_VIA1 BY VIA1_W_2 /2 + GRID UNDEROVER TRUNCATE VIA1_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA1.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA1_W_2 um
  INT SR_VIA1 < VIA1_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_VIA1 BY VIA1_W_2 /2 + GRID UNDEROVER TRUNCATE VIA1_W_2 /2 + GRID
}
#ENDIF
VIA1.S.1 { @ Space >= ^VIA1_S_1 um 
  EXT VIA1 < VIA1_S_1 ABUT < 90 SINGULAR REGION
}
VIA1.S.2 { @ Space to 3-neighboring VIAx (< 0.19 um distance) >= ^VIA1_S_2 um
  X = WITH NEIGHBOR VIA1_EXD > 2 SPACE < VIA1_S_2_S
  EXT X VIA1 < VIA1_S_2 ABUT < 90 SINGULAR REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// VIA1.S.3.R is checked by RR:VIA1.S.3
    RR:VIA1.S.3 { @ Two adjacent VIAx space between different net if the common run length > 0 um, >= 0.17 um
      VIA1_NODAL = STAMP VIA1 BY VIA1i
      EXT VIA1_NODAL < VIA1_S_3R ABUT < 90 NOT CONNECTED OPPOSITE REGION
    }
  #ENDIF
#ENDIF

// VIA1.EN.0 is checked by either {VIA1.EN.1/VIA1.EN.2} or VIA1.EN.3

VIA1.EN.1 { @ Enclosure by Mx or M1 >= ^VIA1_EN_1 um 
  ENC VIA1 M1 < VIA1_EN_1 ABUT < 90 SINGULAR REGION
  VIA1 NOT M1
}

// VIA1.EN.2 is checked by VIA1.EN.2__VIA1.EN.3
// VIA1.EN.3 is checked by VIA1.EN.2__VIA1.EN.3
VIA1.EN.2__VIA1.EN.3 { @ Enclosure by M1 [at least two opposite sides] >= ^VIA1_EN_2 , or [all sides] >= ^VIA1_EN_3
  X = RECTANGLE ENCLOSURE VIA1 M1 ABUT < 90 SINGULAR GOOD VIA1_EN_1 VIA1_EN_2 OPPOSITE VIA1_EN_1 VIA1_EN_2 OPPOSITE
ENC X M1 < VIA1_EN_3 ABUT < 90 SINGULAR REGION
}

// VIA1.R.1 is checked by VIA1.W.1
// VIA1.R.2 is checked by VIA1.R.2__VIA1.R.3
// VIA1.R.3 is checked by VIA1.R.2__VIA1.R.3
// VIA1.R.2.S80 is checked by VIA1.R.2__VIA1.R.3
// VIA1.R.3.S80 is checked by VIA1.R.2__VIA1.R.3
VIA1.R.2__VIA1.R.3 { @ When M1 or M2 width > ^VIA1_R_2_W um, more than one VIA1 is required.
                    @ 2 vias spacing should be <= ^VIA1_R_2_S1 um or 4 vias spacing should be <= ^VIA1_R_2_S2 um
                    @ or 9 vias spacing should be <= ^VIA1_R_2_S3 um
                    @ When M1 or M2 width > ^VIA1_R_3_W um, more than three VIA1 is required.
                    @ 4 vias spacing should be <= ^VIA1_R_3_S1 um or 9 vias spacing should be <= ^VIA1_R_3_S2 um

M2OvpM1_W_ = (M1Wide_0.42_VIA1 AND M2) OR (M2Wide_0.42_VIA1 AND M1)
M2OvpM1_B  = (M1Wide_1.14_VIA1 AND M2) OR (M2Wide_1.14_VIA1 AND M1)
M2OvpM1_W  = M2OvpM1_W_ NOT M2OvpM1_B 
Checked_VIA1_W_ = VIA1_EXD NOT OUTSIDE M2OvpM1_W
Checked_VIA1_B  = VIA1_EXD NOT OUTSIDE M2OvpM1_B
Checked_VIA1_W  = Checked_VIA1_W_ NOT Checked_VIA1_B

M1_effect = M1i INTERACT M2OvpM1_W_
M2_effect = M2i INTERACT M2OvpM1_W_
effect_M2OvpM1_ = M1_effect AND M2_effect
effect_M2OvpM1 = effect_M2OvpM1_ INTERACT M2OvpM1_W_
effect_VIA = VIA1_EXD INTERACT effect_M2OvpM1
    
V1Merged_A = SIZE effect_VIA BY VIA1_R_2_S1/2 INSIDE OF effect_M2OvpM1 STEP 0.085
V1Merged_B = SIZE V1Merged_A BY (VIA1_R_2_S2 - VIA1_R_2_S1)/2 INSIDE OF effect_M2OvpM1 STEP 0.085
V1Merged_C = SIZE V1Merged_B BY (VIA1_R_3_S2 - VIA1_R_2_S2)/2 INSIDE OF effect_M2OvpM1 STEP 0.085
V1Merged_A2R = V1Merged_A INTERACT effect_VIA < 2
V1Merged_A2 = V1Merged_A OUTSIDE V1Merged_A2R
V1Merged_A4R = V1Merged_A2 INTERACT effect_VIA < 4
V1Merged_A4 = V1Merged_A2 OUTSIDE V1Merged_A4R
V1Merged_B4R = V1Merged_B INTERACT effect_VIA < 4
V1Merged_B4 = V1Merged_B OUTSIDE V1Merged_B4R
V1Merged_C9R = V1Merged_C INTERACT effect_VIA < 9
V1Merged_C9 = V1Merged_C OUTSIDE V1Merged_C9R

GMergeW = (V1Merged_A2 OR V1Merged_B4) OR V1Merged_C9
GMergeB = V1Merged_A4 OR V1Merged_C9

GVIA_W = Checked_VIA1_W INTERACT GMergeW
GVIA_B = Checked_VIA1_B INTERACT GMergeB
GOOD_AREA_W = M2OvpM1_W INTERACT GVIA_W
GOOD_AREA_B = M2OvpM1_B INTERACT GVIA_B
Checked_VIA1_W OUTSIDE GOOD_AREA_W
Checked_VIA1_B OUTSIDE GOOD_AREA_B
}
// VIA1.R.4 is checked by VIA1.R.4:M1
// VIA1.R.4.S80 is checked by VIA1.R.4:M1
VIA1.R.4:M1 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M1Wide_0.7_VIA1 BY VIA1_R_4_D + GRID) NOT M1Wide_0.7_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_0.7_VIA1) INTERACT VIA1
  Branch1Edge = M1Wide_0.7_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M1_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA1.R.4 is checked by VIA1.R.4:M2
// VIA1.R.4.S80 is checked by VIA1.R.4:M2
VIA1.R.4:M2 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M2Wide_0.7_VIA1 BY VIA1_R_4_D + GRID) NOT M2Wide_0.7_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_0.7_VIA1) INTERACT VIA1
  Branch1Edge = M2Wide_0.7_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M1) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA1.R.5 is checked by VIA1.R.5:M1
// VIA1.R.5.S80 is checked by VIA1.R.5:M1
VIA1.R.5:M1 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M1Wide_2_VIA1 BY VIA1_R_5_D + GRID) NOT M1Wide_2_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Wide_2_VIA1) INTERACT VIA1
  Branch1Edge = M1Wide_2_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA1.R.5 is checked by VIA1.R.5:M2
// VIA1.R.5.S80 is checked by VIA1.R.5:M2
VIA1.R.5:M2 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M2Wide_2_VIA1 BY VIA1_R_5_D + GRID) NOT M2Wide_2_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_2_VIA1) INTERACT VIA1
  Branch1Edge = M2Wide_2_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M1Big_3_VIA1 = ENCLOSE RECTANGLE M1Wide_3_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID
// VIA1.R.6 is checked by VIA1.R.6:M1
// VIA1.R.6.S80 is checked by VIA1.R.6:M1
VIA1.R.6:M1 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M1Big_3_VIA1 BY VIA1_R_6_D + GRID) NOT M1Big_3_VIA1) AND M1
  Branch1HasVia = (Branch1 INTERACT M1Big_3_VIA1) INTERACT VIA1
  Branch1Edge = M1Big_3_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M1_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M1) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M2Big_3_VIA1 = ENCLOSE RECTANGLE M2Wide_3_VIA1 VIA1_R_6_W VIA1_R_6_L+GRID
// VIA1.R.6 is checked by VIA1.R.6:M2
// VIA1.R.6.S80 is checked by VIA1.R.6:M2
VIA1.R.6:M2 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M2Big_3_VIA1 BY VIA1_R_6_D + GRID) NOT M2Big_3_VIA1) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_3_VIA1) INTERACT VIA1
  Branch1Edge = M2Big_3_VIA1 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA1_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M1) INTERACT VIA1 > 1
  BranchSingleVia = (VIA1 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M1 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA1 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA1.R.7 is checked by VIA1.EN.1
// VIA1.R.9 can't be checked


VIA1.R.11 { @ Single VIAx is not allowed for mesh-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has mesh-shape interact with two metal holes : both two metal hole area <= ^VIA1_R_11_A um2 and two metal hole length(L2) <= ^VIA1_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this mesh-shape Mx+1 
@ 3. The length (L) of the center metal bar <= 1um and the width of metal bar is <= 0.42um. 



    
  W = M2i WITH WIDTH <= VIA1_R_11_W   
  H_HOLE = (HOLES M2i INNER <= VIA1_R_11_A) INTERACT W
  A0 = M2i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA1_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA1_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA1_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA1_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA1_R_11_L+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA1i
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA1_R_11_L2 OPPOSITE  
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA1i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M1i INTERACT CHECK_VIA)) INTERACT VIA1i == 1)
}


//M2 CHECKS
//=========
#IFDEF N80
  M2A = M2Wide_N80first NOT CB_NON_CUP
#ENDIF

M21 = M2Wide_first NOT CB_NON_CUP
M22 = M2Wide_1.5 NOT CB_NON_CUP
M23 = M2Wide_4.5 NOT CB_NON_CUP


VARIABLE M2_A_2pre ((M2_A_2 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))*((M2_A_2 + (M2_S_1 * M2_S_1 * 3.142))/(2 * M2_S_1))/3.141

M2HO = HOLES M2 INNER < M2_A_2pre

M2HOC = M2HO NOT M2

M2AS3 = AREA M2 > M2_S_3_L*M2_W_1  // filter small metal for M2.S.3
M2AS4 = AREA M2AS3 > M2_S_4_L*M2_W_1  // filter small metal for M2.S.4

M2.W.1 { @ Width >= ^M2_W_1 um 
  INT M2 < M2_W_1 ABUT < 90 SINGULAR REGION
}
M2.W.2 { @ Width of 45-degree bent Mx >= ^M2_W_2 um 
  INT M2_EDGE_45 < M2_W_2 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M2.W.2.R is checked by RR:M2.W.2
    RR:M2.W.2 { @ Width of 45-degree bent Mx >= ^M2_W_2R um 
      INT M2_EDGE_45 < M2_W_2R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF


M2.W.3 { @ Maximum width [Except WBDMY, if Mx is Mtop-1 layer] <= ^M2_W_3 um 
  SIZE M2 BY M2_W_3 /2 UNDEROVER TRUNCATE M2_W_3 /2
}
M2.S.1 { @ Space >= ^M2_S_1 um 
  EXT M2 < M2_S_1 ABUT < 90 SINGULAR REGION
}
// M2.S.2.S80 is checked by M2.S.2
M2.S.2 { @ Space [at least one metal line width > M2_S_2_W um and the parallel metal run length > M2_S_2_L um] >= ^M2_S_2 um
  X = EXT M21 M2 < M2_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_L+GRID
}
#IFDEF N80
  M2.S.2.1.S80 { @ Space [at least one metal line width > 0.21um(W1) and the parallel metal run length > 0.8um(L1)] >= 0.15um
  X = EXT M2A M2 < M2_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_2_1_L+GRID
  }
#ENDIF


// M2.S.3.S80 is checked by M2.S.3
M2.S.3 { @ Space [at least one metal line width > M2_S_3_W um and the parallel metal run length > M2_S_3_L um] >= ^M2_S_3 um
  X = EXT M22 M2AS3 < M2_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_3_L+GRID
}
// M2.S.4.S80 is checked by M2.S.4
M2.S.4 { @ Space [at least one metal line width > M2_S_4_W um and the parallel metal run length > M2_S_4_L um] >= ^M2_S_4 um
  X = EXT M23 M2AS4 < M2_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M2
  ENCLOSE RECTANGLE Y GRID M2_S_4_L+GRID
}
M2.S.5 { @ Space to 45-degree bent Mx >= ^M2_S_5 um 
  X = EXPAND EDGE M2_EDGE_45 OUTSIDE BY M2_S_5
  X AND M2
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M2.S.5.R is checked by RR:M2.S.5
    RR:M2.S.5 { @ Mx space to 45-degree bent Mx >= ^M2_S_5R um 
      X = EXPAND EDGE M2_EDGE_45 OUTSIDE BY M2_S_5R
      X AND M2
    }
  #ENDIF
#ENDIF

// M2.EN.0 is checked by either {M2.EN.1/M2.EN.2} or M2.EN.3
M2.EN.1 { @ Enclosure of VIAx-1 >= ^M2_EN_1 um 
  ENC VIA1 M2 < M2_EN_1 ABUT < 90 SINGULAR REGION
  VIA1 NOT M2
}
// M2.EN.2 is checked by M2.EN.2__M2.EN.3
// M2.EN.3 is checked by M2.EN.2__M2.EN.3
M2.EN.2__M2.EN.3 { @ Enclosure of VIAx-1 [at least 2 opposite sides] >= ^M2_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA1 M2 ABUT < 90 SINGULAR GOOD M2_EN_1 M2_EN_2 OPPOSITE M2_EN_1 M2_EN_2 OPPOSITE
  ENC X M2 < M2_EN_3 ABUT < 90 SINGULAR REGION
}

M2.A.1 { @ Area >= ^M2_A_1 um2
  AREA M2 < M2_A_1
}
M2.A.2 { @ Enclosed area >= ^M2_A_2 um
  AREA M2HOC < M2_A_2
}


CHIP_NOT_M2_EXC_HIGH = CHIP NOT M2_EXC_H  // for high density check
M2_NOT_EXC_HIGH = M2x NOT M2_EXC_H       // for high density check 
CHIP_NOT_M2_EXC_L = CHIP NOT M2_EXC_L1    // for low density check
M2_NOT_EXC_L = M2x NOT M2_EXC_L1         // for low density check

// For density check in DMxEXCL
CHIP_AND_DM2EXCL_HIGH = CHIP_NOT_M2_EXC_HIGH AND DM2EXCL  // for high density check
M2_AND_DM2EXCL_HIGH = M2_NOT_EXC_HIGH AND DM2EXCL        // for high density check
CHIP_AND_DM2EXCL = CHIP_NOT_M2_EXC_L AND DM2EXCL 	     // for low density check
M2_AND_DM2EXCL = M2_NOT_EXC_L AND DM2EXCL                // for low density check

#IFDEF DENSITY_IN_BLOCKAGE
// M2.DN.3 is checked by M2.DN.3:L
// M2.DN.3a is checked by M2.DN.3:L
M2.DN.3:L { @ M2 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um (with DM2EXCL region)
  ERR1 = DENSITY M2_AND_DM2EXCL CHIP_AND_DM2EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]
  ERR2 = DENSITY M2_NOT_EXC_L CHIP_NOT_M2_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_NOT_EXC_L)/AREA(CHIP_NOT_M2_EXC_L) ]	
  K = SIZE (((ERR1 AND DM2EXCL) INSIDE ERR2) NOT M2_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M2_AND_DM2EXCL CHIP_AND_DM2EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M2.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]

}
// M2.DN.3 is checked by M2.DN.3:H 
// M2.DN.3d is checked by M2.DN.3:H 
M2.DN.3:H { @ M2 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 umx ^Mx_DN_W2 um step 50um (with DM2EXCL region)
  ERR1 = DENSITY M2_AND_DM2EXCL_HIGH CHIP_AND_DM2EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_AND_DM2EXCL_HIGH)/AREA(CHIP_AND_DM2EXCL_HIGH) ]
  ERR2 = DENSITY M2_NOT_EXC_HIGH CHIP_NOT_M2_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_NOT_EXC_HIGH)/AREA(CHIP_NOT_M2_EXC_HIGH) ]
  K = SIZE (((ERR1 AND DM2EXCL) INSIDE ERR2) NOT M2_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M2_AND_DM2EXCL_HIGH CHIP_AND_DM2EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M2.DN.3H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*(AREA(M2_AND_DM2EXCL_HIGH)/AREA(CHIP_AND_DM2EXCL_HIGH)) ]
}
#ELSE
#IFDEF FULL_CHIP
// M2.DN.1 is checked by M2.DN.1__M2.DN.3:L
// M2.DN.3 is checked by M2.DN.1__M2.DN.3:L
// M2.DN.1a is checked by M2.DN.1__M2.DN.3:L
// M2.DN.3a is checked by M2.DN.1__M2.DN.3:L
M2.DN.1__M2.DN.3:L { @ M2 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M2_NOT_EXC_L CHIP_NOT_M2_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
[ AREA(M2_NOT_EXC_L)/AREA(CHIP_NOT_M2_EXC_L) ]
  K = SIZE (ERR_WIN NOT M2_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M2_NOT_EXC_L CHIP_NOT_M2_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M2.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M2_NOT_EXC_L)/AREA(CHIP_NOT_M2_EXC_L) ]
}
#ELSE  // IP/macro/block level
#IFDEF DENSITY_FOR_NONFULLCHIP
// M2.DN.1 is checked by M2.DN.1__M2.DN.3:L
// M2.DN.3 is checked by M2.DN.1__M2.DN.3:L
// M2.DN.1a is checked by M2.DN.1__M2.DN.3:L
// M2.DN.3a is checked by M2.DN.1__M2.DN.3:L
M2.DN.1__M2.DN.3:L { @ M2 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M2_NOT_EXC_L CHIP_NOT_M2_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_NOT_EXC_L)/AREA(CHIP_NOT_M2_EXC_L) ]
  K = SIZE (ERR_WIN NOT M2_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M2_NOT_EXC_L CHIP_NOT_M2_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M2.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M2_NOT_EXC_L)/AREA(CHIP_NOT_M2_EXC_L) ]
}
#ELSE
// M2.DN.3 is checked by M2.DN.3:L
// M2.DN.3a is checked by M2.DN.3:L
M2.DN.3:L { @ M2 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um (with DM2EXCL region)
  ERR1 = DENSITY M2_AND_DM2EXCL CHIP_AND_DM2EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]
  ERR2 = DENSITY M2_NOT_EXC_L CHIP_NOT_M2_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_NOT_EXC_L)/AREA(CHIP_NOT_M2_EXC_L) ]
  K = SIZE (((ERR1 AND DM2EXCL) INSIDE ERR2) NOT M2_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2 
  DENSITY K M2_AND_DM2EXCL CHIP_AND_DM2EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M2.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M2_AND_DM2EXCL)/AREA(CHIP_AND_DM2EXCL) ]
}
#ENDIF
#ENDIF
// M2.DN.1 is checked by M2.DN.1__M2.DN.3:H
// M2.DN.3 is checked by M2.DN.1__M2.DN.3:H
// M2.DN.1d is checked by M2.DN.1__M2.DN.3:H
// M2.DN.3d is checked by M2.DN.1__M2.DN.3:H
M2.DN.1__M2.DN.3:H { @ M2 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 um x ^Mx_DN_W2 um step 50um 
  ERR_WIN = DENSITY M2_NOT_EXC_HIGH CHIP_NOT_M2_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M2_NOT_EXC_HIGH)/AREA(CHIP_NOT_M2_EXC_HIGH) ]
  K = SIZE (ERR_WIN NOT M2_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M2_NOT_EXC_HIGH CHIP_NOT_M2_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M2.DN.1H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*AREA(M2_NOT_EXC_HIGH)/AREA(CHIP_NOT_M2_EXC_HIGH) ]
}
#ENDIF

M2.DN.2 { @ M2 local density must be < 90% range over 20umx20um step 10um
  DENSITY M2x CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M2.DN.2.density 
    [ AREA(M2x)/AREA(CHIP) ]
}  

// M2.R.1 can not be checked


//VIA2 CHECKS
//===========
#IFDEF N80
  M3Wide_N80first = (SIZE M3 BY M3_S_2_1_W /2 UNDEROVER TRUNCATE M3_S_2_1_W /2) AND M3
#ENDIF

M3Wide_first = (SIZE M3 BY M3_S_2_W /2 UNDEROVER TRUNCATE M3_S_2_W /2) AND M3
M3Wide_1.5 = (SIZE M3Wide_first BY M3_S_3_W /2 UNDEROVER TRUNCATE M3_S_3_W /2) AND M3Wide_first
M3Wide_4.5 = (SIZE M3Wide_1.5 BY M3_S_4_W /2 UNDEROVER TRUNCATE M3_S_4_W /2) AND M3Wide_1.5

M2Wide_0.42_VIA2 = (SIZE M2Wide_first BY VIA2_R_2_W /2 UNDEROVER TRUNCATE VIA2_R_2_W /2) AND M2Wide_first 
M2Wide_0.7_VIA2 = (SIZE M2Wide_0.42_VIA2 BY VIA2_R_4_W /2 UNDEROVER TRUNCATE VIA2_R_4_W /2) AND M2Wide_0.42_VIA2
M2Wide_1.14_VIA2 = (SIZE M2Wide_0.7_VIA2 BY VIA2_R_3_W /2 UNDEROVER TRUNCATE VIA2_R_3_W /2) AND M2Wide_0.7_VIA2
M2Wide_2_VIA2 = (SIZE M2Wide_1.14_VIA2 BY VIA2_R_5_W /2 UNDEROVER TRUNCATE VIA2_R_5_W /2) AND M2Wide_1.14_VIA2
M2Wide_3_VIA2 = (SIZE M2Wide_2_VIA2 BY VIA2_R_6_W /2 UNDEROVER TRUNCATE VIA2_R_6_W /2) AND M2Wide_2_VIA2
M3Wide_0.42_VIA2 = (SIZE M3Wide_first BY VIA2_R_2_W /2 UNDEROVER TRUNCATE VIA2_R_2_W /2) AND M3Wide_first 
M3Wide_0.7_VIA2 = (SIZE M3Wide_0.42_VIA2 BY VIA2_R_4_W /2 UNDEROVER TRUNCATE VIA2_R_4_W /2) AND M3Wide_0.42_VIA2
M3Wide_1.14_VIA2 = (SIZE M3Wide_0.7_VIA2 BY VIA2_R_3_W /2 UNDEROVER TRUNCATE VIA2_R_3_W /2) AND M3Wide_0.7_VIA2 
M3Wide_2_VIA2 = (SIZE M3Wide_1.14_VIA2 BY VIA2_R_5_W /2 UNDEROVER TRUNCATE VIA2_R_5_W /2) AND M3Wide_1.14_VIA2
M3Wide_3_VIA2 = (SIZE M3Wide_2_VIA2 BY VIA2_R_6_W /2 UNDEROVER TRUNCATE VIA2_R_6_W /2) AND M3Wide_2_VIA2 

VIA2.W.1 { @ Width (square) (maximum = minimum) = ^VIA2_W_1 um
  A = NOT RECTANGLE VIA2 == VIA2_W_1 BY == VIA2_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA2.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA2_W_2 um
  INT SR_VIA2 < VIA2_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_VIA2 BY VIA2_W_2 /2 + GRID UNDEROVER TRUNCATE VIA2_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA2.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA2_W_2 um
  INT SR_VIA2 < VIA2_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_VIA2 BY VIA2_W_2 /2 + GRID UNDEROVER TRUNCATE VIA2_W_2 /2 + GRID
}
#ENDIF
VIA2.S.1 { @ Space >= ^VIA2_S_1 um 
  EXT VIA2 < VIA2_S_1 ABUT < 90 SINGULAR REGION
}
VIA2.S.2 { @ Space to 3-neighboring VIAx (< 0.19 um distance) >= ^VIA2_S_2 um
  X = WITH NEIGHBOR VIA2_EXD > 2 SPACE < VIA2_S_2_S
  EXT X VIA2 < VIA2_S_2 ABUT < 90 SINGULAR REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// VIA2.S.3.R is checked by RR:VIA2.S.3
    RR:VIA2.S.3 { @ Two adjacent VIAx space between different net if the common run length > 0 um, >= 0.17 um
      VIA2_NODAL = STAMP VIA2 BY VIA2i
      EXT VIA2_NODAL < VIA2_S_3R ABUT < 90 NOT CONNECTED OPPOSITE REGION
    }
  #ENDIF
#ENDIF

// VIA2.EN.0 is checked by either {VIA2.EN.1/VIA2.EN.2} or VIA2.EN.3

VIA2.EN.1 { @ Enclosure by Mx or M1 >= ^VIA2_EN_1 um 
  ENC VIA2 M2 < VIA2_EN_1 ABUT < 90 SINGULAR REGION
  VIA2 NOT M2
}

// VIA2.EN.2 is checked by VIA2.EN.2__VIA2.EN.3
// VIA2.EN.3 is checked by VIA2.EN.2__VIA2.EN.3
VIA2.EN.2__VIA2.EN.3 { @ Enclosure by M2 [at least two opposite sides] >= ^VIA2_EN_2 , or [all sides] >= ^VIA2_EN_3
  X = RECTANGLE ENCLOSURE VIA2 M2 ABUT < 90 SINGULAR GOOD VIA2_EN_1 VIA2_EN_2 OPPOSITE VIA2_EN_1 VIA2_EN_2 OPPOSITE
ENC X M2 < VIA2_EN_3 ABUT < 90 SINGULAR REGION
}

// VIA2.R.1 is checked by VIA2.W.1
// VIA2.R.2 is checked by VIA2.R.2__VIA2.R.3
// VIA2.R.3 is checked by VIA2.R.2__VIA2.R.3
// VIA2.R.2.S80 is checked by VIA2.R.2__VIA2.R.3
// VIA2.R.3.S80 is checked by VIA2.R.2__VIA2.R.3
VIA2.R.2__VIA2.R.3 { @ When M2 or M3 width > ^VIA2_R_2_W um, more than one VIA2 is required.
                    @ 2 vias spacing should be <= ^VIA2_R_2_S1 um or 4 vias spacing should be <= ^VIA2_R_2_S2 um
                    @ or 9 vias spacing should be <= ^VIA2_R_2_S3 um
                    @ When M2 or M3 width > ^VIA2_R_3_W um, more than three VIA2 is required.
                    @ 4 vias spacing should be <= ^VIA2_R_3_S1 um or 9 vias spacing should be <= ^VIA2_R_3_S2 um

M3OvpM2_W_ = (M2Wide_0.42_VIA2 AND M3) OR (M3Wide_0.42_VIA2 AND M2)
M3OvpM2_B  = (M2Wide_1.14_VIA2 AND M3) OR (M3Wide_1.14_VIA2 AND M2)
M3OvpM2_W  = M3OvpM2_W_ NOT M3OvpM2_B 
Checked_VIA2_W_ = VIA2_EXD NOT OUTSIDE M3OvpM2_W
Checked_VIA2_B  = VIA2_EXD NOT OUTSIDE M3OvpM2_B
Checked_VIA2_W  = Checked_VIA2_W_ NOT Checked_VIA2_B

M2_effect = M2i INTERACT M3OvpM2_W_
M3_effect = M3i INTERACT M3OvpM2_W_
effect_M3OvpM2_ = M2_effect AND M3_effect
effect_M3OvpM2 = effect_M3OvpM2_ INTERACT M3OvpM2_W_
effect_VIA = VIA2_EXD INTERACT effect_M3OvpM2
    
V2Merged_A = SIZE effect_VIA BY VIA2_R_2_S1/2 INSIDE OF effect_M3OvpM2 STEP 0.098
V2Merged_B = SIZE V2Merged_A BY (VIA2_R_2_S2 - VIA2_R_2_S1)/2 INSIDE OF effect_M3OvpM2 STEP 0.098
V2Merged_C = SIZE V2Merged_B BY (VIA2_R_3_S2 - VIA2_R_2_S2)/2 INSIDE OF effect_M3OvpM2 STEP 0.098
V2Merged_A2R = V2Merged_A INTERACT effect_VIA < 2
V2Merged_A2 = V2Merged_A OUTSIDE V2Merged_A2R
V2Merged_A4R = V2Merged_A2 INTERACT effect_VIA < 4
V2Merged_A4 = V2Merged_A2 OUTSIDE V2Merged_A4R
V2Merged_B4R = V2Merged_B INTERACT effect_VIA < 4
V2Merged_B4 = V2Merged_B OUTSIDE V2Merged_B4R
V2Merged_C9R = V2Merged_C INTERACT effect_VIA < 9
V2Merged_C9 = V2Merged_C OUTSIDE V2Merged_C9R

GMergeW = (V2Merged_A2 OR V2Merged_B4) OR V2Merged_C9
GMergeB = V2Merged_A4 OR V2Merged_C9

GVIA_W = Checked_VIA2_W INTERACT GMergeW
GVIA_B = Checked_VIA2_B INTERACT GMergeB
GOOD_AREA_W = M3OvpM2_W INTERACT GVIA_W
GOOD_AREA_B = M3OvpM2_B INTERACT GVIA_B
Checked_VIA2_W OUTSIDE GOOD_AREA_W
Checked_VIA2_B OUTSIDE GOOD_AREA_B
}
// VIA2.R.4 is checked by VIA2.R.4:M2
// VIA2.R.4.S80 is checked by VIA2.R.4:M2
VIA2.R.4:M2 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M2Wide_0.7_VIA2 BY VIA2_R_4_D + GRID) NOT M2Wide_0.7_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_0.7_VIA2) INTERACT VIA2
  Branch1Edge = M2Wide_0.7_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M2_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA2.R.4 is checked by VIA2.R.4:M3
// VIA2.R.4.S80 is checked by VIA2.R.4:M3
VIA2.R.4:M3 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M3Wide_0.7_VIA2 BY VIA2_R_4_D + GRID) NOT M3Wide_0.7_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_0.7_VIA2) INTERACT VIA2
  Branch1Edge = M3Wide_0.7_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M2) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA2.R.5 is checked by VIA2.R.5:M2
// VIA2.R.5.S80 is checked by VIA2.R.5:M2
VIA2.R.5:M2 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M2Wide_2_VIA2 BY VIA2_R_5_D + GRID) NOT M2Wide_2_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Wide_2_VIA2) INTERACT VIA2
  Branch1Edge = M2Wide_2_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA2.R.5 is checked by VIA2.R.5:M3
// VIA2.R.5.S80 is checked by VIA2.R.5:M3
VIA2.R.5:M3 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M3Wide_2_VIA2 BY VIA2_R_5_D + GRID) NOT M3Wide_2_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_2_VIA2) INTERACT VIA2
  Branch1Edge = M3Wide_2_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M2Big_3_VIA2 = ENCLOSE RECTANGLE M2Wide_3_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID
// VIA2.R.6 is checked by VIA2.R.6:M2
// VIA2.R.6.S80 is checked by VIA2.R.6:M2
VIA2.R.6:M2 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M2Big_3_VIA2 BY VIA2_R_6_D + GRID) NOT M2Big_3_VIA2) AND M2
  Branch1HasVia = (Branch1 INTERACT M2Big_3_VIA2) INTERACT VIA2
  Branch1Edge = M2Big_3_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M2_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M2) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M3Big_3_VIA2 = ENCLOSE RECTANGLE M3Wide_3_VIA2 VIA2_R_6_W VIA2_R_6_L+GRID
// VIA2.R.6 is checked by VIA2.R.6:M3
// VIA2.R.6.S80 is checked by VIA2.R.6:M3
VIA2.R.6:M3 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M3Big_3_VIA2 BY VIA2_R_6_D + GRID) NOT M3Big_3_VIA2) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_3_VIA2) INTERACT VIA2
  Branch1Edge = M3Big_3_VIA2 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA2_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M2) INTERACT VIA2 > 1
  BranchSingleVia = (VIA2 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M2 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA2 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA2.R.7 is checked by VIA2.EN.1
// VIA2.R.9 can't be checked


VIA2.R.11 { @ Single VIAx is not allowed for mesh-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has mesh-shape interact with two metal holes : both two metal hole area <= ^VIA2_R_11_A um2 and two metal hole length(L2) <= ^VIA2_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this mesh-shape Mx+1 
@ 3. The length (L) of the center metal bar <= 1um and the width of metal bar is <= 0.42um. 



    
  W = M3i WITH WIDTH <= VIA2_R_11_W   
  H_HOLE = (HOLES M3i INNER <= VIA2_R_11_A) INTERACT W
  A0 = M3i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA2_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA2_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA2_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA2_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA2_R_11_L+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA2i
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA2_R_11_L2 OPPOSITE  
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA2i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M2i INTERACT CHECK_VIA)) INTERACT VIA2i == 1)
}


//M3 CHECKS
//=========
#IFDEF N80
  M3A = M3Wide_N80first NOT CB_NON_CUP
#ENDIF

M31 = M3Wide_first NOT CB_NON_CUP
M32 = M3Wide_1.5 NOT CB_NON_CUP
M33 = M3Wide_4.5 NOT CB_NON_CUP


VARIABLE M3_A_2pre ((M3_A_2 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))*((M3_A_2 + (M3_S_1 * M3_S_1 * 3.142))/(2 * M3_S_1))/3.141

M3HO = HOLES M3 INNER < M3_A_2pre

M3HOC = M3HO NOT M3

M3AS3 = AREA M3 > M3_S_3_L*M3_W_1  // filter small metal for M3.S.3
M3AS4 = AREA M3AS3 > M3_S_4_L*M3_W_1  // filter small metal for M3.S.4

M3.W.1 { @ Width >= ^M3_W_1 um 
  INT M3 < M3_W_1 ABUT < 90 SINGULAR REGION
}
M3.W.2 { @ Width of 45-degree bent Mx >= ^M3_W_2 um 
  INT M3_EDGE_45 < M3_W_2 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M3.W.2.R is checked by RR:M3.W.2
    RR:M3.W.2 { @ Width of 45-degree bent Mx >= ^M3_W_2R um 
      INT M3_EDGE_45 < M3_W_2R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF


M3.W.3 { @ Maximum width [Except WBDMY, if Mx is Mtop-1 layer] <= ^M3_W_3 um 
  SIZE M3 BY M3_W_3 /2 UNDEROVER TRUNCATE M3_W_3 /2
}
M3.S.1 { @ Space >= ^M3_S_1 um 
  EXT M3 < M3_S_1 ABUT < 90 SINGULAR REGION
}
// M3.S.2.S80 is checked by M3.S.2
M3.S.2 { @ Space [at least one metal line width > M3_S_2_W um and the parallel metal run length > M3_S_2_L um] >= ^M3_S_2 um
  X = EXT M31 M3 < M3_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_L+GRID
}
#IFDEF N80
  M3.S.2.1.S80 { @ Space [at least one metal line width > 0.21um(W1) and the parallel metal run length > 0.8um(L1)] >= 0.15um
  X = EXT M3A M3 < M3_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_2_1_L+GRID
  }
#ENDIF


// M3.S.3.S80 is checked by M3.S.3
M3.S.3 { @ Space [at least one metal line width > M3_S_3_W um and the parallel metal run length > M3_S_3_L um] >= ^M3_S_3 um
  X = EXT M32 M3AS3 < M3_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_3_L+GRID
}
// M3.S.4.S80 is checked by M3.S.4
M3.S.4 { @ Space [at least one metal line width > M3_S_4_W um and the parallel metal run length > M3_S_4_L um] >= ^M3_S_4 um
  X = EXT M33 M3AS4 < M3_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M3
  ENCLOSE RECTANGLE Y GRID M3_S_4_L+GRID
}
M3.S.5 { @ Space to 45-degree bent Mx >= ^M3_S_5 um 
  X = EXPAND EDGE M3_EDGE_45 OUTSIDE BY M3_S_5
  X AND M3
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M3.S.5.R is checked by RR:M3.S.5
    RR:M3.S.5 { @ Mx space to 45-degree bent Mx >= ^M3_S_5R um 
      X = EXPAND EDGE M3_EDGE_45 OUTSIDE BY M3_S_5R
      X AND M3
    }
  #ENDIF
#ENDIF

// M3.EN.0 is checked by either {M3.EN.1/M3.EN.2} or M3.EN.3
M3.EN.1 { @ Enclosure of VIAx-1 >= ^M3_EN_1 um 
  ENC VIA2 M3 < M3_EN_1 ABUT < 90 SINGULAR REGION
  VIA2 NOT M3
}
// M3.EN.2 is checked by M3.EN.2__M3.EN.3
// M3.EN.3 is checked by M3.EN.2__M3.EN.3
M3.EN.2__M3.EN.3 { @ Enclosure of VIAx-1 [at least 2 opposite sides] >= ^M3_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA2 M3 ABUT < 90 SINGULAR GOOD M3_EN_1 M3_EN_2 OPPOSITE M3_EN_1 M3_EN_2 OPPOSITE
  ENC X M3 < M3_EN_3 ABUT < 90 SINGULAR REGION
}

M3.A.1 { @ Area >= ^M3_A_1 um2
  AREA M3 < M3_A_1
}
M3.A.2 { @ Enclosed area >= ^M3_A_2 um
  AREA M3HOC < M3_A_2
}


CHIP_NOT_M3_EXC_HIGH = CHIP NOT M3_EXC_H  // for high density check
M3_NOT_EXC_HIGH = M3x NOT M3_EXC_H       // for high density check 
CHIP_NOT_M3_EXC_L = CHIP NOT M3_EXC_L1    // for low density check
M3_NOT_EXC_L = M3x NOT M3_EXC_L1         // for low density check

// For density check in DMxEXCL
CHIP_AND_DM3EXCL_HIGH = CHIP_NOT_M3_EXC_HIGH AND DM3EXCL  // for high density check
M3_AND_DM3EXCL_HIGH = M3_NOT_EXC_HIGH AND DM3EXCL        // for high density check
CHIP_AND_DM3EXCL = CHIP_NOT_M3_EXC_L AND DM3EXCL 	     // for low density check
M3_AND_DM3EXCL = M3_NOT_EXC_L AND DM3EXCL                // for low density check

#IFDEF DENSITY_IN_BLOCKAGE
// M3.DN.3 is checked by M3.DN.3:L
// M3.DN.3a is checked by M3.DN.3:L
M3.DN.3:L { @ M3 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um (with DM3EXCL region)
  ERR1 = DENSITY M3_AND_DM3EXCL CHIP_AND_DM3EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]
  ERR2 = DENSITY M3_NOT_EXC_L CHIP_NOT_M3_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_NOT_EXC_L)/AREA(CHIP_NOT_M3_EXC_L) ]	
  K = SIZE (((ERR1 AND DM3EXCL) INSIDE ERR2) NOT M3_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M3_AND_DM3EXCL CHIP_AND_DM3EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M3.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]

}
// M3.DN.3 is checked by M3.DN.3:H 
// M3.DN.3d is checked by M3.DN.3:H 
M3.DN.3:H { @ M3 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 umx ^Mx_DN_W2 um step 50um (with DM3EXCL region)
  ERR1 = DENSITY M3_AND_DM3EXCL_HIGH CHIP_AND_DM3EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_AND_DM3EXCL_HIGH)/AREA(CHIP_AND_DM3EXCL_HIGH) ]
  ERR2 = DENSITY M3_NOT_EXC_HIGH CHIP_NOT_M3_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_NOT_EXC_HIGH)/AREA(CHIP_NOT_M3_EXC_HIGH) ]
  K = SIZE (((ERR1 AND DM3EXCL) INSIDE ERR2) NOT M3_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M3_AND_DM3EXCL_HIGH CHIP_AND_DM3EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M3.DN.3H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*(AREA(M3_AND_DM3EXCL_HIGH)/AREA(CHIP_AND_DM3EXCL_HIGH)) ]
}
#ELSE
#IFDEF FULL_CHIP
// M3.DN.1 is checked by M3.DN.1__M3.DN.3:L
// M3.DN.3 is checked by M3.DN.1__M3.DN.3:L
// M3.DN.1a is checked by M3.DN.1__M3.DN.3:L
// M3.DN.3a is checked by M3.DN.1__M3.DN.3:L
M3.DN.1__M3.DN.3:L { @ M3 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M3_NOT_EXC_L CHIP_NOT_M3_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
[ AREA(M3_NOT_EXC_L)/AREA(CHIP_NOT_M3_EXC_L) ]
  K = SIZE (ERR_WIN NOT M3_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M3_NOT_EXC_L CHIP_NOT_M3_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M3.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M3_NOT_EXC_L)/AREA(CHIP_NOT_M3_EXC_L) ]
}
#ELSE  // IP/macro/block level
#IFDEF DENSITY_FOR_NONFULLCHIP
// M3.DN.1 is checked by M3.DN.1__M3.DN.3:L
// M3.DN.3 is checked by M3.DN.1__M3.DN.3:L
// M3.DN.1a is checked by M3.DN.1__M3.DN.3:L
// M3.DN.3a is checked by M3.DN.1__M3.DN.3:L
M3.DN.1__M3.DN.3:L { @ M3 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M3_NOT_EXC_L CHIP_NOT_M3_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_NOT_EXC_L)/AREA(CHIP_NOT_M3_EXC_L) ]
  K = SIZE (ERR_WIN NOT M3_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M3_NOT_EXC_L CHIP_NOT_M3_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M3.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M3_NOT_EXC_L)/AREA(CHIP_NOT_M3_EXC_L) ]
}
#ELSE
// M3.DN.3 is checked by M3.DN.3:L
// M3.DN.3a is checked by M3.DN.3:L
M3.DN.3:L { @ M3 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um (with DM3EXCL region)
  ERR1 = DENSITY M3_AND_DM3EXCL CHIP_AND_DM3EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]
  ERR2 = DENSITY M3_NOT_EXC_L CHIP_NOT_M3_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_NOT_EXC_L)/AREA(CHIP_NOT_M3_EXC_L) ]
  K = SIZE (((ERR1 AND DM3EXCL) INSIDE ERR2) NOT M3_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2 
  DENSITY K M3_AND_DM3EXCL CHIP_AND_DM3EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M3.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M3_AND_DM3EXCL)/AREA(CHIP_AND_DM3EXCL) ]
}
#ENDIF
#ENDIF
// M3.DN.1 is checked by M3.DN.1__M3.DN.3:H
// M3.DN.3 is checked by M3.DN.1__M3.DN.3:H
// M3.DN.1d is checked by M3.DN.1__M3.DN.3:H
// M3.DN.3d is checked by M3.DN.1__M3.DN.3:H
M3.DN.1__M3.DN.3:H { @ M3 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 um x ^Mx_DN_W2 um step 50um 
  ERR_WIN = DENSITY M3_NOT_EXC_HIGH CHIP_NOT_M3_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M3_NOT_EXC_HIGH)/AREA(CHIP_NOT_M3_EXC_HIGH) ]
  K = SIZE (ERR_WIN NOT M3_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M3_NOT_EXC_HIGH CHIP_NOT_M3_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M3.DN.1H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*AREA(M3_NOT_EXC_HIGH)/AREA(CHIP_NOT_M3_EXC_HIGH) ]
}
#ENDIF

M3.DN.2 { @ M3 local density must be < 90% range over 20umx20um step 10um
  DENSITY M3x CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M3.DN.2.density 
    [ AREA(M3x)/AREA(CHIP) ]
}  

// M3.R.1 can not be checked


//VIA3 CHECKS
//===========
#IFDEF N80
  M4Wide_N80first = (SIZE M4 BY M4_S_2_1_W /2 UNDEROVER TRUNCATE M4_S_2_1_W /2) AND M4
#ENDIF

M4Wide_first = (SIZE M4 BY M4_S_2_W /2 UNDEROVER TRUNCATE M4_S_2_W /2) AND M4
M4Wide_1.5 = (SIZE M4Wide_first BY M4_S_3_W /2 UNDEROVER TRUNCATE M4_S_3_W /2) AND M4Wide_first
M4Wide_4.5 = (SIZE M4Wide_1.5 BY M4_S_4_W /2 UNDEROVER TRUNCATE M4_S_4_W /2) AND M4Wide_1.5

M3Wide_0.42_VIA3 = (SIZE M3Wide_first BY VIA3_R_2_W /2 UNDEROVER TRUNCATE VIA3_R_2_W /2) AND M3Wide_first 
M3Wide_0.7_VIA3 = (SIZE M3Wide_0.42_VIA3 BY VIA3_R_4_W /2 UNDEROVER TRUNCATE VIA3_R_4_W /2) AND M3Wide_0.42_VIA3
M3Wide_1.14_VIA3 = (SIZE M3Wide_0.7_VIA3 BY VIA3_R_3_W /2 UNDEROVER TRUNCATE VIA3_R_3_W /2) AND M3Wide_0.7_VIA3
M3Wide_2_VIA3 = (SIZE M3Wide_1.14_VIA3 BY VIA3_R_5_W /2 UNDEROVER TRUNCATE VIA3_R_5_W /2) AND M3Wide_1.14_VIA3
M3Wide_3_VIA3 = (SIZE M3Wide_2_VIA3 BY VIA3_R_6_W /2 UNDEROVER TRUNCATE VIA3_R_6_W /2) AND M3Wide_2_VIA3
M4Wide_0.42_VIA3 = (SIZE M4Wide_first BY VIA3_R_2_W /2 UNDEROVER TRUNCATE VIA3_R_2_W /2) AND M4Wide_first 
M4Wide_0.7_VIA3 = (SIZE M4Wide_0.42_VIA3 BY VIA3_R_4_W /2 UNDEROVER TRUNCATE VIA3_R_4_W /2) AND M4Wide_0.42_VIA3
M4Wide_1.14_VIA3 = (SIZE M4Wide_0.7_VIA3 BY VIA3_R_3_W /2 UNDEROVER TRUNCATE VIA3_R_3_W /2) AND M4Wide_0.7_VIA3 
M4Wide_2_VIA3 = (SIZE M4Wide_1.14_VIA3 BY VIA3_R_5_W /2 UNDEROVER TRUNCATE VIA3_R_5_W /2) AND M4Wide_1.14_VIA3
M4Wide_3_VIA3 = (SIZE M4Wide_2_VIA3 BY VIA3_R_6_W /2 UNDEROVER TRUNCATE VIA3_R_6_W /2) AND M4Wide_2_VIA3 

VIA3.W.1 { @ Width (square) (maximum = minimum) = ^VIA3_W_1 um
  A = NOT RECTANGLE VIA3 == VIA3_W_1 BY == VIA3_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA3.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA3_W_2 um
  INT SR_VIA3 < VIA3_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_VIA3 BY VIA3_W_2 /2 + GRID UNDEROVER TRUNCATE VIA3_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA3.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA3_W_2 um
  INT SR_VIA3 < VIA3_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_VIA3 BY VIA3_W_2 /2 + GRID UNDEROVER TRUNCATE VIA3_W_2 /2 + GRID
}
#ENDIF
VIA3.S.1 { @ Space >= ^VIA3_S_1 um 
  EXT VIA3 < VIA3_S_1 ABUT < 90 SINGULAR REGION
}
VIA3.S.2 { @ Space to 3-neighboring VIAx (< 0.19 um distance) >= ^VIA3_S_2 um
  X = WITH NEIGHBOR VIA3_EXD > 2 SPACE < VIA3_S_2_S
  EXT X VIA3 < VIA3_S_2 ABUT < 90 SINGULAR REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// VIA3.S.3.R is checked by RR:VIA3.S.3
    RR:VIA3.S.3 { @ Two adjacent VIAx space between different net if the common run length > 0 um, >= 0.17 um
      VIA3_NODAL = STAMP VIA3 BY VIA3i
      EXT VIA3_NODAL < VIA3_S_3R ABUT < 90 NOT CONNECTED OPPOSITE REGION
    }
  #ENDIF
#ENDIF

// VIA3.EN.0 is checked by either {VIA3.EN.1/VIA3.EN.2} or VIA3.EN.3

VIA3.EN.1 { @ Enclosure by Mx or M1 >= ^VIA3_EN_1 um 
  ENC VIA3 M3 < VIA3_EN_1 ABUT < 90 SINGULAR REGION
  VIA3 NOT M3
}

// VIA3.EN.2 is checked by VIA3.EN.2__VIA3.EN.3
// VIA3.EN.3 is checked by VIA3.EN.2__VIA3.EN.3
VIA3.EN.2__VIA3.EN.3 { @ Enclosure by M3 [at least two opposite sides] >= ^VIA3_EN_2 , or [all sides] >= ^VIA3_EN_3
  X = RECTANGLE ENCLOSURE VIA3 M3 ABUT < 90 SINGULAR GOOD VIA3_EN_1 VIA3_EN_2 OPPOSITE VIA3_EN_1 VIA3_EN_2 OPPOSITE
ENC X M3 < VIA3_EN_3 ABUT < 90 SINGULAR REGION
}

// VIA3.R.1 is checked by VIA3.W.1
// VIA3.R.2 is checked by VIA3.R.2__VIA3.R.3
// VIA3.R.3 is checked by VIA3.R.2__VIA3.R.3
// VIA3.R.2.S80 is checked by VIA3.R.2__VIA3.R.3
// VIA3.R.3.S80 is checked by VIA3.R.2__VIA3.R.3
VIA3.R.2__VIA3.R.3 { @ When M3 or M4 width > ^VIA3_R_2_W um, more than one VIA3 is required.
                    @ 2 vias spacing should be <= ^VIA3_R_2_S1 um or 4 vias spacing should be <= ^VIA3_R_2_S2 um
                    @ or 9 vias spacing should be <= ^VIA3_R_2_S3 um
                    @ When M3 or M4 width > ^VIA3_R_3_W um, more than three VIA3 is required.
                    @ 4 vias spacing should be <= ^VIA3_R_3_S1 um or 9 vias spacing should be <= ^VIA3_R_3_S2 um

M4OvpM3_W_ = (M3Wide_0.42_VIA3 AND M4) OR (M4Wide_0.42_VIA3 AND M3)
M4OvpM3_B  = (M3Wide_1.14_VIA3 AND M4) OR (M4Wide_1.14_VIA3 AND M3)
M4OvpM3_W  = M4OvpM3_W_ NOT M4OvpM3_B 
Checked_VIA3_W_ = VIA3_EXD NOT OUTSIDE M4OvpM3_W
Checked_VIA3_B  = VIA3_EXD NOT OUTSIDE M4OvpM3_B
Checked_VIA3_W  = Checked_VIA3_W_ NOT Checked_VIA3_B

M3_effect = M3i INTERACT M4OvpM3_W_
M4_effect = M4i INTERACT M4OvpM3_W_
effect_M4OvpM3_ = M3_effect AND M4_effect
effect_M4OvpM3 = effect_M4OvpM3_ INTERACT M4OvpM3_W_
effect_VIA = VIA3_EXD INTERACT effect_M4OvpM3
    
V3Merged_A = SIZE effect_VIA BY VIA3_R_2_S1/2 INSIDE OF effect_M4OvpM3 STEP 0.098
V3Merged_B = SIZE V3Merged_A BY (VIA3_R_2_S2 - VIA3_R_2_S1)/2 INSIDE OF effect_M4OvpM3 STEP 0.098
V3Merged_C = SIZE V3Merged_B BY (VIA3_R_3_S2 - VIA3_R_2_S2)/2 INSIDE OF effect_M4OvpM3 STEP 0.098
V3Merged_A2R = V3Merged_A INTERACT effect_VIA < 2
V3Merged_A2 = V3Merged_A OUTSIDE V3Merged_A2R
V3Merged_A4R = V3Merged_A2 INTERACT effect_VIA < 4
V3Merged_A4 = V3Merged_A2 OUTSIDE V3Merged_A4R
V3Merged_B4R = V3Merged_B INTERACT effect_VIA < 4
V3Merged_B4 = V3Merged_B OUTSIDE V3Merged_B4R
V3Merged_C9R = V3Merged_C INTERACT effect_VIA < 9
V3Merged_C9 = V3Merged_C OUTSIDE V3Merged_C9R

GMergeW = (V3Merged_A2 OR V3Merged_B4) OR V3Merged_C9
GMergeB = V3Merged_A4 OR V3Merged_C9

GVIA_W = Checked_VIA3_W INTERACT GMergeW
GVIA_B = Checked_VIA3_B INTERACT GMergeB
GOOD_AREA_W = M4OvpM3_W INTERACT GVIA_W
GOOD_AREA_B = M4OvpM3_B INTERACT GVIA_B
Checked_VIA3_W OUTSIDE GOOD_AREA_W
Checked_VIA3_B OUTSIDE GOOD_AREA_B
}
// VIA3.R.4 is checked by VIA3.R.4:M3
// VIA3.R.4.S80 is checked by VIA3.R.4:M3
VIA3.R.4:M3 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M3Wide_0.7_VIA3 BY VIA3_R_4_D + GRID) NOT M3Wide_0.7_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_0.7_VIA3) INTERACT VIA3
  Branch1Edge = M3Wide_0.7_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M3_S_1*0.5
  GoodBranch = (Branch AND M4) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA3.R.4 is checked by VIA3.R.4:M4
// VIA3.R.4.S80 is checked by VIA3.R.4:M4
VIA3.R.4:M4 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M4Wide_0.7_VIA3 BY VIA3_R_4_D + GRID) NOT M4Wide_0.7_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_0.7_VIA3) INTERACT VIA3
  Branch1Edge = M4Wide_0.7_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_4_D INSIDE OF Branch1HasVia STEP M4_S_1*0.5
  GoodBranch = (Branch AND M3) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA3.R.5 is checked by VIA3.R.5:M3
// VIA3.R.5.S80 is checked by VIA3.R.5:M3
VIA3.R.5:M3 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M3Wide_2_VIA3 BY VIA3_R_5_D + GRID) NOT M3Wide_2_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Wide_2_VIA3) INTERACT VIA3
  Branch1Edge = M3Wide_2_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA3.R.5 is checked by VIA3.R.5:M4
// VIA3.R.5.S80 is checked by VIA3.R.5:M4
VIA3.R.5:M4 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M4Wide_2_VIA3 BY VIA3_R_5_D + GRID) NOT M4Wide_2_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_2_VIA3) INTERACT VIA3
  Branch1Edge = M4Wide_2_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_5_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M3Big_3_VIA3 = ENCLOSE RECTANGLE M3Wide_3_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID
// VIA3.R.6 is checked by VIA3.R.6:M3
// VIA3.R.6.S80 is checked by VIA3.R.6:M3
VIA3.R.6:M3 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M3Big_3_VIA3 BY VIA3_R_6_D + GRID) NOT M3Big_3_VIA3) AND M3
  Branch1HasVia = (Branch1 INTERACT M3Big_3_VIA3) INTERACT VIA3
  Branch1Edge = M3Big_3_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M3_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M3) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M4Big_3_VIA3 = ENCLOSE RECTANGLE M4Wide_3_VIA3 VIA3_R_6_W VIA3_R_6_L+GRID
// VIA3.R.6 is checked by VIA3.R.6:M4
// VIA3.R.6.S80 is checked by VIA3.R.6:M4
VIA3.R.6:M4 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M4Big_3_VIA3 BY VIA3_R_6_D + GRID) NOT M4Big_3_VIA3) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_3_VIA3) INTERACT VIA3
  Branch1Edge = M4Big_3_VIA3 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA3_R_6_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M3) INTERACT VIA3 > 1
  BranchSingleVia = (VIA3 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M3 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA3 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA3.R.7 is checked by VIA3.EN.1
// VIA3.R.9 can't be checked


VIA3.R.11 { @ Single VIAx is not allowed for mesh-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has mesh-shape interact with two metal holes : both two metal hole area <= ^VIA3_R_11_A um2 and two metal hole length(L2) <= ^VIA3_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this mesh-shape Mx+1 
@ 3. The length (L) of the center metal bar <= 1um and the width of metal bar is <= 0.42um. 



    
  W = M4i WITH WIDTH <= VIA3_R_11_W   
  H_HOLE = (HOLES M4i INNER <= VIA3_R_11_A) INTERACT W
  A0 = M4i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA3_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA3_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA3_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA3_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA3_R_11_L+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA3i
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA3_R_11_L2 OPPOSITE  
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA3i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M3i INTERACT CHECK_VIA)) INTERACT VIA3i == 1)
}


//M4 CHECKS
//=========
#IFDEF N80
  M4A = M4Wide_N80first NOT CB_NON_CUP
#ENDIF

M41 = M4Wide_first NOT CB_NON_CUP
M42 = M4Wide_1.5 NOT CB_NON_CUP
M43 = M4Wide_4.5 NOT CB_NON_CUP


VARIABLE M4_A_2pre ((M4_A_2 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))*((M4_A_2 + (M4_S_1 * M4_S_1 * 3.142))/(2 * M4_S_1))/3.141

M4HO = HOLES M4 INNER < M4_A_2pre

M4HOC = M4HO NOT M4

M4AS3 = AREA M4 > M4_S_3_L*M4_W_1  // filter small metal for M4.S.3
M4AS4 = AREA M4AS3 > M4_S_4_L*M4_W_1  // filter small metal for M4.S.4

M4.W.1 { @ Width >= ^M4_W_1 um 
  INT M4 < M4_W_1 ABUT < 90 SINGULAR REGION
}
M4.W.2 { @ Width of 45-degree bent Mx >= ^M4_W_2 um 
  INT M4_EDGE_45 < M4_W_2 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M4.W.2.R is checked by RR:M4.W.2
    RR:M4.W.2 { @ Width of 45-degree bent Mx >= ^M4_W_2R um 
      INT M4_EDGE_45 < M4_W_2R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF


M4.W.3 { @ Maximum width [Except WBDMY, if Mx is Mtop-1 layer] <= ^M4_W_3 um 
  SIZE M4 BY M4_W_3 /2 UNDEROVER TRUNCATE M4_W_3 /2
}
M4.S.1 { @ Space >= ^M4_S_1 um 
  EXT M4 < M4_S_1 ABUT < 90 SINGULAR REGION
}
// M4.S.2.S80 is checked by M4.S.2
M4.S.2 { @ Space [at least one metal line width > M4_S_2_W um and the parallel metal run length > M4_S_2_L um] >= ^M4_S_2 um
  X = EXT M41 M4 < M4_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_L+GRID
}
#IFDEF N80
  M4.S.2.1.S80 { @ Space [at least one metal line width > 0.21um(W1) and the parallel metal run length > 0.8um(L1)] >= 0.15um
  X = EXT M4A M4 < M4_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_2_1_L+GRID
  }
#ENDIF


// M4.S.3.S80 is checked by M4.S.3
M4.S.3 { @ Space [at least one metal line width > M4_S_3_W um and the parallel metal run length > M4_S_3_L um] >= ^M4_S_3 um
  X = EXT M42 M4AS3 < M4_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_3_L+GRID
}
// M4.S.4.S80 is checked by M4.S.4
M4.S.4 { @ Space [at least one metal line width > M4_S_4_W um and the parallel metal run length > M4_S_4_L um] >= ^M4_S_4 um
  X = EXT M43 M4AS4 < M4_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M4
  ENCLOSE RECTANGLE Y GRID M4_S_4_L+GRID
}
M4.S.5 { @ Space to 45-degree bent Mx >= ^M4_S_5 um 
  X = EXPAND EDGE M4_EDGE_45 OUTSIDE BY M4_S_5
  X AND M4
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M4.S.5.R is checked by RR:M4.S.5
    RR:M4.S.5 { @ Mx space to 45-degree bent Mx >= ^M4_S_5R um 
      X = EXPAND EDGE M4_EDGE_45 OUTSIDE BY M4_S_5R
      X AND M4
    }
  #ENDIF
#ENDIF

// M4.EN.0 is checked by either {M4.EN.1/M4.EN.2} or M4.EN.3
M4.EN.1 { @ Enclosure of VIAx-1 >= ^M4_EN_1 um 
  ENC VIA3 M4 < M4_EN_1 ABUT < 90 SINGULAR REGION
  VIA3 NOT M4
}
// M4.EN.2 is checked by M4.EN.2__M4.EN.3
// M4.EN.3 is checked by M4.EN.2__M4.EN.3
M4.EN.2__M4.EN.3 { @ Enclosure of VIAx-1 [at least 2 opposite sides] >= ^M4_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA3 M4 ABUT < 90 SINGULAR GOOD M4_EN_1 M4_EN_2 OPPOSITE M4_EN_1 M4_EN_2 OPPOSITE
  ENC X M4 < M4_EN_3 ABUT < 90 SINGULAR REGION
}

M4.A.1 { @ Area >= ^M4_A_1 um2
  AREA M4 < M4_A_1
}
M4.A.2 { @ Enclosed area >= ^M4_A_2 um
  AREA M4HOC < M4_A_2
}


CHIP_NOT_M4_EXC_HIGH = CHIP NOT M4_EXC_H  // for high density check
M4_NOT_EXC_HIGH = M4x NOT M4_EXC_H       // for high density check 
CHIP_NOT_M4_EXC_L = CHIP NOT M4_EXC_L1    // for low density check
M4_NOT_EXC_L = M4x NOT M4_EXC_L1         // for low density check

// For density check in DMxEXCL
CHIP_AND_DM4EXCL_HIGH = CHIP_NOT_M4_EXC_HIGH AND DM4EXCL  // for high density check
M4_AND_DM4EXCL_HIGH = M4_NOT_EXC_HIGH AND DM4EXCL        // for high density check
CHIP_AND_DM4EXCL = CHIP_NOT_M4_EXC_L AND DM4EXCL 	     // for low density check
M4_AND_DM4EXCL = M4_NOT_EXC_L AND DM4EXCL                // for low density check

#IFDEF DENSITY_IN_BLOCKAGE
// M4.DN.3 is checked by M4.DN.3:L
// M4.DN.3a is checked by M4.DN.3:L
M4.DN.3:L { @ M4 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um (with DM4EXCL region)
  ERR1 = DENSITY M4_AND_DM4EXCL CHIP_AND_DM4EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]
  ERR2 = DENSITY M4_NOT_EXC_L CHIP_NOT_M4_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_NOT_EXC_L)/AREA(CHIP_NOT_M4_EXC_L) ]	
  K = SIZE (((ERR1 AND DM4EXCL) INSIDE ERR2) NOT M4_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M4_AND_DM4EXCL CHIP_AND_DM4EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M4.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]

}
// M4.DN.3 is checked by M4.DN.3:H 
// M4.DN.3d is checked by M4.DN.3:H 
M4.DN.3:H { @ M4 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 umx ^Mx_DN_W2 um step 50um (with DM4EXCL region)
  ERR1 = DENSITY M4_AND_DM4EXCL_HIGH CHIP_AND_DM4EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_AND_DM4EXCL_HIGH)/AREA(CHIP_AND_DM4EXCL_HIGH) ]
  ERR2 = DENSITY M4_NOT_EXC_HIGH CHIP_NOT_M4_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_NOT_EXC_HIGH)/AREA(CHIP_NOT_M4_EXC_HIGH) ]
  K = SIZE (((ERR1 AND DM4EXCL) INSIDE ERR2) NOT M4_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M4_AND_DM4EXCL_HIGH CHIP_AND_DM4EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M4.DN.3H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*(AREA(M4_AND_DM4EXCL_HIGH)/AREA(CHIP_AND_DM4EXCL_HIGH)) ]
}
#ELSE
#IFDEF FULL_CHIP
// M4.DN.1 is checked by M4.DN.1__M4.DN.3:L
// M4.DN.3 is checked by M4.DN.1__M4.DN.3:L
// M4.DN.1a is checked by M4.DN.1__M4.DN.3:L
// M4.DN.3a is checked by M4.DN.1__M4.DN.3:L
M4.DN.1__M4.DN.3:L { @ M4 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M4_NOT_EXC_L CHIP_NOT_M4_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
[ AREA(M4_NOT_EXC_L)/AREA(CHIP_NOT_M4_EXC_L) ]
  K = SIZE (ERR_WIN NOT M4_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M4_NOT_EXC_L CHIP_NOT_M4_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M4.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M4_NOT_EXC_L)/AREA(CHIP_NOT_M4_EXC_L) ]
}
#ELSE  // IP/macro/block level
#IFDEF DENSITY_FOR_NONFULLCHIP
// M4.DN.1 is checked by M4.DN.1__M4.DN.3:L
// M4.DN.3 is checked by M4.DN.1__M4.DN.3:L
// M4.DN.1a is checked by M4.DN.1__M4.DN.3:L
// M4.DN.3a is checked by M4.DN.1__M4.DN.3:L
M4.DN.1__M4.DN.3:L { @ M4 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M4_NOT_EXC_L CHIP_NOT_M4_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_NOT_EXC_L)/AREA(CHIP_NOT_M4_EXC_L) ]
  K = SIZE (ERR_WIN NOT M4_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M4_NOT_EXC_L CHIP_NOT_M4_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M4.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M4_NOT_EXC_L)/AREA(CHIP_NOT_M4_EXC_L) ]
}
#ELSE
// M4.DN.3 is checked by M4.DN.3:L
// M4.DN.3a is checked by M4.DN.3:L
M4.DN.3:L { @ M4 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um (with DM4EXCL region)
  ERR1 = DENSITY M4_AND_DM4EXCL CHIP_AND_DM4EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]
  ERR2 = DENSITY M4_NOT_EXC_L CHIP_NOT_M4_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_NOT_EXC_L)/AREA(CHIP_NOT_M4_EXC_L) ]
  K = SIZE (((ERR1 AND DM4EXCL) INSIDE ERR2) NOT M4_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2 
  DENSITY K M4_AND_DM4EXCL CHIP_AND_DM4EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M4.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M4_AND_DM4EXCL)/AREA(CHIP_AND_DM4EXCL) ]
}
#ENDIF
#ENDIF
// M4.DN.1 is checked by M4.DN.1__M4.DN.3:H
// M4.DN.3 is checked by M4.DN.1__M4.DN.3:H
// M4.DN.1d is checked by M4.DN.1__M4.DN.3:H
// M4.DN.3d is checked by M4.DN.1__M4.DN.3:H
M4.DN.1__M4.DN.3:H { @ M4 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 um x ^Mx_DN_W2 um step 50um 
  ERR_WIN = DENSITY M4_NOT_EXC_HIGH CHIP_NOT_M4_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M4_NOT_EXC_HIGH)/AREA(CHIP_NOT_M4_EXC_HIGH) ]
  K = SIZE (ERR_WIN NOT M4_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M4_NOT_EXC_HIGH CHIP_NOT_M4_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M4.DN.1H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*AREA(M4_NOT_EXC_HIGH)/AREA(CHIP_NOT_M4_EXC_HIGH) ]
}
#ENDIF

M4.DN.2 { @ M4 local density must be < 90% range over 20umx20um step 10um
  DENSITY M4x CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M4.DN.2.density 
    [ AREA(M4x)/AREA(CHIP) ]
}  

// M4.R.1 can not be checked


//VIA4 CHECKS
//===========
#IFDEF N80
  M5Wide_N80first = (SIZE M5 BY M5_S_2_1_W /2 UNDEROVER TRUNCATE M5_S_2_1_W /2) AND M5
#ENDIF

M5Wide_first = (SIZE M5 BY M5_S_2_W /2 UNDEROVER TRUNCATE M5_S_2_W /2) AND M5
M5Wide_1.5 = (SIZE M5Wide_first BY M5_S_3_W /2 UNDEROVER TRUNCATE M5_S_3_W /2) AND M5Wide_first
M5Wide_4.5 = (SIZE M5Wide_1.5 BY M5_S_4_W /2 UNDEROVER TRUNCATE M5_S_4_W /2) AND M5Wide_1.5

M4Wide_0.42_VIA4 = (SIZE M4Wide_first BY VIA4_R_2_W /2 UNDEROVER TRUNCATE VIA4_R_2_W /2) AND M4Wide_first 
M4Wide_0.7_VIA4 = (SIZE M4Wide_0.42_VIA4 BY VIA4_R_4_W /2 UNDEROVER TRUNCATE VIA4_R_4_W /2) AND M4Wide_0.42_VIA4
M4Wide_1.14_VIA4 = (SIZE M4Wide_0.7_VIA4 BY VIA4_R_3_W /2 UNDEROVER TRUNCATE VIA4_R_3_W /2) AND M4Wide_0.7_VIA4
M4Wide_2_VIA4 = (SIZE M4Wide_1.14_VIA4 BY VIA4_R_5_W /2 UNDEROVER TRUNCATE VIA4_R_5_W /2) AND M4Wide_1.14_VIA4
M4Wide_3_VIA4 = (SIZE M4Wide_2_VIA4 BY VIA4_R_6_W /2 UNDEROVER TRUNCATE VIA4_R_6_W /2) AND M4Wide_2_VIA4
M5Wide_0.42_VIA4 = (SIZE M5Wide_first BY VIA4_R_2_W /2 UNDEROVER TRUNCATE VIA4_R_2_W /2) AND M5Wide_first 
M5Wide_0.7_VIA4 = (SIZE M5Wide_0.42_VIA4 BY VIA4_R_4_W /2 UNDEROVER TRUNCATE VIA4_R_4_W /2) AND M5Wide_0.42_VIA4
M5Wide_1.14_VIA4 = (SIZE M5Wide_0.7_VIA4 BY VIA4_R_3_W /2 UNDEROVER TRUNCATE VIA4_R_3_W /2) AND M5Wide_0.7_VIA4 
M5Wide_2_VIA4 = (SIZE M5Wide_1.14_VIA4 BY VIA4_R_5_W /2 UNDEROVER TRUNCATE VIA4_R_5_W /2) AND M5Wide_1.14_VIA4
M5Wide_3_VIA4 = (SIZE M5Wide_2_VIA4 BY VIA4_R_6_W /2 UNDEROVER TRUNCATE VIA4_R_6_W /2) AND M5Wide_2_VIA4 

VIA4.W.1 { @ Width (square) (maximum = minimum) = ^VIA4_W_1 um
  A = NOT RECTANGLE VIA4 == VIA4_W_1 BY == VIA4_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA4.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA4_W_2 um
  INT SR_VIA4 < VIA4_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_VIA4 BY VIA4_W_2 /2 + GRID UNDEROVER TRUNCATE VIA4_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA4.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA4_W_2 um
  INT SR_VIA4 < VIA4_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_VIA4 BY VIA4_W_2 /2 + GRID UNDEROVER TRUNCATE VIA4_W_2 /2 + GRID
}
#ENDIF
VIA4.S.1 { @ Space >= ^VIA4_S_1 um 
  EXT VIA4 < VIA4_S_1 ABUT < 90 SINGULAR REGION
}
VIA4.S.2 { @ Space to 3-neighboring VIAx (< 0.19 um distance) >= ^VIA4_S_2 um
  X = WITH NEIGHBOR VIA4_EXD > 2 SPACE < VIA4_S_2_S
  EXT X VIA4 < VIA4_S_2 ABUT < 90 SINGULAR REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// VIA4.S.3.R is checked by RR:VIA4.S.3
    RR:VIA4.S.3 { @ Two adjacent VIAx space between different net if the common run length > 0 um, >= 0.17 um
      VIA4_NODAL = STAMP VIA4 BY VIA4i
      EXT VIA4_NODAL < VIA4_S_3R ABUT < 90 NOT CONNECTED OPPOSITE REGION
    }
  #ENDIF
#ENDIF

// VIA4.EN.0 is checked by either {VIA4.EN.1/VIA4.EN.2} or VIA4.EN.3

VIA4.EN.1 { @ Enclosure by Mx or M1 >= ^VIA4_EN_1 um 
  ENC VIA4 M4 < VIA4_EN_1 ABUT < 90 SINGULAR REGION
  VIA4 NOT M4
}

// VIA4.EN.2 is checked by VIA4.EN.2__VIA4.EN.3
// VIA4.EN.3 is checked by VIA4.EN.2__VIA4.EN.3
VIA4.EN.2__VIA4.EN.3 { @ Enclosure by M4 [at least two opposite sides] >= ^VIA4_EN_2 , or [all sides] >= ^VIA4_EN_3
  X = RECTANGLE ENCLOSURE VIA4 M4 ABUT < 90 SINGULAR GOOD VIA4_EN_1 VIA4_EN_2 OPPOSITE VIA4_EN_1 VIA4_EN_2 OPPOSITE
ENC X M4 < VIA4_EN_3 ABUT < 90 SINGULAR REGION
}

// VIA4.R.1 is checked by VIA4.W.1
// VIA4.R.2 is checked by VIA4.R.2__VIA4.R.3
// VIA4.R.3 is checked by VIA4.R.2__VIA4.R.3
// VIA4.R.2.S80 is checked by VIA4.R.2__VIA4.R.3
// VIA4.R.3.S80 is checked by VIA4.R.2__VIA4.R.3
VIA4.R.2__VIA4.R.3 { @ When M4 or M5 width > ^VIA4_R_2_W um, more than one VIA4 is required.
                    @ 2 vias spacing should be <= ^VIA4_R_2_S1 um or 4 vias spacing should be <= ^VIA4_R_2_S2 um
                    @ or 9 vias spacing should be <= ^VIA4_R_2_S3 um
                    @ When M4 or M5 width > ^VIA4_R_3_W um, more than three VIA4 is required.
                    @ 4 vias spacing should be <= ^VIA4_R_3_S1 um or 9 vias spacing should be <= ^VIA4_R_3_S2 um

M5OvpM4_W_ = (M4Wide_0.42_VIA4 AND M5) OR (M5Wide_0.42_VIA4 AND M4)
M5OvpM4_B  = (M4Wide_1.14_VIA4 AND M5) OR (M5Wide_1.14_VIA4 AND M4)
M5OvpM4_W  = M5OvpM4_W_ NOT M5OvpM4_B 
Checked_VIA4_W_ = VIA4_EXD NOT OUTSIDE M5OvpM4_W
Checked_VIA4_B  = VIA4_EXD NOT OUTSIDE M5OvpM4_B
Checked_VIA4_W  = Checked_VIA4_W_ NOT Checked_VIA4_B

M4_effect = M4i INTERACT M5OvpM4_W_
M5_effect = M5i INTERACT M5OvpM4_W_
effect_M5OvpM4_ = M4_effect AND M5_effect
effect_M5OvpM4 = effect_M5OvpM4_ INTERACT M5OvpM4_W_
effect_VIA = VIA4_EXD INTERACT effect_M5OvpM4
    
V4Merged_A = SIZE effect_VIA BY VIA4_R_2_S1/2 INSIDE OF effect_M5OvpM4 STEP 0.098
V4Merged_B = SIZE V4Merged_A BY (VIA4_R_2_S2 - VIA4_R_2_S1)/2 INSIDE OF effect_M5OvpM4 STEP 0.098
V4Merged_C = SIZE V4Merged_B BY (VIA4_R_3_S2 - VIA4_R_2_S2)/2 INSIDE OF effect_M5OvpM4 STEP 0.098
V4Merged_A2R = V4Merged_A INTERACT effect_VIA < 2
V4Merged_A2 = V4Merged_A OUTSIDE V4Merged_A2R
V4Merged_A4R = V4Merged_A2 INTERACT effect_VIA < 4
V4Merged_A4 = V4Merged_A2 OUTSIDE V4Merged_A4R
V4Merged_B4R = V4Merged_B INTERACT effect_VIA < 4
V4Merged_B4 = V4Merged_B OUTSIDE V4Merged_B4R
V4Merged_C9R = V4Merged_C INTERACT effect_VIA < 9
V4Merged_C9 = V4Merged_C OUTSIDE V4Merged_C9R

GMergeW = (V4Merged_A2 OR V4Merged_B4) OR V4Merged_C9
GMergeB = V4Merged_A4 OR V4Merged_C9

GVIA_W = Checked_VIA4_W INTERACT GMergeW
GVIA_B = Checked_VIA4_B INTERACT GMergeB
GOOD_AREA_W = M5OvpM4_W INTERACT GVIA_W
GOOD_AREA_B = M5OvpM4_B INTERACT GVIA_B
Checked_VIA4_W OUTSIDE GOOD_AREA_W
Checked_VIA4_B OUTSIDE GOOD_AREA_B
}
// VIA4.R.4 is checked by VIA4.R.4:M4
// VIA4.R.4.S80 is checked by VIA4.R.4:M4
VIA4.R.4:M4 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M4Wide_0.7_VIA4 BY VIA4_R_4_D + GRID) NOT M4Wide_0.7_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_0.7_VIA4) INTERACT VIA4
  Branch1Edge = M4Wide_0.7_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_4_D INSIDE OF Branch1HasVia STEP M4_S_1*0.5
  GoodBranch = (Branch AND M5) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA4.R.4 is checked by VIA4.R.4:M5
// VIA4.R.4.S80 is checked by VIA4.R.4:M5
VIA4.R.4:M5 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M5Wide_0.7_VIA4 BY VIA4_R_4_D + GRID) NOT M5Wide_0.7_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_0.7_VIA4) INTERACT VIA4
  Branch1Edge = M5Wide_0.7_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_4_D INSIDE OF Branch1HasVia STEP M5_S_1*0.5
  GoodBranch = (Branch AND M4) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA4.R.5 is checked by VIA4.R.5:M4
// VIA4.R.5.S80 is checked by VIA4.R.5:M4
VIA4.R.5:M4 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M4Wide_2_VIA4 BY VIA4_R_5_D + GRID) NOT M4Wide_2_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Wide_2_VIA4) INTERACT VIA4
  Branch1Edge = M4Wide_2_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_5_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA4.R.5 is checked by VIA4.R.5:M5
// VIA4.R.5.S80 is checked by VIA4.R.5:M5
VIA4.R.5:M5 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M5Wide_2_VIA4 BY VIA4_R_5_D + GRID) NOT M5Wide_2_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_2_VIA4) INTERACT VIA4
  Branch1Edge = M5Wide_2_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_5_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M4Big_3_VIA4 = ENCLOSE RECTANGLE M4Wide_3_VIA4 VIA4_R_6_W VIA4_R_6_L+GRID
// VIA4.R.6 is checked by VIA4.R.6:M4
// VIA4.R.6.S80 is checked by VIA4.R.6:M4
VIA4.R.6:M4 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M4Big_3_VIA4 BY VIA4_R_6_D + GRID) NOT M4Big_3_VIA4) AND M4
  Branch1HasVia = (Branch1 INTERACT M4Big_3_VIA4) INTERACT VIA4
  Branch1Edge = M4Big_3_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_6_D INSIDE OF Branch1HasVia STEP M4_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M4) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M5Big_3_VIA4 = ENCLOSE RECTANGLE M5Wide_3_VIA4 VIA4_R_6_W VIA4_R_6_L+GRID
// VIA4.R.6 is checked by VIA4.R.6:M5
// VIA4.R.6.S80 is checked by VIA4.R.6:M5
VIA4.R.6:M5 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M5Big_3_VIA4 BY VIA4_R_6_D + GRID) NOT M5Big_3_VIA4) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_3_VIA4) INTERACT VIA4
  Branch1Edge = M5Big_3_VIA4 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA4_R_6_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M4) INTERACT VIA4 > 1
  BranchSingleVia = (VIA4 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M4 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA4 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA4.R.7 is checked by VIA4.EN.1
// VIA4.R.9 can't be checked


VIA4.R.11 { @ Single VIAx is not allowed for mesh-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has mesh-shape interact with two metal holes : both two metal hole area <= ^VIA4_R_11_A um2 and two metal hole length(L2) <= ^VIA4_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this mesh-shape Mx+1 
@ 3. The length (L) of the center metal bar <= 1um and the width of metal bar is <= 0.42um. 



    
  W = M5i WITH WIDTH <= VIA4_R_11_W   
  H_HOLE = (HOLES M5i INNER <= VIA4_R_11_A) INTERACT W
  A0 = M5i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA4_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA4_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA4_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA4_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA4_R_11_L+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA4i
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA4_R_11_L2 OPPOSITE  
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA4i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M4i INTERACT CHECK_VIA)) INTERACT VIA4i == 1)
}


//M5 CHECKS
//=========
#IFDEF N80
  M5A = M5Wide_N80first NOT CB_NON_CUP
#ENDIF

M51 = M5Wide_first NOT CB_NON_CUP
M52 = M5Wide_1.5 NOT CB_NON_CUP
M53 = M5Wide_4.5 NOT CB_NON_CUP


VARIABLE M5_A_2pre ((M5_A_2 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))*((M5_A_2 + (M5_S_1 * M5_S_1 * 3.142))/(2 * M5_S_1))/3.141

M5HO = HOLES M5 INNER < M5_A_2pre

M5HOC = M5HO NOT M5

M5AS3 = AREA M5 > M5_S_3_L*M5_W_1  // filter small metal for M5.S.3
M5AS4 = AREA M5AS3 > M5_S_4_L*M5_W_1  // filter small metal for M5.S.4

M5.W.1 { @ Width >= ^M5_W_1 um 
  INT M5 < M5_W_1 ABUT < 90 SINGULAR REGION
}
M5.W.2 { @ Width of 45-degree bent Mx >= ^M5_W_2 um 
  INT M5_EDGE_45 < M5_W_2 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M5.W.2.R is checked by RR:M5.W.2
    RR:M5.W.2 { @ Width of 45-degree bent Mx >= ^M5_W_2R um 
      INT M5_EDGE_45 < M5_W_2R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF


M5.W.3 { @ Maximum width [Except WBDMY, if Mx is Mtop-1 layer] <= ^M5_W_3 um 
  SIZE M5 BY M5_W_3 /2 UNDEROVER TRUNCATE M5_W_3 /2
}
M5.S.1 { @ Space >= ^M5_S_1 um 
  EXT M5 < M5_S_1 ABUT < 90 SINGULAR REGION
}
// M5.S.2.S80 is checked by M5.S.2
M5.S.2 { @ Space [at least one metal line width > M5_S_2_W um and the parallel metal run length > M5_S_2_L um] >= ^M5_S_2 um
  X = EXT M51 M5 < M5_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_L+GRID
}
#IFDEF N80
  M5.S.2.1.S80 { @ Space [at least one metal line width > 0.21um(W1) and the parallel metal run length > 0.8um(L1)] >= 0.15um
  X = EXT M5A M5 < M5_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_2_1_L+GRID
  }
#ENDIF


// M5.S.3.S80 is checked by M5.S.3
M5.S.3 { @ Space [at least one metal line width > M5_S_3_W um and the parallel metal run length > M5_S_3_L um] >= ^M5_S_3 um
  X = EXT M52 M5AS3 < M5_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_3_L+GRID
}
// M5.S.4.S80 is checked by M5.S.4
M5.S.4 { @ Space [at least one metal line width > M5_S_4_W um and the parallel metal run length > M5_S_4_L um] >= ^M5_S_4 um
  X = EXT M53 M5AS4 < M5_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M5
  ENCLOSE RECTANGLE Y GRID M5_S_4_L+GRID
}
M5.S.5 { @ Space to 45-degree bent Mx >= ^M5_S_5 um 
  X = EXPAND EDGE M5_EDGE_45 OUTSIDE BY M5_S_5
  X AND M5
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M5.S.5.R is checked by RR:M5.S.5
    RR:M5.S.5 { @ Mx space to 45-degree bent Mx >= ^M5_S_5R um 
      X = EXPAND EDGE M5_EDGE_45 OUTSIDE BY M5_S_5R
      X AND M5
    }
  #ENDIF
#ENDIF

// M5.EN.0 is checked by either {M5.EN.1/M5.EN.2} or M5.EN.3
M5.EN.1 { @ Enclosure of VIAx-1 >= ^M5_EN_1 um 
  ENC VIA4 M5 < M5_EN_1 ABUT < 90 SINGULAR REGION
  VIA4 NOT M5
}
// M5.EN.2 is checked by M5.EN.2__M5.EN.3
// M5.EN.3 is checked by M5.EN.2__M5.EN.3
M5.EN.2__M5.EN.3 { @ Enclosure of VIAx-1 [at least 2 opposite sides] >= ^M5_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA4 M5 ABUT < 90 SINGULAR GOOD M5_EN_1 M5_EN_2 OPPOSITE M5_EN_1 M5_EN_2 OPPOSITE
  ENC X M5 < M5_EN_3 ABUT < 90 SINGULAR REGION
}

M5.A.1 { @ Area >= ^M5_A_1 um2
  AREA M5 < M5_A_1
}
M5.A.2 { @ Enclosed area >= ^M5_A_2 um
  AREA M5HOC < M5_A_2
}


CHIP_NOT_M5_EXC_HIGH = CHIP NOT M5_EXC_H  // for high density check
M5_NOT_EXC_HIGH = M5x NOT M5_EXC_H       // for high density check 
CHIP_NOT_M5_EXC_L = CHIP NOT M5_EXC_L1    // for low density check
M5_NOT_EXC_L = M5x NOT M5_EXC_L1         // for low density check

// For density check in DMxEXCL
CHIP_AND_DM5EXCL_HIGH = CHIP_NOT_M5_EXC_HIGH AND DM5EXCL  // for high density check
M5_AND_DM5EXCL_HIGH = M5_NOT_EXC_HIGH AND DM5EXCL        // for high density check
CHIP_AND_DM5EXCL = CHIP_NOT_M5_EXC_L AND DM5EXCL 	     // for low density check
M5_AND_DM5EXCL = M5_NOT_EXC_L AND DM5EXCL                // for low density check

#IFDEF DENSITY_IN_BLOCKAGE
// M5.DN.3 is checked by M5.DN.3:L
// M5.DN.3a is checked by M5.DN.3:L
M5.DN.3:L { @ M5 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um (with DM5EXCL region)
  ERR1 = DENSITY M5_AND_DM5EXCL CHIP_AND_DM5EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]
  ERR2 = DENSITY M5_NOT_EXC_L CHIP_NOT_M5_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_NOT_EXC_L)/AREA(CHIP_NOT_M5_EXC_L) ]	
  K = SIZE (((ERR1 AND DM5EXCL) INSIDE ERR2) NOT M5_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M5_AND_DM5EXCL CHIP_AND_DM5EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M5.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]

}
// M5.DN.3 is checked by M5.DN.3:H 
// M5.DN.3d is checked by M5.DN.3:H 
M5.DN.3:H { @ M5 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 umx ^Mx_DN_W2 um step 50um (with DM5EXCL region)
  ERR1 = DENSITY M5_AND_DM5EXCL_HIGH CHIP_AND_DM5EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_AND_DM5EXCL_HIGH)/AREA(CHIP_AND_DM5EXCL_HIGH) ]
  ERR2 = DENSITY M5_NOT_EXC_HIGH CHIP_NOT_M5_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_NOT_EXC_HIGH)/AREA(CHIP_NOT_M5_EXC_HIGH) ]
  K = SIZE (((ERR1 AND DM5EXCL) INSIDE ERR2) NOT M5_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M5_AND_DM5EXCL_HIGH CHIP_AND_DM5EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M5.DN.3H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*(AREA(M5_AND_DM5EXCL_HIGH)/AREA(CHIP_AND_DM5EXCL_HIGH)) ]
}
#ELSE
#IFDEF FULL_CHIP
// M5.DN.1 is checked by M5.DN.1__M5.DN.3:L
// M5.DN.3 is checked by M5.DN.1__M5.DN.3:L
// M5.DN.1a is checked by M5.DN.1__M5.DN.3:L
// M5.DN.3a is checked by M5.DN.1__M5.DN.3:L
M5.DN.1__M5.DN.3:L { @ M5 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M5_NOT_EXC_L CHIP_NOT_M5_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
[ AREA(M5_NOT_EXC_L)/AREA(CHIP_NOT_M5_EXC_L) ]
  K = SIZE (ERR_WIN NOT M5_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M5_NOT_EXC_L CHIP_NOT_M5_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M5.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M5_NOT_EXC_L)/AREA(CHIP_NOT_M5_EXC_L) ]
}
#ELSE  // IP/macro/block level
#IFDEF DENSITY_FOR_NONFULLCHIP
// M5.DN.1 is checked by M5.DN.1__M5.DN.3:L
// M5.DN.3 is checked by M5.DN.1__M5.DN.3:L
// M5.DN.1a is checked by M5.DN.1__M5.DN.3:L
// M5.DN.3a is checked by M5.DN.1__M5.DN.3:L
M5.DN.1__M5.DN.3:L { @ M5 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M5_NOT_EXC_L CHIP_NOT_M5_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_NOT_EXC_L)/AREA(CHIP_NOT_M5_EXC_L) ]
  K = SIZE (ERR_WIN NOT M5_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M5_NOT_EXC_L CHIP_NOT_M5_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M5.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M5_NOT_EXC_L)/AREA(CHIP_NOT_M5_EXC_L) ]
}
#ELSE
// M5.DN.3 is checked by M5.DN.3:L
// M5.DN.3a is checked by M5.DN.3:L
M5.DN.3:L { @ M5 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um (with DM5EXCL region)
  ERR1 = DENSITY M5_AND_DM5EXCL CHIP_AND_DM5EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]
  ERR2 = DENSITY M5_NOT_EXC_L CHIP_NOT_M5_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_NOT_EXC_L)/AREA(CHIP_NOT_M5_EXC_L) ]
  K = SIZE (((ERR1 AND DM5EXCL) INSIDE ERR2) NOT M5_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2 
  DENSITY K M5_AND_DM5EXCL CHIP_AND_DM5EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M5.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M5_AND_DM5EXCL)/AREA(CHIP_AND_DM5EXCL) ]
}
#ENDIF
#ENDIF
// M5.DN.1 is checked by M5.DN.1__M5.DN.3:H
// M5.DN.3 is checked by M5.DN.1__M5.DN.3:H
// M5.DN.1d is checked by M5.DN.1__M5.DN.3:H
// M5.DN.3d is checked by M5.DN.1__M5.DN.3:H
M5.DN.1__M5.DN.3:H { @ M5 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 um x ^Mx_DN_W2 um step 50um 
  ERR_WIN = DENSITY M5_NOT_EXC_HIGH CHIP_NOT_M5_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M5_NOT_EXC_HIGH)/AREA(CHIP_NOT_M5_EXC_HIGH) ]
  K = SIZE (ERR_WIN NOT M5_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M5_NOT_EXC_HIGH CHIP_NOT_M5_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M5.DN.1H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*AREA(M5_NOT_EXC_HIGH)/AREA(CHIP_NOT_M5_EXC_HIGH) ]
}
#ENDIF

M5.DN.2 { @ M5 local density must be < 90% range over 20umx20um step 10um
  DENSITY M5x CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M5.DN.2.density 
    [ AREA(M5x)/AREA(CHIP) ]
}  

// M5.R.1 can not be checked


//VIA5 CHECKS
//===========
#IFDEF N80
  M6Wide_N80first = (SIZE M6 BY M6_S_2_1_W /2 UNDEROVER TRUNCATE M6_S_2_1_W /2) AND M6
#ENDIF

M6Wide_first = (SIZE M6 BY M6_S_2_W /2 UNDEROVER TRUNCATE M6_S_2_W /2) AND M6
M6Wide_1.5 = (SIZE M6Wide_first BY M6_S_3_W /2 UNDEROVER TRUNCATE M6_S_3_W /2) AND M6Wide_first
M6Wide_4.5 = (SIZE M6Wide_1.5 BY M6_S_4_W /2 UNDEROVER TRUNCATE M6_S_4_W /2) AND M6Wide_1.5

M5Wide_0.42_VIA5 = (SIZE M5Wide_first BY VIA5_R_2_W /2 UNDEROVER TRUNCATE VIA5_R_2_W /2) AND M5Wide_first 
M5Wide_0.7_VIA5 = (SIZE M5Wide_0.42_VIA5 BY VIA5_R_4_W /2 UNDEROVER TRUNCATE VIA5_R_4_W /2) AND M5Wide_0.42_VIA5
M5Wide_1.14_VIA5 = (SIZE M5Wide_0.7_VIA5 BY VIA5_R_3_W /2 UNDEROVER TRUNCATE VIA5_R_3_W /2) AND M5Wide_0.7_VIA5
M5Wide_2_VIA5 = (SIZE M5Wide_1.14_VIA5 BY VIA5_R_5_W /2 UNDEROVER TRUNCATE VIA5_R_5_W /2) AND M5Wide_1.14_VIA5
M5Wide_3_VIA5 = (SIZE M5Wide_2_VIA5 BY VIA5_R_6_W /2 UNDEROVER TRUNCATE VIA5_R_6_W /2) AND M5Wide_2_VIA5
M6Wide_0.42_VIA5 = (SIZE M6Wide_first BY VIA5_R_2_W /2 UNDEROVER TRUNCATE VIA5_R_2_W /2) AND M6Wide_first 
M6Wide_0.7_VIA5 = (SIZE M6Wide_0.42_VIA5 BY VIA5_R_4_W /2 UNDEROVER TRUNCATE VIA5_R_4_W /2) AND M6Wide_0.42_VIA5
M6Wide_1.14_VIA5 = (SIZE M6Wide_0.7_VIA5 BY VIA5_R_3_W /2 UNDEROVER TRUNCATE VIA5_R_3_W /2) AND M6Wide_0.7_VIA5 
M6Wide_2_VIA5 = (SIZE M6Wide_1.14_VIA5 BY VIA5_R_5_W /2 UNDEROVER TRUNCATE VIA5_R_5_W /2) AND M6Wide_1.14_VIA5
M6Wide_3_VIA5 = (SIZE M6Wide_2_VIA5 BY VIA5_R_6_W /2 UNDEROVER TRUNCATE VIA5_R_6_W /2) AND M6Wide_2_VIA5 

VIA5.W.1 { @ Width (square) (maximum = minimum) = ^VIA5_W_1 um
  A = NOT RECTANGLE VIA5 == VIA5_W_1 BY == VIA5_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA5.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA5_W_2 um
  INT SR_VIA5 < VIA5_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_VIA5 BY VIA5_W_2 /2 + GRID UNDEROVER TRUNCATE VIA5_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA5.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA5_W_2 um
  INT SR_VIA5 < VIA5_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_VIA5 BY VIA5_W_2 /2 + GRID UNDEROVER TRUNCATE VIA5_W_2 /2 + GRID
}
#ENDIF
VIA5.S.1 { @ Space >= ^VIA5_S_1 um 
  EXT VIA5 < VIA5_S_1 ABUT < 90 SINGULAR REGION
}
VIA5.S.2 { @ Space to 3-neighboring VIAx (< 0.19 um distance) >= ^VIA5_S_2 um
  X = WITH NEIGHBOR VIA5_EXD > 2 SPACE < VIA5_S_2_S
  EXT X VIA5 < VIA5_S_2 ABUT < 90 SINGULAR REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// VIA5.S.3.R is checked by RR:VIA5.S.3
    RR:VIA5.S.3 { @ Two adjacent VIAx space between different net if the common run length > 0 um, >= 0.17 um
      VIA5_NODAL = STAMP VIA5 BY VIA5i
      EXT VIA5_NODAL < VIA5_S_3R ABUT < 90 NOT CONNECTED OPPOSITE REGION
    }
  #ENDIF
#ENDIF

// VIA5.EN.0 is checked by either {VIA5.EN.1/VIA5.EN.2} or VIA5.EN.3

VIA5.EN.1 { @ Enclosure by Mx or M1 >= ^VIA5_EN_1 um 
  ENC VIA5 M5 < VIA5_EN_1 ABUT < 90 SINGULAR REGION
  VIA5 NOT M5
}

// VIA5.EN.2 is checked by VIA5.EN.2__VIA5.EN.3
// VIA5.EN.3 is checked by VIA5.EN.2__VIA5.EN.3
VIA5.EN.2__VIA5.EN.3 { @ Enclosure by M5 [at least two opposite sides] >= ^VIA5_EN_2 , or [all sides] >= ^VIA5_EN_3
  X = RECTANGLE ENCLOSURE VIA5 M5 ABUT < 90 SINGULAR GOOD VIA5_EN_1 VIA5_EN_2 OPPOSITE VIA5_EN_1 VIA5_EN_2 OPPOSITE
ENC X M5 < VIA5_EN_3 ABUT < 90 SINGULAR REGION
}

// VIA5.R.1 is checked by VIA5.W.1
// VIA5.R.2 is checked by VIA5.R.2__VIA5.R.3
// VIA5.R.3 is checked by VIA5.R.2__VIA5.R.3
// VIA5.R.2.S80 is checked by VIA5.R.2__VIA5.R.3
// VIA5.R.3.S80 is checked by VIA5.R.2__VIA5.R.3
VIA5.R.2__VIA5.R.3 { @ When M5 or M6 width > ^VIA5_R_2_W um, more than one VIA5 is required.
                    @ 2 vias spacing should be <= ^VIA5_R_2_S1 um or 4 vias spacing should be <= ^VIA5_R_2_S2 um
                    @ or 9 vias spacing should be <= ^VIA5_R_2_S3 um
                    @ When M5 or M6 width > ^VIA5_R_3_W um, more than three VIA5 is required.
                    @ 4 vias spacing should be <= ^VIA5_R_3_S1 um or 9 vias spacing should be <= ^VIA5_R_3_S2 um

M6OvpM5_W_ = (M5Wide_0.42_VIA5 AND M6) OR (M6Wide_0.42_VIA5 AND M5)
M6OvpM5_B  = (M5Wide_1.14_VIA5 AND M6) OR (M6Wide_1.14_VIA5 AND M5)
M6OvpM5_W  = M6OvpM5_W_ NOT M6OvpM5_B 
Checked_VIA5_W_ = VIA5_EXD NOT OUTSIDE M6OvpM5_W
Checked_VIA5_B  = VIA5_EXD NOT OUTSIDE M6OvpM5_B
Checked_VIA5_W  = Checked_VIA5_W_ NOT Checked_VIA5_B

M5_effect = M5i INTERACT M6OvpM5_W_
M6_effect = M6i INTERACT M6OvpM5_W_
effect_M6OvpM5_ = M5_effect AND M6_effect
effect_M6OvpM5 = effect_M6OvpM5_ INTERACT M6OvpM5_W_
effect_VIA = VIA5_EXD INTERACT effect_M6OvpM5
    
V5Merged_A = SIZE effect_VIA BY VIA5_R_2_S1/2 INSIDE OF effect_M6OvpM5 STEP 0.098
V5Merged_B = SIZE V5Merged_A BY (VIA5_R_2_S2 - VIA5_R_2_S1)/2 INSIDE OF effect_M6OvpM5 STEP 0.098
V5Merged_C = SIZE V5Merged_B BY (VIA5_R_3_S2 - VIA5_R_2_S2)/2 INSIDE OF effect_M6OvpM5 STEP 0.098
V5Merged_A2R = V5Merged_A INTERACT effect_VIA < 2
V5Merged_A2 = V5Merged_A OUTSIDE V5Merged_A2R
V5Merged_A4R = V5Merged_A2 INTERACT effect_VIA < 4
V5Merged_A4 = V5Merged_A2 OUTSIDE V5Merged_A4R
V5Merged_B4R = V5Merged_B INTERACT effect_VIA < 4
V5Merged_B4 = V5Merged_B OUTSIDE V5Merged_B4R
V5Merged_C9R = V5Merged_C INTERACT effect_VIA < 9
V5Merged_C9 = V5Merged_C OUTSIDE V5Merged_C9R

GMergeW = (V5Merged_A2 OR V5Merged_B4) OR V5Merged_C9
GMergeB = V5Merged_A4 OR V5Merged_C9

GVIA_W = Checked_VIA5_W INTERACT GMergeW
GVIA_B = Checked_VIA5_B INTERACT GMergeB
GOOD_AREA_W = M6OvpM5_W INTERACT GVIA_W
GOOD_AREA_B = M6OvpM5_B INTERACT GVIA_B
Checked_VIA5_W OUTSIDE GOOD_AREA_W
Checked_VIA5_B OUTSIDE GOOD_AREA_B
}
// VIA5.R.4 is checked by VIA5.R.4:M5
// VIA5.R.4.S80 is checked by VIA5.R.4:M5
VIA5.R.4:M5 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M5Wide_0.7_VIA5 BY VIA5_R_4_D + GRID) NOT M5Wide_0.7_VIA5) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_0.7_VIA5) INTERACT VIA5
  Branch1Edge = M5Wide_0.7_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_4_D INSIDE OF Branch1HasVia STEP M5_S_1*0.5
  GoodBranch = (Branch AND M6) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA5.R.4 is checked by VIA5.R.4:M6
// VIA5.R.4.S80 is checked by VIA5.R.4:M6
VIA5.R.4:M6 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M6Wide_0.7_VIA5 BY VIA5_R_4_D + GRID) NOT M6Wide_0.7_VIA5) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_0.7_VIA5) INTERACT VIA5
  Branch1Edge = M6Wide_0.7_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_4_D INSIDE OF Branch1HasVia STEP M6_S_1*0.5
  GoodBranch = (Branch AND M5) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA5.R.5 is checked by VIA5.R.5:M5
// VIA5.R.5.S80 is checked by VIA5.R.5:M5
VIA5.R.5:M5 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M5Wide_2_VIA5 BY VIA5_R_5_D + GRID) NOT M5Wide_2_VIA5) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Wide_2_VIA5) INTERACT VIA5
  Branch1Edge = M5Wide_2_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_5_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA5.R.5 is checked by VIA5.R.5:M6
// VIA5.R.5.S80 is checked by VIA5.R.5:M6
VIA5.R.5:M6 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M6Wide_2_VIA5 BY VIA5_R_5_D + GRID) NOT M6Wide_2_VIA5) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_2_VIA5) INTERACT VIA5
  Branch1Edge = M6Wide_2_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_5_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M5Big_3_VIA5 = ENCLOSE RECTANGLE M5Wide_3_VIA5 VIA5_R_6_W VIA5_R_6_L+GRID
// VIA5.R.6 is checked by VIA5.R.6:M5
// VIA5.R.6.S80 is checked by VIA5.R.6:M5
VIA5.R.6:M5 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M5Big_3_VIA5 BY VIA5_R_6_D + GRID) NOT M5Big_3_VIA5) AND M5
  Branch1HasVia = (Branch1 INTERACT M5Big_3_VIA5) INTERACT VIA5
  Branch1Edge = M5Big_3_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_6_D INSIDE OF Branch1HasVia STEP M5_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M5) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M6Big_3_VIA5 = ENCLOSE RECTANGLE M6Wide_3_VIA5 VIA5_R_6_W VIA5_R_6_L+GRID
// VIA5.R.6 is checked by VIA5.R.6:M6
// VIA5.R.6.S80 is checked by VIA5.R.6:M6
VIA5.R.6:M6 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M6Big_3_VIA5 BY VIA5_R_6_D + GRID) NOT M6Big_3_VIA5) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Big_3_VIA5) INTERACT VIA5
  Branch1Edge = M6Big_3_VIA5 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA5_R_6_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M5) INTERACT VIA5 > 1
  BranchSingleVia = (VIA5 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M5 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA5 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA5.R.7 is checked by VIA5.EN.1
// VIA5.R.9 can't be checked


VIA5.R.11 { @ Single VIAx is not allowed for mesh-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has mesh-shape interact with two metal holes : both two metal hole area <= ^VIA5_R_11_A um2 and two metal hole length(L2) <= ^VIA5_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this mesh-shape Mx+1 
@ 3. The length (L) of the center metal bar <= 1um and the width of metal bar is <= 0.42um. 



    
  W = M6i WITH WIDTH <= VIA5_R_11_W   
  H_HOLE = (HOLES M6i INNER <= VIA5_R_11_A) INTERACT W
  A0 = M6i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA5_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA5_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA5_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA5_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA5_R_11_L+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA5i
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA5_R_11_L2 OPPOSITE  
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA5i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M5i INTERACT CHECK_VIA)) INTERACT VIA5i == 1)
}


//M6 CHECKS
//=========
#IFDEF N80
  M6A = M6Wide_N80first NOT CB_NON_CUP
#ENDIF

M61 = M6Wide_first NOT CB_NON_CUP
M62 = M6Wide_1.5 NOT CB_NON_CUP
M63 = M6Wide_4.5 NOT CB_NON_CUP


VARIABLE M6_A_2pre ((M6_A_2 + (M6_S_1 * M6_S_1 * 3.142))/(2 * M6_S_1))*((M6_A_2 + (M6_S_1 * M6_S_1 * 3.142))/(2 * M6_S_1))/3.141

M6HO = HOLES M6 INNER < M6_A_2pre

M6HOC = M6HO NOT M6

M6AS3 = AREA M6 > M6_S_3_L*M6_W_1  // filter small metal for M6.S.3
M6AS4 = AREA M6AS3 > M6_S_4_L*M6_W_1  // filter small metal for M6.S.4

M6.W.1 { @ Width >= ^M6_W_1 um 
  INT M6 < M6_W_1 ABUT < 90 SINGULAR REGION
}
M6.W.2 { @ Width of 45-degree bent Mx >= ^M6_W_2 um 
  INT M6_EDGE_45 < M6_W_2 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M6.W.2.R is checked by RR:M6.W.2
    RR:M6.W.2 { @ Width of 45-degree bent Mx >= ^M6_W_2R um 
      INT M6_EDGE_45 < M6_W_2R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF


M6.W.3 { @ Maximum width [Except WBDMY, if Mx is Mtop-1 layer] <= ^M6_W_3 um 
  SIZE M6 BY M6_W_3 /2 UNDEROVER TRUNCATE M6_W_3 /2
}
M6.S.1 { @ Space >= ^M6_S_1 um 
  EXT M6 < M6_S_1 ABUT < 90 SINGULAR REGION
}
// M6.S.2.S80 is checked by M6.S.2
M6.S.2 { @ Space [at least one metal line width > M6_S_2_W um and the parallel metal run length > M6_S_2_L um] >= ^M6_S_2 um
  X = EXT M61 M6 < M6_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_L+GRID
}
#IFDEF N80
  M6.S.2.1.S80 { @ Space [at least one metal line width > 0.21um(W1) and the parallel metal run length > 0.8um(L1)] >= 0.15um
  X = EXT M6A M6 < M6_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_2_1_L+GRID
  }
#ENDIF


// M6.S.3.S80 is checked by M6.S.3
M6.S.3 { @ Space [at least one metal line width > M6_S_3_W um and the parallel metal run length > M6_S_3_L um] >= ^M6_S_3 um
  X = EXT M62 M6AS3 < M6_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_3_L+GRID
}
// M6.S.4.S80 is checked by M6.S.4
M6.S.4 { @ Space [at least one metal line width > M6_S_4_W um and the parallel metal run length > M6_S_4_L um] >= ^M6_S_4 um
  X = EXT M63 M6AS4 < M6_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M6
  ENCLOSE RECTANGLE Y GRID M6_S_4_L+GRID
}
M6.S.5 { @ Space to 45-degree bent Mx >= ^M6_S_5 um 
  X = EXPAND EDGE M6_EDGE_45 OUTSIDE BY M6_S_5
  X AND M6
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M6.S.5.R is checked by RR:M6.S.5
    RR:M6.S.5 { @ Mx space to 45-degree bent Mx >= ^M6_S_5R um 
      X = EXPAND EDGE M6_EDGE_45 OUTSIDE BY M6_S_5R
      X AND M6
    }
  #ENDIF
#ENDIF

// M6.EN.0 is checked by either {M6.EN.1/M6.EN.2} or M6.EN.3
M6.EN.1 { @ Enclosure of VIAx-1 >= ^M6_EN_1 um 
  ENC VIA5 M6 < M6_EN_1 ABUT < 90 SINGULAR REGION
  VIA5 NOT M6
}
// M6.EN.2 is checked by M6.EN.2__M6.EN.3
// M6.EN.3 is checked by M6.EN.2__M6.EN.3
M6.EN.2__M6.EN.3 { @ Enclosure of VIAx-1 [at least 2 opposite sides] >= ^M6_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA5 M6 ABUT < 90 SINGULAR GOOD M6_EN_1 M6_EN_2 OPPOSITE M6_EN_1 M6_EN_2 OPPOSITE
  ENC X M6 < M6_EN_3 ABUT < 90 SINGULAR REGION
}

M6.A.1 { @ Area >= ^M6_A_1 um2
  AREA M6 < M6_A_1
}
M6.A.2 { @ Enclosed area >= ^M6_A_2 um
  AREA M6HOC < M6_A_2
}


CHIP_NOT_M6_EXC_HIGH = CHIP NOT M6_EXC_H  // for high density check
M6_NOT_EXC_HIGH = M6x NOT M6_EXC_H       // for high density check 
CHIP_NOT_M6_EXC_L = CHIP NOT M6_EXC_L1    // for low density check
M6_NOT_EXC_L = M6x NOT M6_EXC_L1         // for low density check

// For density check in DMxEXCL
CHIP_AND_DM6EXCL_HIGH = CHIP_NOT_M6_EXC_HIGH AND DM6EXCL  // for high density check
M6_AND_DM6EXCL_HIGH = M6_NOT_EXC_HIGH AND DM6EXCL        // for high density check
CHIP_AND_DM6EXCL = CHIP_NOT_M6_EXC_L AND DM6EXCL 	     // for low density check
M6_AND_DM6EXCL = M6_NOT_EXC_L AND DM6EXCL                // for low density check

#IFDEF DENSITY_IN_BLOCKAGE
// M6.DN.3 is checked by M6.DN.3:L
// M6.DN.3a is checked by M6.DN.3:L
M6.DN.3:L { @ M6 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um (with DM6EXCL region)
  ERR1 = DENSITY M6_AND_DM6EXCL CHIP_AND_DM6EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]
  ERR2 = DENSITY M6_NOT_EXC_L CHIP_NOT_M6_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_NOT_EXC_L)/AREA(CHIP_NOT_M6_EXC_L) ]	
  K = SIZE (((ERR1 AND DM6EXCL) INSIDE ERR2) NOT M6_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M6_AND_DM6EXCL CHIP_AND_DM6EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M6.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]

}
// M6.DN.3 is checked by M6.DN.3:H 
// M6.DN.3d is checked by M6.DN.3:H 
M6.DN.3:H { @ M6 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 umx ^Mx_DN_W2 um step 50um (with DM6EXCL region)
  ERR1 = DENSITY M6_AND_DM6EXCL_HIGH CHIP_AND_DM6EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_AND_DM6EXCL_HIGH)/AREA(CHIP_AND_DM6EXCL_HIGH) ]
  ERR2 = DENSITY M6_NOT_EXC_HIGH CHIP_NOT_M6_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_NOT_EXC_HIGH)/AREA(CHIP_NOT_M6_EXC_HIGH) ]
  K = SIZE (((ERR1 AND DM6EXCL) INSIDE ERR2) NOT M6_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M6_AND_DM6EXCL_HIGH CHIP_AND_DM6EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M6.DN.3H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*(AREA(M6_AND_DM6EXCL_HIGH)/AREA(CHIP_AND_DM6EXCL_HIGH)) ]
}
#ELSE
#IFDEF FULL_CHIP
// M6.DN.1 is checked by M6.DN.1__M6.DN.3:L
// M6.DN.3 is checked by M6.DN.1__M6.DN.3:L
// M6.DN.1a is checked by M6.DN.1__M6.DN.3:L
// M6.DN.3a is checked by M6.DN.1__M6.DN.3:L
M6.DN.1__M6.DN.3:L { @ M6 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M6_NOT_EXC_L CHIP_NOT_M6_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
[ AREA(M6_NOT_EXC_L)/AREA(CHIP_NOT_M6_EXC_L) ]
  K = SIZE (ERR_WIN NOT M6_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M6_NOT_EXC_L CHIP_NOT_M6_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M6.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M6_NOT_EXC_L)/AREA(CHIP_NOT_M6_EXC_L) ]
}
#ELSE  // IP/macro/block level
#IFDEF DENSITY_FOR_NONFULLCHIP
// M6.DN.1 is checked by M6.DN.1__M6.DN.3:L
// M6.DN.3 is checked by M6.DN.1__M6.DN.3:L
// M6.DN.1a is checked by M6.DN.1__M6.DN.3:L
// M6.DN.3a is checked by M6.DN.1__M6.DN.3:L
M6.DN.1__M6.DN.3:L { @ M6 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M6_NOT_EXC_L CHIP_NOT_M6_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_NOT_EXC_L)/AREA(CHIP_NOT_M6_EXC_L) ]
  K = SIZE (ERR_WIN NOT M6_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M6_NOT_EXC_L CHIP_NOT_M6_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M6.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M6_NOT_EXC_L)/AREA(CHIP_NOT_M6_EXC_L) ]
}
#ELSE
// M6.DN.3 is checked by M6.DN.3:L
// M6.DN.3a is checked by M6.DN.3:L
M6.DN.3:L { @ M6 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um (with DM6EXCL region)
  ERR1 = DENSITY M6_AND_DM6EXCL CHIP_AND_DM6EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]
  ERR2 = DENSITY M6_NOT_EXC_L CHIP_NOT_M6_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_NOT_EXC_L)/AREA(CHIP_NOT_M6_EXC_L) ]
  K = SIZE (((ERR1 AND DM6EXCL) INSIDE ERR2) NOT M6_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2 
  DENSITY K M6_AND_DM6EXCL CHIP_AND_DM6EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M6.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M6_AND_DM6EXCL)/AREA(CHIP_AND_DM6EXCL) ]
}
#ENDIF
#ENDIF
// M6.DN.1 is checked by M6.DN.1__M6.DN.3:H
// M6.DN.3 is checked by M6.DN.1__M6.DN.3:H
// M6.DN.1d is checked by M6.DN.1__M6.DN.3:H
// M6.DN.3d is checked by M6.DN.1__M6.DN.3:H
M6.DN.1__M6.DN.3:H { @ M6 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 um x ^Mx_DN_W2 um step 50um 
  ERR_WIN = DENSITY M6_NOT_EXC_HIGH CHIP_NOT_M6_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M6_NOT_EXC_HIGH)/AREA(CHIP_NOT_M6_EXC_HIGH) ]
  K = SIZE (ERR_WIN NOT M6_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M6_NOT_EXC_HIGH CHIP_NOT_M6_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M6.DN.1H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*AREA(M6_NOT_EXC_HIGH)/AREA(CHIP_NOT_M6_EXC_HIGH) ]
}
#ENDIF

M6.DN.2 { @ M6 local density must be < 90% range over 20umx20um step 10um
  DENSITY M6x CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M6.DN.2.density 
    [ AREA(M6x)/AREA(CHIP) ]
}  

// M6.R.1 can not be checked


//VIA6 CHECKS
//===========
#IFDEF N80
  M7Wide_N80first = (SIZE M7 BY M7_S_2_1_W /2 UNDEROVER TRUNCATE M7_S_2_1_W /2) AND M7
#ENDIF

M7Wide_first = (SIZE M7 BY M7_S_2_W /2 UNDEROVER TRUNCATE M7_S_2_W /2) AND M7
M7Wide_1.5 = (SIZE M7Wide_first BY M7_S_3_W /2 UNDEROVER TRUNCATE M7_S_3_W /2) AND M7Wide_first
M7Wide_4.5 = (SIZE M7Wide_1.5 BY M7_S_4_W /2 UNDEROVER TRUNCATE M7_S_4_W /2) AND M7Wide_1.5

M6Wide_0.42_VIA6 = (SIZE M6Wide_first BY VIA6_R_2_W /2 UNDEROVER TRUNCATE VIA6_R_2_W /2) AND M6Wide_first 
M6Wide_0.7_VIA6 = (SIZE M6Wide_0.42_VIA6 BY VIA6_R_4_W /2 UNDEROVER TRUNCATE VIA6_R_4_W /2) AND M6Wide_0.42_VIA6
M6Wide_1.14_VIA6 = (SIZE M6Wide_0.7_VIA6 BY VIA6_R_3_W /2 UNDEROVER TRUNCATE VIA6_R_3_W /2) AND M6Wide_0.7_VIA6
M6Wide_2_VIA6 = (SIZE M6Wide_1.14_VIA6 BY VIA6_R_5_W /2 UNDEROVER TRUNCATE VIA6_R_5_W /2) AND M6Wide_1.14_VIA6
M6Wide_3_VIA6 = (SIZE M6Wide_2_VIA6 BY VIA6_R_6_W /2 UNDEROVER TRUNCATE VIA6_R_6_W /2) AND M6Wide_2_VIA6
M7Wide_0.42_VIA6 = (SIZE M7Wide_first BY VIA6_R_2_W /2 UNDEROVER TRUNCATE VIA6_R_2_W /2) AND M7Wide_first 
M7Wide_0.7_VIA6 = (SIZE M7Wide_0.42_VIA6 BY VIA6_R_4_W /2 UNDEROVER TRUNCATE VIA6_R_4_W /2) AND M7Wide_0.42_VIA6
M7Wide_1.14_VIA6 = (SIZE M7Wide_0.7_VIA6 BY VIA6_R_3_W /2 UNDEROVER TRUNCATE VIA6_R_3_W /2) AND M7Wide_0.7_VIA6 
M7Wide_2_VIA6 = (SIZE M7Wide_1.14_VIA6 BY VIA6_R_5_W /2 UNDEROVER TRUNCATE VIA6_R_5_W /2) AND M7Wide_1.14_VIA6
M7Wide_3_VIA6 = (SIZE M7Wide_2_VIA6 BY VIA6_R_6_W /2 UNDEROVER TRUNCATE VIA6_R_6_W /2) AND M7Wide_2_VIA6 

VIA6.W.1 { @ Width (square) (maximum = minimum) = ^VIA6_W_1 um
  A = NOT RECTANGLE VIA6 == VIA6_W_1 BY == VIA6_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA6.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA6_W_2 um
  INT SR_VIA6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  A = SIZE SR_VIA6 BY VIA6_W_2 /2 + GRID UNDEROVER TRUNCATE VIA6_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 1 0.005
}
#ELSE
VIA6.W.2 { @ Width of VIAx bar. VIAx bar is only allowed in seal-ring and fuse protection ring. SEALRING layer (CAD layer: 162 for both seal-ring and fuse protection ring) is a must to cover VIAx bar if VIAx bar is used = ^VIA6_W_2 um
  INT SR_VIA6 < VIA6_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION
  SIZE SR_VIA6 BY VIA6_W_2 /2 + GRID UNDEROVER TRUNCATE VIA6_W_2 /2 + GRID
}
#ENDIF
VIA6.S.1 { @ Space >= ^VIA6_S_1 um 
  EXT VIA6 < VIA6_S_1 ABUT < 90 SINGULAR REGION
}
VIA6.S.2 { @ Space to 3-neighboring VIAx (< 0.19 um distance) >= ^VIA6_S_2 um
  X = WITH NEIGHBOR VIA6_EXD > 2 SPACE < VIA6_S_2_S
  EXT X VIA6 < VIA6_S_2 ABUT < 90 SINGULAR REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// VIA6.S.3.R is checked by RR:VIA6.S.3
    RR:VIA6.S.3 { @ Two adjacent VIAx space between different net if the common run length > 0 um, >= 0.17 um
      VIA6_NODAL = STAMP VIA6 BY VIA6i
      EXT VIA6_NODAL < VIA6_S_3R ABUT < 90 NOT CONNECTED OPPOSITE REGION
    }
  #ENDIF
#ENDIF

// VIA6.EN.0 is checked by either {VIA6.EN.1/VIA6.EN.2} or VIA6.EN.3

VIA6.EN.1 { @ Enclosure by Mx or M1 >= ^VIA6_EN_1 um 
  ENC VIA6 M6 < VIA6_EN_1 ABUT < 90 SINGULAR REGION
  VIA6 NOT M6
}

// VIA6.EN.2 is checked by VIA6.EN.2__VIA6.EN.3
// VIA6.EN.3 is checked by VIA6.EN.2__VIA6.EN.3
VIA6.EN.2__VIA6.EN.3 { @ Enclosure by M6 [at least two opposite sides] >= ^VIA6_EN_2 , or [all sides] >= ^VIA6_EN_3
  X = RECTANGLE ENCLOSURE VIA6 M6 ABUT < 90 SINGULAR GOOD VIA6_EN_1 VIA6_EN_2 OPPOSITE VIA6_EN_1 VIA6_EN_2 OPPOSITE
ENC X M6 < VIA6_EN_3 ABUT < 90 SINGULAR REGION
}

// VIA6.R.1 is checked by VIA6.W.1
// VIA6.R.2 is checked by VIA6.R.2__VIA6.R.3
// VIA6.R.3 is checked by VIA6.R.2__VIA6.R.3
// VIA6.R.2.S80 is checked by VIA6.R.2__VIA6.R.3
// VIA6.R.3.S80 is checked by VIA6.R.2__VIA6.R.3
VIA6.R.2__VIA6.R.3 { @ When M6 or M7 width > ^VIA6_R_2_W um, more than one VIA6 is required.
                    @ 2 vias spacing should be <= ^VIA6_R_2_S1 um or 4 vias spacing should be <= ^VIA6_R_2_S2 um
                    @ or 9 vias spacing should be <= ^VIA6_R_2_S3 um
                    @ When M6 or M7 width > ^VIA6_R_3_W um, more than three VIA6 is required.
                    @ 4 vias spacing should be <= ^VIA6_R_3_S1 um or 9 vias spacing should be <= ^VIA6_R_3_S2 um

M7OvpM6_W_ = (M6Wide_0.42_VIA6 AND M7) OR (M7Wide_0.42_VIA6 AND M6)
M7OvpM6_B  = (M6Wide_1.14_VIA6 AND M7) OR (M7Wide_1.14_VIA6 AND M6)
M7OvpM6_W  = M7OvpM6_W_ NOT M7OvpM6_B 
Checked_VIA6_W_ = VIA6_EXD NOT OUTSIDE M7OvpM6_W
Checked_VIA6_B  = VIA6_EXD NOT OUTSIDE M7OvpM6_B
Checked_VIA6_W  = Checked_VIA6_W_ NOT Checked_VIA6_B

M6_effect = M6i INTERACT M7OvpM6_W_
M7_effect = M7i INTERACT M7OvpM6_W_
effect_M7OvpM6_ = M6_effect AND M7_effect
effect_M7OvpM6 = effect_M7OvpM6_ INTERACT M7OvpM6_W_
effect_VIA = VIA6_EXD INTERACT effect_M7OvpM6
    
V6Merged_A = SIZE effect_VIA BY VIA6_R_2_S1/2 INSIDE OF effect_M7OvpM6 STEP 0.098
V6Merged_B = SIZE V6Merged_A BY (VIA6_R_2_S2 - VIA6_R_2_S1)/2 INSIDE OF effect_M7OvpM6 STEP 0.098
V6Merged_C = SIZE V6Merged_B BY (VIA6_R_3_S2 - VIA6_R_2_S2)/2 INSIDE OF effect_M7OvpM6 STEP 0.098
V6Merged_A2R = V6Merged_A INTERACT effect_VIA < 2
V6Merged_A2 = V6Merged_A OUTSIDE V6Merged_A2R
V6Merged_A4R = V6Merged_A2 INTERACT effect_VIA < 4
V6Merged_A4 = V6Merged_A2 OUTSIDE V6Merged_A4R
V6Merged_B4R = V6Merged_B INTERACT effect_VIA < 4
V6Merged_B4 = V6Merged_B OUTSIDE V6Merged_B4R
V6Merged_C9R = V6Merged_C INTERACT effect_VIA < 9
V6Merged_C9 = V6Merged_C OUTSIDE V6Merged_C9R

GMergeW = (V6Merged_A2 OR V6Merged_B4) OR V6Merged_C9
GMergeB = V6Merged_A4 OR V6Merged_C9

GVIA_W = Checked_VIA6_W INTERACT GMergeW
GVIA_B = Checked_VIA6_B INTERACT GMergeB
GOOD_AREA_W = M7OvpM6_W INTERACT GVIA_W
GOOD_AREA_B = M7OvpM6_B INTERACT GVIA_B
Checked_VIA6_W OUTSIDE GOOD_AREA_W
Checked_VIA6_B OUTSIDE GOOD_AREA_B
}
// VIA6.R.4 is checked by VIA6.R.4:M6
// VIA6.R.4.S80 is checked by VIA6.R.4:M6
VIA6.R.4:M6 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M6Wide_0.7_VIA6 BY VIA6_R_4_D + GRID) NOT M6Wide_0.7_VIA6) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_0.7_VIA6) INTERACT VIA6
  Branch1Edge = M6Wide_0.7_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_4_D INSIDE OF Branch1HasVia STEP M6_S_1*0.5
  GoodBranch = (Branch AND M7) INTERACT VIA6 > 1
  BranchSingleVia = (VIA6 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA6 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA6.R.4 is checked by VIA6.R.4:M7
// VIA6.R.4.S80 is checked by VIA6.R.4:M7
VIA6.R.4:M7 { @ At least 2 VIAx must be used for a connection that is <= 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W). (It is allowed to use one VIAx for a connection that is > 1 um (D) away from a metal plate (either Mx or Mx+1) with length > 0.7 um (L) and width > 0.7 um (W).)
  Branch1 = ((SIZE M7Wide_0.7_VIA6 BY VIA6_R_4_D + GRID) NOT M7Wide_0.7_VIA6) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Wide_0.7_VIA6) INTERACT VIA6
  Branch1Edge = M7Wide_0.7_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_4_D INSIDE OF Branch1HasVia STEP M7_S_1*0.5
  GoodBranch = (Branch AND M6) INTERACT VIA6 > 1
  BranchSingleVia = (VIA6 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA6 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA6.R.5 is checked by VIA6.R.5:M6
// VIA6.R.5.S80 is checked by VIA6.R.5:M6
VIA6.R.5:M6 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M6Wide_2_VIA6 BY VIA6_R_5_D + GRID) NOT M6Wide_2_VIA6) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Wide_2_VIA6) INTERACT VIA6
  Branch1Edge = M6Wide_2_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_5_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M7) INTERACT VIA6 > 1
  BranchSingleVia = (VIA6 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA6 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA6.R.5 is checked by VIA6.R.5:M7
// VIA6.R.5.S80 is checked by VIA6.R.5:M7
VIA6.R.5:M7 { @ At least 2 VIAx must be used for a connection that is <= 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W). (It is allowed to use one VIAx for a connection that is > 2 um (D) away from a metal plate (either Mx or Mx+1) with length > 2 um (L) and width > 2 um (W).)   
  Branch1 = ((SIZE M7Wide_2_VIA6 BY VIA6_R_5_D + GRID) NOT M7Wide_2_VIA6) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Wide_2_VIA6) INTERACT VIA6
  Branch1Edge = M7Wide_2_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_5_D INSIDE OF Branch1HasVia STEP M7_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA6 > 1
  BranchSingleVia = (VIA6 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA6 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M6Big_3_VIA6 = ENCLOSE RECTANGLE M6Wide_3_VIA6 VIA6_R_6_W VIA6_R_6_L+GRID
// VIA6.R.6 is checked by VIA6.R.6:M6
// VIA6.R.6.S80 is checked by VIA6.R.6:M6
VIA6.R.6:M6 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M6Big_3_VIA6 BY VIA6_R_6_D + GRID) NOT M6Big_3_VIA6) AND M6
  Branch1HasVia = (Branch1 INTERACT M6Big_3_VIA6) INTERACT VIA6
  Branch1Edge = M6Big_3_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_6_D INSIDE OF Branch1HasVia STEP M6_S_1*0.7
  GoodBranch = (Branch AND M7) INTERACT VIA6 > 1
  BranchSingleVia = (VIA6 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M6) INTERACT BranchSingleVia) INTERACT VIA6 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M7Big_3_VIA6 = ENCLOSE RECTANGLE M7Wide_3_VIA6 VIA6_R_6_W VIA6_R_6_L+GRID
// VIA6.R.6 is checked by VIA6.R.6:M7
// VIA6.R.6.S80 is checked by VIA6.R.6:M7
VIA6.R.6:M7 { @ At least 2 VIAx must be used for a connection that is <= 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W). (It is allowed to use one VIAx for a connection that is > 5 um (D) away from a metal plate (either Mx or Mx+1) with length > 10 um (L) and width > 3 um (W))   
  Branch1 = ((SIZE M7Big_3_VIA6 BY VIA6_R_6_D + GRID) NOT M7Big_3_VIA6) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Big_3_VIA6) INTERACT VIA6
  Branch1Edge = M7Big_3_VIA6 COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA6_R_6_D INSIDE OF Branch1HasVia STEP M7_S_1*0.7
  GoodBranch = (Branch AND M6) INTERACT VIA6 > 1
  BranchSingleVia = (VIA6 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M6 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA6 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}
// VIA6.R.7 is checked by VIA6.EN.1
// VIA6.R.9 can't be checked


VIA6.R.11 { @ Single VIAx is not allowed for mesh-shape  Mx+1 when all of the following conditions come into existence:
@ 1. The Mx+1 has mesh-shape interact with two metal holes : both two metal hole area <= ^VIA6_R_11_A um2 and two metal hole length(L2) <= ^VIA6_R_11_L2 um
@ 2. The VIAx overlaps on the center metal bar of this mesh-shape Mx+1 
@ 3. The length (L) of the center metal bar <= 1um and the width of metal bar is <= 0.42um. 



    
  W = M7i WITH WIDTH <= VIA6_R_11_W   
  H_HOLE = (HOLES M7i INNER <= VIA6_R_11_A) INTERACT W
  A0 = M7i INTERACT H_HOLE
  A = A0 COIN OUTSIDE EDGE H_HOLE
  B0 = ((INT A <= VIA6_R_11_W ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) INTERACT H_HOLE == 2 
  B1 = (((INT A <= VIA6_R_11_L ABUT<90 OPPOSITE REGION EXCLUDE SHIELDED 4) INSIDE A0) AND W) INTERACT H_HOLE == 2
  HOLE_NOTCH = EXT H_HOLE <= VIA6_R_11_W ABUT<90 OPPOSITE NOTCH REGION  
  B2 = (B1 NOT HOLE_NOTCH) OR B0
  CORNER_M = ((EXT B2 <= VIA6_R_11_W ABUT == 90 INTERSECTING ONLY REGION EXTENTS) TOUCH B2 == 2) AND W
  B = B2 OR CORNER_M
  CENTER_BAR1 = NOT ENCLOSE RECTANGLE B GRID VIA6_R_11_L+GRID
  CENTER_BAR2 = (CENTER_BAR1 INTERACT H_HOLE == 2) INTERACT VIA6i
  C = CENTER_BAR2 COIN OUTSIDE EDGE H_HOLE 
  D = EXT [C] A <= VIA6_R_11_L2 OPPOSITE  
  E = C NOT COIN INSIDE EDGE D
  CENTER_BAR3 = CENTER_BAR2 NOT WITH EDGE E
  CHECK_VIA = VIA6i NOT OUTSIDE CENTER_BAR3
  CHECK_VIA AND (((A0 INTERACT CHECK_VIA) AND (M6i INTERACT CHECK_VIA)) INTERACT VIA6i == 1)
}


//M7 CHECKS
//=========
#IFDEF N80
  M7A = M7Wide_N80first NOT CB_NON_CUP
#ENDIF

M71 = M7Wide_first NOT CB_NON_CUP
M72 = M7Wide_1.5 NOT CB_NON_CUP
M73 = M7Wide_4.5 NOT CB_NON_CUP


VARIABLE M7_A_2pre ((M7_A_2 + (M7_S_1 * M7_S_1 * 3.142))/(2 * M7_S_1))*((M7_A_2 + (M7_S_1 * M7_S_1 * 3.142))/(2 * M7_S_1))/3.141

M7HO = HOLES M7 INNER < M7_A_2pre

M7HOC = M7HO NOT M7

M7AS3 = AREA M7 > M7_S_3_L*M7_W_1  // filter small metal for M7.S.3
M7AS4 = AREA M7AS3 > M7_S_4_L*M7_W_1  // filter small metal for M7.S.4

M7.W.1 { @ Width >= ^M7_W_1 um 
  INT M7 < M7_W_1 ABUT < 90 SINGULAR REGION
}
M7.W.2 { @ Width of 45-degree bent Mx >= ^M7_W_2 um 
  INT M7_EDGE_45 < M7_W_2 ABUT < 90 REGION
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M7.W.2.R is checked by RR:M7.W.2
    RR:M7.W.2 { @ Width of 45-degree bent Mx >= ^M7_W_2R um 
      INT M7_EDGE_45 < M7_W_2R ABUT < 90 REGION
    }
  #ENDIF
#ENDIF


M7.W.3 { @ Maximum width [Except WBDMY, if Mx is Mtop-1 layer] <= ^M7_W_3 um 
  SIZE M7 BY M7_W_3 /2 UNDEROVER TRUNCATE M7_W_3 /2
}
M7.S.1 { @ Space >= ^M7_S_1 um 
  EXT M7 < M7_S_1 ABUT < 90 SINGULAR REGION
}
// M7.S.2.S80 is checked by M7.S.2
M7.S.2 { @ Space [at least one metal line width > M7_S_2_W um and the parallel metal run length > M7_S_2_L um] >= ^M7_S_2 um
  X = EXT M71 M7 < M7_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_L+GRID
}
#IFDEF N80
  M7.S.2.1.S80 { @ Space [at least one metal line width > 0.21um(W1) and the parallel metal run length > 0.8um(L1)] >= 0.15um
  X = EXT M7A M7 < M7_S_2_1 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_2_1_L+GRID
  }
#ENDIF


// M7.S.3.S80 is checked by M7.S.3
M7.S.3 { @ Space [at least one metal line width > M7_S_3_W um and the parallel metal run length > M7_S_3_L um] >= ^M7_S_3 um
  X = EXT M72 M7AS3 < M7_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_3_L+GRID
}
// M7.S.4.S80 is checked by M7.S.4
M7.S.4 { @ Space [at least one metal line width > M7_S_4_W um and the parallel metal run length > M7_S_4_L um] >= ^M7_S_4 um
  X = EXT M73 M7AS4 < M7_S_4 OPPOSITE REGION MEASURE ALL
  Y = X NOT M7
  ENCLOSE RECTANGLE Y GRID M7_S_4_L+GRID
}
M7.S.5 { @ Space to 45-degree bent Mx >= ^M7_S_5 um 
  X = EXPAND EDGE M7_EDGE_45 OUTSIDE BY M7_S_5
  X AND M7
}
#IFDEF RECOMMENDED_NONSHRINKABLE_RULE
  #IFDEF N80
// M7.S.5.R is checked by RR:M7.S.5
    RR:M7.S.5 { @ Mx space to 45-degree bent Mx >= ^M7_S_5R um 
      X = EXPAND EDGE M7_EDGE_45 OUTSIDE BY M7_S_5R
      X AND M7
    }
  #ENDIF
#ENDIF

// M7.EN.0 is checked by either {M7.EN.1/M7.EN.2} or M7.EN.3
M7.EN.1 { @ Enclosure of VIAx-1 >= ^M7_EN_1 um 
  ENC VIA6 M7 < M7_EN_1 ABUT < 90 SINGULAR REGION
  VIA6 NOT M7
}
// M7.EN.2 is checked by M7.EN.2__M7.EN.3
// M7.EN.3 is checked by M7.EN.2__M7.EN.3
M7.EN.2__M7.EN.3 { @ Enclosure of VIAx-1 [at least 2 opposite sides] >= ^M7_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA6 M7 ABUT < 90 SINGULAR GOOD M7_EN_1 M7_EN_2 OPPOSITE M7_EN_1 M7_EN_2 OPPOSITE
  ENC X M7 < M7_EN_3 ABUT < 90 SINGULAR REGION
}

M7.A.1 { @ Area >= ^M7_A_1 um2
  AREA M7 < M7_A_1
}
M7.A.2 { @ Enclosed area >= ^M7_A_2 um
  AREA M7HOC < M7_A_2
}


CHIP_NOT_M7_EXC_HIGH = CHIP NOT M7_EXC_H  // for high density check
M7_NOT_EXC_HIGH = M7x NOT M7_EXC_H       // for high density check 
CHIP_NOT_M7_EXC_L = CHIP NOT M7_EXC_L1    // for low density check
M7_NOT_EXC_L = M7x NOT M7_EXC_L1         // for low density check

// For density check in DMxEXCL
CHIP_AND_DM7EXCL_HIGH = CHIP_NOT_M7_EXC_HIGH AND DM7EXCL  // for high density check
M7_AND_DM7EXCL_HIGH = M7_NOT_EXC_HIGH AND DM7EXCL        // for high density check
CHIP_AND_DM7EXCL = CHIP_NOT_M7_EXC_L AND DM7EXCL 	     // for low density check
M7_AND_DM7EXCL = M7_NOT_EXC_L AND DM7EXCL                // for low density check

#IFDEF DENSITY_IN_BLOCKAGE
// M7.DN.3 is checked by M7.DN.3:L
// M7.DN.3a is checked by M7.DN.3:L
M7.DN.3:L { @ M7 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um (with DM7EXCL region)
  ERR1 = DENSITY M7_AND_DM7EXCL CHIP_AND_DM7EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]
  ERR2 = DENSITY M7_NOT_EXC_L CHIP_NOT_M7_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_NOT_EXC_L)/AREA(CHIP_NOT_M7_EXC_L) ]	
  K = SIZE (((ERR1 AND DM7EXCL) INSIDE ERR2) NOT M7_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M7_AND_DM7EXCL CHIP_AND_DM7EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M7.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]

}
// M7.DN.3 is checked by M7.DN.3:H 
// M7.DN.3d is checked by M7.DN.3:H 
M7.DN.3:H { @ M7 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 umx ^Mx_DN_W2 um step 50um (with DM7EXCL region)
  ERR1 = DENSITY M7_AND_DM7EXCL_HIGH CHIP_AND_DM7EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_AND_DM7EXCL_HIGH)/AREA(CHIP_AND_DM7EXCL_HIGH) ]
  ERR2 = DENSITY M7_NOT_EXC_HIGH CHIP_NOT_M7_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_NOT_EXC_HIGH)/AREA(CHIP_NOT_M7_EXC_HIGH) ]
  K = SIZE (((ERR1 AND DM7EXCL) INSIDE ERR2) NOT M7_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M7_AND_DM7EXCL_HIGH CHIP_AND_DM7EXCL_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M7.DN.3H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*(AREA(M7_AND_DM7EXCL_HIGH)/AREA(CHIP_AND_DM7EXCL_HIGH)) ]
}
#ELSE
#IFDEF FULL_CHIP
// M7.DN.1 is checked by M7.DN.1__M7.DN.3:L
// M7.DN.3 is checked by M7.DN.1__M7.DN.3:L
// M7.DN.1a is checked by M7.DN.1__M7.DN.3:L
// M7.DN.3a is checked by M7.DN.1__M7.DN.3:L
M7.DN.1__M7.DN.3:L { @ M7 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 umx ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M7_NOT_EXC_L CHIP_NOT_M7_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
[ AREA(M7_NOT_EXC_L)/AREA(CHIP_NOT_M7_EXC_L) ]
  K = SIZE (ERR_WIN NOT M7_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M7_NOT_EXC_L CHIP_NOT_M7_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M7.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M7_NOT_EXC_L)/AREA(CHIP_NOT_M7_EXC_L) ]
}
#ELSE  // IP/macro/block level
#IFDEF DENSITY_FOR_NONFULLCHIP
// M7.DN.1 is checked by M7.DN.1__M7.DN.3:L
// M7.DN.3 is checked by M7.DN.1__M7.DN.3:L
// M7.DN.1a is checked by M7.DN.1__M7.DN.3:L
// M7.DN.3a is checked by M7.DN.1__M7.DN.3:L
M7.DN.1__M7.DN.3:L { @ M7 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um in whole chip
  ERR_WIN = DENSITY M7_NOT_EXC_L CHIP_NOT_M7_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_NOT_EXC_L)/AREA(CHIP_NOT_M7_EXC_L) ]
  K = SIZE (ERR_WIN NOT M7_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M7_NOT_EXC_L CHIP_NOT_M7_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M7.DN.1L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M7_NOT_EXC_L)/AREA(CHIP_NOT_M7_EXC_L) ]
}
#ELSE
// M7.DN.3 is checked by M7.DN.3:L
// M7.DN.3a is checked by M7.DN.3:L
M7.DN.3:L { @ M7 area coverage must be > ^Mx_DN_1L range over ^Mx_DN_W1 um x ^Mx_DN_W1 um step 25um (with DM7EXCL region)
  ERR1 = DENSITY M7_AND_DM7EXCL CHIP_AND_DM7EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]
  ERR2 = DENSITY M7_NOT_EXC_L CHIP_NOT_M7_EXC_L < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_NOT_EXC_L)/AREA(CHIP_NOT_M7_EXC_L) ]
  K = SIZE (((ERR1 AND DM7EXCL) INSIDE ERR2) NOT M7_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2 
  DENSITY K M7_AND_DM7EXCL CHIP_AND_DM7EXCL < Mx_DN_1L WINDOW Mx_DN_W1 STEP 25 BACKUP PRINT M7.DN.3L.density INSIDE OF LAYER CHIP 
    [ !AREA(K)+AREA(M7_AND_DM7EXCL)/AREA(CHIP_AND_DM7EXCL) ]
}
#ENDIF
#ENDIF
// M7.DN.1 is checked by M7.DN.1__M7.DN.3:H
// M7.DN.3 is checked by M7.DN.1__M7.DN.3:H
// M7.DN.1d is checked by M7.DN.1__M7.DN.3:H
// M7.DN.3d is checked by M7.DN.1__M7.DN.3:H
M7.DN.1__M7.DN.3:H { @ M7 area coverage must be < ^Mx_DN_1H range over ^Mx_DN_W2 um x ^Mx_DN_W2 um step 50um 
  ERR_WIN = DENSITY M7_NOT_EXC_HIGH CHIP_NOT_M7_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP INSIDE OF LAYER CHIP 
    [ AREA(M7_NOT_EXC_HIGH)/AREA(CHIP_NOT_M7_EXC_HIGH) ]
  K = SIZE (ERR_WIN NOT M7_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M7_NOT_EXC_HIGH CHIP_NOT_M7_EXC_HIGH > Mx_DN_1H WINDOW Mx_DN_W2 STEP 50 BACKUP PRINT M7.DN.1H.density INSIDE OF LAYER CHIP 
    [ !!AREA(K)*AREA(M7_NOT_EXC_HIGH)/AREA(CHIP_NOT_M7_EXC_HIGH) ]
}
#ENDIF

M7.DN.2 { @ M7 local density must be < 90% range over 20umx20um step 10um
  DENSITY M7x CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M7.DN.2.density 
    [ AREA(M7x)/AREA(CHIP) ]
}  

// M7.R.1 can not be checked


//VIA7 CHECKS
//===========

VIA7.W.1 { @ Width (square)(maximum = minimum) = ^VIA7_W_1 um
  A = NOT RECTANGLE VIA7 == VIA7_W_1 BY == VIA7_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA7.W.2 { @ Width of VIAn bar = ^VIA7_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring. 
  INT SR_VIA7 < VIA7_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_VIA7 BY VIA7_W_2 /2 + GRID UNDEROVER TRUNCATE VIA7_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 2 0.005
}
VIA7.S.1 { @ Space >= ^VIA7_S_1 um 
  EXT (VIA7 NOT SR_VIA7) < VIA7_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIA7.W.2 { @ Width of VIAn bar = ^VIA7_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring.
  INT SR_VIA7 < VIA7_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_VIA7 BY VIA7_W_2 /2 + GRID UNDEROVER TRUNCATE VIA7_W_2 /2 + GRID
}
VIA7.S.1 { @ Space >= ^VIA7_S_1 um
  EXT VIA7 < VIA7_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF
VIA7.S.2 { @ Space to 3-neighboring VIAn (<^VIA7_S_2_S um distance) >= ^VIA7_S_2 um
  X = WITH NEIGHBOR VIA7_EXD > 2 SPACE < VIA7_S_2_S
  EXT X VIA7 < VIA7_S_2 ABUT < 90 SINGULAR REGION
}

VIA7.EN.2 { @ Enclosure by M7 [at least two opposite sides] >= ^VIA7_EN_2 um
  X = RECTANGLE ENCLOSURE VIA7 M7 ABUT < 90 SINGULAR GOOD VIA7_EN_1 VIA7_EN_2 OPPOSITE VIA7_EN_1 VIA7_EN_2 OPPOSITE
  Y = ENC [X] M7 < VIA7_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA7_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}


// VIA7.R.1 is checked by VIA7.W.1

M8Wide_1.8_VIA7T = (SIZE M8 BY VIA7_R_2_W /2 UNDEROVER TRUNCATE VIA7_R_2_W /2) AND M8
M7Wide_1.8_VIA7T = (SIZE M7 BY VIA7_R_2_W /2 UNDEROVER TRUNCATE VIA7_R_2_W /2) AND M7
M8Wide_3_VIA7T = (SIZE M8Wide_1.8_VIA7T BY VIA7_R_3_W /2 UNDEROVER TRUNCATE VIA7_R_3_W /2) AND M8Wide_1.8_VIA7T
M7Wide_3_VIA7T = (SIZE M7Wide_1.8_VIA7T BY VIA7_R_3_W /2 UNDEROVER TRUNCATE VIA7_R_3_W /2) AND M7Wide_1.8_VIA7T
//VIA7.R.2.S80 is checked by VIA7.R.2
VIA7.R.2 { @ At least two VIAn with spacing <= ^VIA7_R_2_S are required to connect Mn and Mn+1 when one of these metals has a width and length > ^VIA7_R_2_W um.
   M8OvpM7W = (M8 AND M7Wide_1.8_VIA7T) OR (M7 AND M8Wide_1.8_VIA7T)
   Checked_VIA7 = VIA7_EXD NOT OUTSIDE M8OvpM7W
   M7_effect = M7i INTERACT M8OvpM7W
   M8_effect = M8i INTERACT M8OvpM7W
   effect_M8OvpM7_ = M7_effect AND M8_effect
   effect_M8OvpM7 = effect_M8OvpM7_ INTERACT M8OvpM7W
   Effect_VIA7 = VIA7_EXD INTERACT effect_M8OvpM7

   VIA7Merged = SIZE Effect_VIA7 BY VIA7_R_2_S /2 INSIDE OF effect_M8OvpM7 STEP M7_S_1*0.7
   VIA7Merged2 = VIA7Merged ENCLOSE Effect_VIA7 >=2
   GVIA = Checked_VIA7 INTERACT VIA7Merged2
   GM8OvpM7W = M8OvpM7W INTERACT GVIA
   Checked_VIA7 OUTSIDE GM8OvpM7W

}   

M7Big_3_VIA7T = ENCLOSE RECTANGLE M7Wide_3_VIA7T VIA7_R_3_W VIA7_R_3_L+GRID
// VIA7.R.3 is checked by VIA7.R.3:M7
// VIA7.R.3.S80 is checked by VIA7.R.3:M7
VIA7.R.3:M7 { @ At least two VIAn must be used for a connection that is <= ^VIA7_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA7_R_3_L (L) and width > ^VIA7_R_3_W (W). (It is allowed to use one VIAn for a connection that is > ^VIA7_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA7_R_3_L (L) and width > ^VIA7_R_3_W (W)). 
  Branch1 = ((SIZE M7Big_3_VIA7T BY VIA7_R_3_D + GRID) NOT M7Big_3_VIA7T) AND M7
  Branch1HasVia = (Branch1 INTERACT M7Big_3_VIA7T) INTERACT VIA7
  Branch1Edge = M7Big_3_VIA7T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_3_D INSIDE OF Branch1HasVia STEP M7_S_1*0.7
  GoodBranch = (Branch AND M8) INTERACT VIA7 > 1
  BranchSingleVia = (VIA7 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M8 INTERACT BranchSingleVia) AND M7) INTERACT BranchSingleVia) INTERACT VIA7 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M8Big_3_VIA7T = ENCLOSE RECTANGLE M8Wide_3_VIA7T VIA7_R_3_W VIA7_R_3_L+GRID
// VIA7.R.3 is checked by VIA7.R.3:M8
VIA7.R.3:M8 { @ At least two VIAn must be used for a connection that is <= ^VIA7_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA7_R_3_L (L) and width > ^VIA7_R_3_W (W). (It is allowed to use one VIAn for a connection that is > ^VIA7_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA7_R_3_L (L) and width > ^VIA7_R_3_W (W)).
  Branch1 = ((SIZE M8Big_3_VIA7T BY VIA7_R_3_D + GRID) NOT M8Big_3_VIA7T) AND M8
  Branch1HasVia = (Branch1 INTERACT M8Big_3_VIA7T) INTERACT VIA7
  Branch1Edge = M8Big_3_VIA7T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA7_R_3_D INSIDE OF Branch1HasVia STEP M8_S_1*0.7
  GoodBranch = (Branch AND M7) INTERACT VIA7 > 1
  BranchSingleVia = (VIA7 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M7 INTERACT BranchSingleVia) AND M8) INTERACT BranchSingleVia) INTERACT VIA7 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

// VIA7.R.4 is checked by VIA7.EN.1
// VIA7.R.5 can not be checked.


//M8 CHECKS
//=============

M8Wide_1.5 = (SIZE M8 BY M8_S_2_W /2 UNDEROVER TRUNCATE M8_S_2_W /2) AND M8
M8Wide_4.5 = (SIZE M8Wide_1.5 BY M8_S_3_W /2 UNDEROVER TRUNCATE M8_S_3_W /2) AND M8Wide_1.5

M81 = (M8Wide_1.5 NOT CB) NOT WBDMY
M82 = (M8Wide_4.5 NOT CB) NOT WBDMY

VARIABLE M8_A_2pre ((M8_A_2 + (M8_S_1 * M8_S_1 * 3.142))/(2 * M8_S_1))*((M8_A_2 + (M8_S_1 * M8_S_1 * 3.142))/(2 * M8_S_1))/3.141
M8HO = HOLES M8 INNER < M8_A_2pre 

M8HOC = M8HO NOT M8

M8nAS2 = AREA M8 > M8_S_2_L*M8_W_1  // filter small metal for M8.S.2
M8nAS3 = AREA M8nAS2 > M8_S_3_L*M8_W_1  // filter small metal for M8.S.3





#IFNDEF UTM
M8.W.1 { @ Width >= ^M8_W_1 um 
  INT M8 < M8_W_1 ABUT < 90 SINGULAR REGION
}
M8.W.2 { @ Max. width [except bond pad] <= ^M8_W_2 um 
  SIZE M8_MAX_WIDTH BY M8_W_2 /2 UNDEROVER TRUNCATE M8_W_2 /2
}
#ENDIF
M8.S.1 { @ Space >= ^M8_S_1 um 
  EXT M8 < M8_S_1 ABUT < 90 SINGULAR REGION
}
// M8.S.2.S80 is checked by M8.S.2
M8.S.2 { @ Space [at least one metal line width > ^M8_S_2_W um (W1) and
             @ the parallel metal run length > ^M8_S_2_L um (L1)] >= ^M8_S_2 um
  X = EXT M81 M8nAS2 < M8_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_2_L+GRID
}
// M8.S.3.S80 is checked by M8.S.3
M8.S.3 { @ Space [at least one metal line width > ^M8_S_3_W um (W2) and
             @ the parallel metal run length > ^M8_S_3_L um (L2)] >= ^M8_S_3 um
  X = EXT M82 M8nAS3 < M8_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M8
  ENCLOSE RECTANGLE Y GRID M8_S_3_L+GRID
}
M8.EN.1 { @ Enclosure of VIA7 >= ^M8_EN_1 um 
  ENC VIA7 M8 < M8_EN_1 ABUT < 90 SINGULAR REGION
  VIA7 NOT M8
}
M8.EN.2 { @ Enclosure of VIA7 [at least two opposite sides] >= ^M8_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA7 M8 ABUT < 90 SINGULAR GOOD M8_EN_1 M8_EN_2 OPPOSITE M8_EN_1 M8_EN_2 OPPOSITE
  Y = ENC [X] M8 < M8_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA7_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
M8.A.1 { @ Area >= ^M8_A_1 um2
  AREA M8 < M8_A_1
}
M8.A.2 { @ Enclosed area >= ^M8_A_2 um
  AREA M8HOC < M8_A_2
}


CHIP_NOT_M8_EXC_H = CHIP NOT M8_EXC_H  // For high density limit
CHIP_NOT_M8_EXC_L = CHIP NOT M8_EXC_L1 // For low density limit
M8_NOT_EXC_H = M8x NOT M8_EXC_H
M8_NOT_EXC_L = M8x NOT M8_EXC_L1

// For density check in DMxEXCL
CHIP_AND_DM8EXCL_L = CHIP_NOT_M8_EXC_L AND DM8EXCL  // low density check include CB
M8_AND_DM8EXCL_L = M8_NOT_EXC_L AND DM8EXCL     // low density check include CB
CHIP_AND_DM8EXCL_H = CHIP_NOT_M8_EXC_H AND DM8EXCL  // high density check exclude CB
M8_AND_DM8EXCL_H = M8_NOT_EXC_H AND DM8EXCL     // high density check exclude CB

#IFDEF CU_WIRE
M8x_NOT_PAD = M8x NOT CBMT
#ELSE
M8x_NOT_PAD = M8x NOT WBDMY
#ENDIF

  #IFDEF DENSITY_IN_BLOCKAGE
// M8.DN.3 is checked by M8.DN.3:L
// M8.DN.3b is checked by M8.DN.3:L
M8.DN.3:L { @ M8 area coverage must be > 20% range over 50umx50um step 25um (with DM8EXCL region)
  ERR1 = DENSITY M8_AND_DM8EXCL_L CHIP_AND_DM8EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_AND_DM8EXCL_L)/AREA(CHIP_AND_DM8EXCL_L) ]
  ERR2 = DENSITY M8_NOT_EXC_L CHIP_NOT_M8_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_NOT_EXC_L)/AREA(CHIP_NOT_M8_EXC_L) ]
  K = SIZE (((ERR1 AND DM8EXCL) INSIDE ERR2) NOT M8_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M8_AND_DM8EXCL_L CHIP_AND_DM8EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M8.DN.3L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M8_AND_DM8EXCL_L)/AREA(CHIP_AND_DM8EXCL_L) ]
}
// M8.DN.3 is checked by M8.DN.3:H
// M8.DN.3e is checked by M8.DN.3:H
M8.DN.3:H { @ M8 area coverage must be < 80% range over 100umx100um step 50um (with DM8EXCL region)
  ERR1 = DENSITY M8_AND_DM8EXCL_H CHIP_AND_DM8EXCL_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_AND_DM8EXCL_H)/AREA(CHIP_AND_DM8EXCL_H) ]
  ERR2 = DENSITY M8_NOT_EXC_H CHIP_NOT_M8_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_NOT_EXC_H)/AREA(CHIP_NOT_M8_EXC_H) ]	
  K = SIZE (((ERR1 AND DM8EXCL) INSIDE ERR2) NOT M8_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M8_AND_DM8EXCL_H CHIP_AND_DM8EXCL_H > 0.8 WINDOW 100 STEP 50 BACKUP PRINT M8.DN.3H.density INSIDE OF LAYER CHIP [ !!AREA(K)*AREA(M8_AND_DM8EXCL_H)/AREA(CHIP_AND_DM8EXCL_H) ]
}
#ELSE
#IFDEF FULL_CHIP
// M8.DN.1 is checked by M8.DN.1__M8.DN.3:L
// M8.DN.3 is checked by M8.DN.1__M8.DN.3:L
// M8.DN.1b is checked by M8.DN.1__M8.DN.3:L
// M8.DN.3b is checked by M8.DN.1__M8.DN.3:L
M8.DN.1__M8.DN.3:L { @ M8 area coverage must be > 20% range over 50umx50um step 25um in whole chip 
  ERR_WIN = DENSITY M8_NOT_EXC_L CHIP_NOT_M8_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_NOT_EXC_L)/AREA(CHIP_NOT_M8_EXC_L) ]
  K = SIZE (ERR_WIN NOT M8_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M8_NOT_EXC_L CHIP_NOT_M8_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M8.DN.1L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M8_NOT_EXC_L)/AREA(CHIP_NOT_M8_EXC_L) ]
}
#ELSE
#IFDEF DENSITY_FOR_NONFULLCHIP
// M8.DN.1 is checked by M8.DN.1__M8.DN.3:L
// M8.DN.3 is checked by M8.DN.1__M8.DN.3:L
// M8.DN.1b is checked by M8.DN.1__M8.DN.3:L
// M8.DN.3b is checked by M8.DN.1__M8.DN.3:L
M8.DN.1__M8.DN.3:L { @ M8 area coverage must be > 20% range over 50umx50um step 25um in whole chip 
  ERR_WIN = DENSITY M8_NOT_EXC_L CHIP_NOT_M8_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_NOT_EXC_L)/AREA(CHIP_NOT_M8_EXC_L) ]
  K = SIZE (ERR_WIN NOT M8_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M8_NOT_EXC_L CHIP_NOT_M8_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M8.DN.1L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M8_NOT_EXC_L)/AREA(CHIP_NOT_M8_EXC_L) ]
}
#ELSE
// M8.DN.3 is checked by M8.DN.3:L
// M8.DN.3b is checked by M8.DN.1__M8.DN.3:L
M8.DN.3:L { @ M8 area coverage must be > 20% range over 50umx50um step 25um (with DM8EXCL region)
  ERR1 = DENSITY M8_AND_DM8EXCL_L CHIP_AND_DM8EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_AND_DM8EXCL_L)/AREA(CHIP_AND_DM8EXCL_L) ]
  ERR2 = DENSITY M8_NOT_EXC_L CHIP_NOT_M8_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_NOT_EXC_L)/AREA(CHIP_NOT_M8_EXC_L) ]
	
  K = SIZE (((ERR1 AND DM8EXCL) INSIDE ERR2) NOT M8_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M8_AND_DM8EXCL_L CHIP_AND_DM8EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M8.DN.3L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M8_AND_DM8EXCL_L)/AREA(CHIP_AND_DM8EXCL_L) ]
}
#ENDIF
#ENDIF
// M8.DN.1 is checked by M8.DN.1__M8.DN.3:H
// M8.DN.3 is checked by M8.DN.1__M8.DN.3:H
// M8.DN.1e is checked by M8.DN.1__M8.DN.3:H
// M8.DN.3e is checked by M8.DN.1__M8.DN.3:H
M8.DN.1__M8.DN.3:H { @ M8 area coverage must be < 80% range over 100umx100um step 50um 
  ERR_WIN = DENSITY M8_NOT_EXC_H CHIP_NOT_M8_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(M8_NOT_EXC_H)/AREA(CHIP_NOT_M8_EXC_H) ]
  K = SIZE (ERR_WIN NOT M8_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M8_NOT_EXC_H CHIP_NOT_M8_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP PRINT M8.DN.1H.density INSIDE OF LAYER CHIP [ !!AREA(K)*AREA(M8_NOT_EXC_H)/AREA(CHIP_NOT_M8_EXC_H) ]
}
  #ENDIF
M8.DN.2 { @ M8 local density must be < 90% range over 20umx20um step 10um 
  ERR_WIN = DENSITY M8x_NOT_PAD CHIP > 0.9 WINDOW 20 STEP 10 BACKUP [ AREA(M8x_NOT_PAD)/AREA(CHIP) ]
#IFDEF CU_WIRE
  K = SIZE (ERR_WIN NOT CBMT) BY (5-0.002)/2 UNDEROVER TRUNCATE (5-0.002)/2
#ELSE
  K = SIZE (ERR_WIN NOT WBDMY) BY (5-0.002)/2 UNDEROVER TRUNCATE (5-0.002)/2	
#ENDIF
  DENSITY K M8x_NOT_PAD CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M8.DN.2.density [ !!AREA(K)*AREA(M8x_NOT_PAD)/AREA(CHIP) ]
}
// M8.R.1 can't be checked






//VIA8 CHECKS
//===========

VIA8.W.1 { @ Width (square)(maximum = minimum) = ^VIA8_W_1 um
  A = NOT RECTANGLE VIA8 == VIA8_W_1 BY == VIA8_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIA8.W.2 { @ Width of VIAn bar = ^VIA8_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring. 
  INT SR_VIA8 < VIA8_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_VIA8 BY VIA8_W_2 /2 + GRID UNDEROVER TRUNCATE VIA8_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 2 0.005
}
VIA8.S.1 { @ Space >= ^VIA8_S_1 um 
  EXT (VIA8 NOT SR_VIA8) < VIA8_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIA8.W.2 { @ Width of VIAn bar = ^VIA8_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring.
  INT SR_VIA8 < VIA8_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_VIA8 BY VIA8_W_2 /2 + GRID UNDEROVER TRUNCATE VIA8_W_2 /2 + GRID
}
VIA8.S.1 { @ Space >= ^VIA8_S_1 um
  EXT VIA8 < VIA8_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF
VIA8.S.2 { @ Space to 3-neighboring VIAn (<^VIA8_S_2_S um distance) >= ^VIA8_S_2 um
  X = WITH NEIGHBOR VIA8_EXD > 2 SPACE < VIA8_S_2_S
  EXT X VIA8 < VIA8_S_2 ABUT < 90 SINGULAR REGION
}

VIA8.EN.2 { @ Enclosure by M8 [at least two opposite sides] >= ^VIA8_EN_2 um
  X = RECTANGLE ENCLOSURE VIA8 M8 ABUT < 90 SINGULAR GOOD VIA8_EN_1 VIA8_EN_2 OPPOSITE VIA8_EN_1 VIA8_EN_2 OPPOSITE
  Y = ENC [X] M8 < VIA8_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA8_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}


// VIA8.R.1 is checked by VIA8.W.1

M9Wide_1.8_VIA8T = (SIZE M9 BY VIA8_R_2_W /2 UNDEROVER TRUNCATE VIA8_R_2_W /2) AND M9
M8Wide_1.8_VIA8T = (SIZE M8 BY VIA8_R_2_W /2 UNDEROVER TRUNCATE VIA8_R_2_W /2) AND M8
M9Wide_3_VIA8T = (SIZE M9Wide_1.8_VIA8T BY VIA8_R_3_W /2 UNDEROVER TRUNCATE VIA8_R_3_W /2) AND M9Wide_1.8_VIA8T
M8Wide_3_VIA8T = (SIZE M8Wide_1.8_VIA8T BY VIA8_R_3_W /2 UNDEROVER TRUNCATE VIA8_R_3_W /2) AND M8Wide_1.8_VIA8T
//VIA8.R.2.S80 is checked by VIA8.R.2
VIA8.R.2 { @ At least two VIAn with spacing <= ^VIA8_R_2_S are required to connect Mn and Mn+1 when one of these metals has a width and length > ^VIA8_R_2_W um.
   M9OvpM8W = (M9 AND M8Wide_1.8_VIA8T) OR (M8 AND M9Wide_1.8_VIA8T)
   Checked_VIA8 = VIA8_EXD NOT OUTSIDE M9OvpM8W
   M8_effect = M8i INTERACT M9OvpM8W
   M9_effect = M9i INTERACT M9OvpM8W
   effect_M9OvpM8_ = M8_effect AND M9_effect
   effect_M9OvpM8 = effect_M9OvpM8_ INTERACT M9OvpM8W
   Effect_VIA8 = VIA8_EXD INTERACT effect_M9OvpM8

   VIA8Merged = SIZE Effect_VIA8 BY VIA8_R_2_S /2 INSIDE OF effect_M9OvpM8 STEP M8_S_1*0.7
   VIA8Merged2 = VIA8Merged ENCLOSE Effect_VIA8 >=2
   GVIA = Checked_VIA8 INTERACT VIA8Merged2
   GM9OvpM8W = M9OvpM8W INTERACT GVIA
   Checked_VIA8 OUTSIDE GM9OvpM8W

}   

M8Big_3_VIA8T = ENCLOSE RECTANGLE M8Wide_3_VIA8T VIA8_R_3_W VIA8_R_3_L+GRID
// VIA8.R.3 is checked by VIA8.R.3:M8
// VIA8.R.3.S80 is checked by VIA8.R.3:M8
VIA8.R.3:M8 { @ At least two VIAn must be used for a connection that is <= ^VIA8_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA8_R_3_L (L) and width > ^VIA8_R_3_W (W). (It is allowed to use one VIAn for a connection that is > ^VIA8_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA8_R_3_L (L) and width > ^VIA8_R_3_W (W)). 
  Branch1 = ((SIZE M8Big_3_VIA8T BY VIA8_R_3_D + GRID) NOT M8Big_3_VIA8T) AND M8
  Branch1HasVia = (Branch1 INTERACT M8Big_3_VIA8T) INTERACT VIA8
  Branch1Edge = M8Big_3_VIA8T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA8_R_3_D INSIDE OF Branch1HasVia STEP M8_S_1*0.7
  GoodBranch = (Branch AND M9) INTERACT VIA8 > 1
  BranchSingleVia = (VIA8 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M9 INTERACT BranchSingleVia) AND M8) INTERACT BranchSingleVia) INTERACT VIA8 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

M9Big_3_VIA8T = ENCLOSE RECTANGLE M9Wide_3_VIA8T VIA8_R_3_W VIA8_R_3_L+GRID
// VIA8.R.3 is checked by VIA8.R.3:M9
VIA8.R.3:M9 { @ At least two VIAn must be used for a connection that is <= ^VIA8_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA8_R_3_L (L) and width > ^VIA8_R_3_W (W). (It is allowed to use one VIAn for a connection that is > ^VIA8_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIA8_R_3_L (L) and width > ^VIA8_R_3_W (W)).
  Branch1 = ((SIZE M9Big_3_VIA8T BY VIA8_R_3_D + GRID) NOT M9Big_3_VIA8T) AND M9
  Branch1HasVia = (Branch1 INTERACT M9Big_3_VIA8T) INTERACT VIA8
  Branch1Edge = M9Big_3_VIA8T COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIA8_R_3_D INSIDE OF Branch1HasVia STEP M9_S_1*0.7
  GoodBranch = (Branch AND M8) INTERACT VIA8 > 1
  BranchSingleVia = (VIA8 NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M8 INTERACT BranchSingleVia) AND M9) INTERACT BranchSingleVia) INTERACT VIA8 == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

// VIA8.R.4 is checked by VIA8.EN.1
// VIA8.R.5 can not be checked.


//M9 CHECKS
//=============

M9Wide_1.5 = (SIZE M9 BY M9_S_2_W /2 UNDEROVER TRUNCATE M9_S_2_W /2) AND M9
M9Wide_4.5 = (SIZE M9Wide_1.5 BY M9_S_3_W /2 UNDEROVER TRUNCATE M9_S_3_W /2) AND M9Wide_1.5

M91 = (M9Wide_1.5 NOT MTOP_EXC) NOT WBDMY
M92 = (M9Wide_4.5 NOT MTOP_EXC) NOT WBDMY

VARIABLE M9_A_2pre ((M9_A_2 + (M9_S_1 * M9_S_1 * 3.142))/(2 * M9_S_1))*((M9_A_2 + (M9_S_1 * M9_S_1 * 3.142))/(2 * M9_S_1))/3.141
M9HO = HOLES M9 INNER < M9_A_2pre 

M9HOC = M9HO NOT M9

M9nAS2 = AREA M9 > M9_S_2_L*M9_W_1  // filter small metal for M9.S.2
M9nAS3 = AREA M9nAS2 > M9_S_3_L*M9_W_1  // filter small metal for M9.S.3





#IFNDEF UTM
M9.W.1 { @ Width >= ^M9_W_1 um 
  INT M9 < M9_W_1 ABUT < 90 SINGULAR REGION
}
M9.W.2 { @ Max. width [except bond pad] <= ^M9_W_2 um 
  SIZE M9_MAX_WIDTH BY M9_W_2 /2 UNDEROVER TRUNCATE M9_W_2 /2
}
M9.S.1 { @ Space >= ^M9_S_1 um 
  EXT M9 < M9_S_1 ABUT < 90 SINGULAR REGION
}
// M9.S.2.S80 is checked by M9.S.2
M9.S.2 { @ Space [at least one metal line width > ^M9_S_2_W um (W1) and
             @ the parallel metal run length > ^M9_S_2_L um (L1)] >= ^M9_S_2 um
  X = EXT M91 M9nAS2 < M9_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT M9
  ENCLOSE RECTANGLE Y GRID M9_S_2_L+GRID
}
// M9.S.3.S80 is checked by M9.S.3
M9.S.3 { @ Space [at least one metal line width > ^M9_S_3_W um (W2) and
             @ the parallel metal run length > ^M9_S_3_L um (L2)] >= ^M9_S_3 um
  X = EXT M92 M9nAS3 < M9_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT M9
  ENCLOSE RECTANGLE Y GRID M9_S_3_L+GRID
}
M9.EN.1 { @ Enclosure of VIA8 >= ^M9_EN_1 um 
  ENC VIA8 M9 < M9_EN_1 ABUT < 90 SINGULAR REGION
  VIA8 NOT M9
}
M9.EN.2 { @ Enclosure of VIA8 [at least two opposite sides] >= ^M9_EN_2 um 
  X = RECTANGLE ENCLOSURE VIA8 M9 ABUT < 90 SINGULAR GOOD M9_EN_1 M9_EN_2 OPPOSITE M9_EN_1 M9_EN_2 OPPOSITE
  Y = ENC [X] M9 < M9_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIA8_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
M9.A.1 { @ Area >= ^M9_A_1 um2
  AREA M9 < M9_A_1
}
M9.A.2 { @ Enclosed area >= ^M9_A_2 um
  AREA M9HOC < M9_A_2
}

#ENDIF


CHIP_NOT_M9_EXC_H = CHIP NOT M9_EXC_H  // For high density limit
CHIP_NOT_M9_EXC_L = CHIP NOT M9_EXC_L1 // For low density limit
M9_NOT_EXC_H = M9x NOT M9_EXC_H
M9_NOT_EXC_L = M9x NOT M9_EXC_L1

// For density check in DMxEXCL
CHIP_AND_DM9EXCL_L = CHIP_NOT_M9_EXC_L AND DM9EXCL  // low density check include CB
M9_AND_DM9EXCL_L = M9_NOT_EXC_L AND DM9EXCL     // low density check include CB
CHIP_AND_DM9EXCL_H = CHIP_NOT_M9_EXC_H AND DM9EXCL  // high density check exclude CB
M9_AND_DM9EXCL_H = M9_NOT_EXC_H AND DM9EXCL     // high density check exclude CB

M9x_NOT_PAD = ( M9x NOT MTOP_EXC ) NOT LMARK_MT

#IFNDEF UTM


  #IFDEF DENSITY_IN_BLOCKAGE
// M9.DN.3 is checked by M9.DN.3:L
// M9.DN.3b is checked by M9.DN.3:L
M9.DN.3:L { @ M9 area coverage must be > 20% range over 50umx50um step 25um (with DM9EXCL region)
  ERR1 = DENSITY M9_AND_DM9EXCL_L CHIP_AND_DM9EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_AND_DM9EXCL_L)/AREA(CHIP_AND_DM9EXCL_L) ]
  ERR2 = DENSITY M9_NOT_EXC_L CHIP_NOT_M9_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_NOT_EXC_L)/AREA(CHIP_NOT_M9_EXC_L) ]
  K = SIZE (((ERR1 AND DM9EXCL) INSIDE ERR2) NOT M9_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M9_AND_DM9EXCL_L CHIP_AND_DM9EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M9.DN.3L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M9_AND_DM9EXCL_L)/AREA(CHIP_AND_DM9EXCL_L) ]
}
// M9.DN.3 is checked by M9.DN.3:H
// M9.DN.3e is checked by M9.DN.3:H
M9.DN.3:H { @ M9 area coverage must be < 80% range over 100umx100um step 50um (with DM9EXCL region)
  ERR1 = DENSITY M9_AND_DM9EXCL_H CHIP_AND_DM9EXCL_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_AND_DM9EXCL_H)/AREA(CHIP_AND_DM9EXCL_H) ]
  ERR2 = DENSITY M9_NOT_EXC_H CHIP_NOT_M9_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_NOT_EXC_H)/AREA(CHIP_NOT_M9_EXC_H) ]	
  K = SIZE (((ERR1 AND DM9EXCL) INSIDE ERR2) NOT M9_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M9_AND_DM9EXCL_H CHIP_AND_DM9EXCL_H > 0.8 WINDOW 100 STEP 50 BACKUP PRINT M9.DN.3H.density INSIDE OF LAYER CHIP [ !!AREA(K)*AREA(M9_AND_DM9EXCL_H)/AREA(CHIP_AND_DM9EXCL_H) ]
}
#ELSE
#IFDEF FULL_CHIP
// M9.DN.1 is checked by M9.DN.1__M9.DN.3:L
// M9.DN.3 is checked by M9.DN.1__M9.DN.3:L
// M9.DN.1b is checked by M9.DN.1__M9.DN.3:L
// M9.DN.3b is checked by M9.DN.1__M9.DN.3:L
M9.DN.1__M9.DN.3:L { @ M9 area coverage must be > 20% range over 50umx50um step 25um in whole chip 
  ERR_WIN = DENSITY M9_NOT_EXC_L CHIP_NOT_M9_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_NOT_EXC_L)/AREA(CHIP_NOT_M9_EXC_L) ]
  K = SIZE (ERR_WIN NOT M9_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M9_NOT_EXC_L CHIP_NOT_M9_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M9.DN.1L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M9_NOT_EXC_L)/AREA(CHIP_NOT_M9_EXC_L) ]
}
#ELSE
#IFDEF DENSITY_FOR_NONFULLCHIP
// M9.DN.1 is checked by M9.DN.1__M9.DN.3:L
// M9.DN.3 is checked by M9.DN.1__M9.DN.3:L
// M9.DN.1b is checked by M9.DN.1__M9.DN.3:L
// M9.DN.3b is checked by M9.DN.1__M9.DN.3:L
M9.DN.1__M9.DN.3:L { @ M9 area coverage must be > 20% range over 50umx50um step 25um in whole chip 
  ERR_WIN = DENSITY M9_NOT_EXC_L CHIP_NOT_M9_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_NOT_EXC_L)/AREA(CHIP_NOT_M9_EXC_L) ]
  K = SIZE (ERR_WIN NOT M9_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M9_NOT_EXC_L CHIP_NOT_M9_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M9.DN.1L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M9_NOT_EXC_L)/AREA(CHIP_NOT_M9_EXC_L) ]
}
#ELSE
// M9.DN.3 is checked by M9.DN.3:L
// M9.DN.3b is checked by M9.DN.1__M9.DN.3:L
M9.DN.3:L { @ M9 area coverage must be > 20% range over 50umx50um step 25um (with DM9EXCL region)
  ERR1 = DENSITY M9_AND_DM9EXCL_L CHIP_AND_DM9EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_AND_DM9EXCL_L)/AREA(CHIP_AND_DM9EXCL_L) ]
  ERR2 = DENSITY M9_NOT_EXC_L CHIP_NOT_M9_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_NOT_EXC_L)/AREA(CHIP_NOT_M9_EXC_L) ]
	
  K = SIZE (((ERR1 AND DM9EXCL) INSIDE ERR2) NOT M9_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K M9_AND_DM9EXCL_L CHIP_AND_DM9EXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT M9.DN.3L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(M9_AND_DM9EXCL_L)/AREA(CHIP_AND_DM9EXCL_L) ]
}
#ENDIF
#ENDIF
// M9.DN.1 is checked by M9.DN.1__M9.DN.3:H
// M9.DN.3 is checked by M9.DN.1__M9.DN.3:H
// M9.DN.1e is checked by M9.DN.1__M9.DN.3:H
// M9.DN.3e is checked by M9.DN.1__M9.DN.3:H
M9.DN.1__M9.DN.3:H { @ M9 area coverage must be < 80% range over 100umx100um step 50um 
  ERR_WIN = DENSITY M9_NOT_EXC_H CHIP_NOT_M9_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(M9_NOT_EXC_H)/AREA(CHIP_NOT_M9_EXC_H) ]
  K = SIZE (ERR_WIN NOT M9_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K M9_NOT_EXC_H CHIP_NOT_M9_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP PRINT M9.DN.1H.density INSIDE OF LAYER CHIP [ !!AREA(K)*AREA(M9_NOT_EXC_H)/AREA(CHIP_NOT_M9_EXC_H) ]
}
  #ENDIF
#ENDIF


#IFNDEF UTM


M9.DN.2 { @ M9 local density must be < 90% range over 20umx20um step 10um 
  ERR_WIN = DENSITY M9x_NOT_PAD CHIP > 0.9 WINDOW 20 STEP 10 BACKUP [ AREA(M9x_NOT_PAD)/AREA(CHIP) ]
  K = SIZE (ERR_WIN NOT MTOP_EXC) BY (5-0.002)/2 UNDEROVER TRUNCATE (5-0.002)/2	
  DENSITY K M9x_NOT_PAD CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT M9.DN.2.density [ !!AREA(K)*AREA(M9x_NOT_PAD)/AREA(CHIP) ]
}
#ENDIF


  // M9.R.1 can't be checked





VIA7.EN.1 { @ Min. extension of a M7 region beyond a VIA7 region ^VIA7_EN_1 um 
  ENC VIA7 M7 < VIA7_EN_1 ABUT <90 SINGULAR REGION
  (VIA7 NOT M7) NOT CBM
}
VIA8.EN.1 { @ Min. extension of a M8 region beyond a VIA8 region ^VIA8_EN_1 um 
  ENC VIA8 M8 < VIA8_EN_1 ABUT <90 SINGULAR REGION
  VIA8 NOT M8
}



//VIAD CHECKS
//===========

VIAD.W.1 { @ Width (square)(maximum = minimum) = ^VIAD_W_1 um
  A = NOT RECTANGLE VIAD == VIAD_W_1 BY == VIAD_W_1 ORTHOGONAL ONLY
  A NOT VIA_EXD
}
#IFDEF LmarkSealringCorner
VIAD.W.2 { @ Width of VIAn bar = ^VIAD_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring. 
  INT SR_VIAD < VIAD_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  A = SIZE SR_VIAD BY VIAD_W_2 /2 + GRID UNDEROVER TRUNCATE VIAD_W_2 /2 + GRID
  ENCLOSE RECTANGLE A 2 0.005
}
VIAD.S.1 { @ Space >= ^VIAD_S_1 um 
  EXT (VIAD NOT SR_VIAD) < VIAD_S_1 ABUT < 90 SINGULAR REGION
}
#ELSE
VIAD.W.2 { @ Width of VIAn bar = ^VIAD_W_2 um. VIAn bar is only allowed in seal ring and fuse protection ring.
  INT SR_VIAD < VIAD_W_2 ABUT < 90 OPPOSITE PARALLEL ONLY REGION 
  SIZE SR_VIAD BY VIAD_W_2 /2 + GRID UNDEROVER TRUNCATE VIAD_W_2 /2 + GRID
}
VIAD.S.1 { @ Space >= ^VIAD_S_1 um
  EXT VIAD < VIAD_S_1 ABUT < 90 SINGULAR REGION
}
#ENDIF
VIAD.S.2 { @ Space to 3-neighboring VIAn (<^VIAD_S_2_S um distance) >= ^VIAD_S_2 um
  X = WITH NEIGHBOR VIAD_EXD > 2 SPACE < VIAD_S_2_S
  EXT X VIAD < VIAD_S_2 ABUT < 90 SINGULAR REGION
}
VIAD.EN.1 { @ Enclosure by M9 >= ^VIAD_EN_1 um 
  ENC VIAD M9 < VIAD_EN_1 ABUT < 90 SINGULAR REGION
  VIAD NOT M9
}
VIAD.EN.2 { @ Enclosure by M9 [at least two opposite sides] >= ^VIAD_EN_2 um
  X = RECTANGLE ENCLOSURE VIAD M9 ABUT < 90 SINGULAR GOOD VIAD_EN_1 VIAD_EN_2 OPPOSITE VIAD_EN_1 VIAD_EN_2 OPPOSITE
  Y = ENC [X] M9 < VIAD_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIAD_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}


// VIAD.R.1 is checked by VIAD.W.1

MDWide_1.8_VIADT = (SIZE MD BY VIAD_R_2_W /2 UNDEROVER TRUNCATE VIAD_R_2_W /2) AND MD
M9Wide_1.8_VIADT = (SIZE M9 BY VIAD_R_2_W /2 UNDEROVER TRUNCATE VIAD_R_2_W /2) AND M9
MDWide_3_VIADT = (SIZE MDWide_1.8_VIADT BY VIAD_R_3_W /2 UNDEROVER TRUNCATE VIAD_R_3_W /2) AND MDWide_1.8_VIADT
M9Wide_3_VIADT = (SIZE M9Wide_1.8_VIADT BY VIAD_R_3_W /2 UNDEROVER TRUNCATE VIAD_R_3_W /2) AND M9Wide_1.8_VIADT
//VIAD.R.2.S80 is checked by VIAD.R.2
VIAD.R.2 { @ At least two VIAn with spacing <= ^VIAD_R_2_S are required to connect Mn and Mn+1 when one of these metals has a width and length > ^VIAD_R_2_W um.
   MDOvpM9W = (MD AND M9Wide_1.8_VIADT) OR (M9 AND MDWide_1.8_VIADT)
   Checked_VIAD = VIAD_EXD NOT OUTSIDE MDOvpM9W
   M9_effect = M9i INTERACT MDOvpM9W
   MD_effect = MDi INTERACT MDOvpM9W
   effect_MDOvpM9_ = M9_effect AND MD_effect
   effect_MDOvpM9 = effect_MDOvpM9_ INTERACT MDOvpM9W
   Effect_VIAD = VIAD_EXD INTERACT effect_MDOvpM9

   VIADMerged = SIZE Effect_VIAD BY VIAD_R_2_S /2 INSIDE OF effect_MDOvpM9 STEP M9_S_1*0.7
   VIADMerged2 = VIADMerged ENCLOSE Effect_VIAD >=2
   GVIA = Checked_VIAD INTERACT VIADMerged2
   GMDOvpM9W = MDOvpM9W INTERACT GVIA
   Checked_VIAD OUTSIDE GMDOvpM9W

}   

M9Big_3_VIADT = ENCLOSE RECTANGLE M9Wide_3_VIADT VIAD_R_3_W VIAD_R_3_L+GRID
// VIAD.R.3 is checked by VIAD.R.3:M9
// VIAD.R.3.S80 is checked by VIAD.R.3:M9
VIAD.R.3:M9 { @ At least two VIAn must be used for a connection that is <= ^VIAD_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIAD_R_3_L (L) and width > ^VIAD_R_3_W (W). (It is allowed to use one VIAn for a connection that is > ^VIAD_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIAD_R_3_L (L) and width > ^VIAD_R_3_W (W)). 
  Branch1 = ((SIZE M9Big_3_VIADT BY VIAD_R_3_D + GRID) NOT M9Big_3_VIADT) AND M9
  Branch1HasVia = (Branch1 INTERACT M9Big_3_VIADT) INTERACT VIAD
  Branch1Edge = M9Big_3_VIADT COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIAD_R_3_D INSIDE OF Branch1HasVia STEP M9_S_1*0.7
  GoodBranch = (Branch AND MD) INTERACT VIAD > 1
  BranchSingleVia = (VIAD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((MD INTERACT BranchSingleVia) AND M9) INTERACT BranchSingleVia) INTERACT VIAD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

MDBig_3_VIADT = ENCLOSE RECTANGLE MDWide_3_VIADT VIAD_R_3_W VIAD_R_3_L+GRID
// VIAD.R.3 is checked by VIAD.R.3:MD
VIAD.R.3:MD { @ At least two VIAn must be used for a connection that is <= ^VIAD_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIAD_R_3_L (L) and width > ^VIAD_R_3_W (W). (It is allowed to use one VIAn for a connection that is > ^VIAD_R_3_D (D) away from a metal plate (either Mn or Mn+1) with length > ^VIAD_R_3_L (L) and width > ^VIAD_R_3_W (W)).
  Branch1 = ((SIZE MDBig_3_VIADT BY VIAD_R_3_D + GRID) NOT MDBig_3_VIADT) AND MD
  Branch1HasVia = (Branch1 INTERACT MDBig_3_VIADT) INTERACT VIAD
  Branch1Edge = MDBig_3_VIADT COIN OUTSIDE EDGE Branch1HasVia
  Branch1Rec = EXPAND EDGE Branch1Edge OUTSIDE BY GRID
  Branch = SIZE Branch1Rec BY VIAD_R_3_D INSIDE OF Branch1HasVia STEP MD_S_1*0.7
  GoodBranch = (Branch AND M9) INTERACT VIAD > 1
  BranchSingleVia = (VIAD NOT OUTSIDE Branch) OUTSIDE GoodBranch
  Bad_Region = (((M9 INTERACT BranchSingleVia) AND MD) INTERACT BranchSingleVia) INTERACT VIAD == 1
  (BranchSingleVia INTERACT Bad_Region) NOT VIA_EXD

}

// VIAD.R.4 is checked by VIAD.EN.1
// VIAD.R.5 can not be checked.


//MD CHECKS
//=============

MDWide_1.5 = (SIZE MD BY MD_S_2_W /2 UNDEROVER TRUNCATE MD_S_2_W /2) AND MD
MDWide_4.5 = (SIZE MDWide_1.5 BY MD_S_3_W /2 UNDEROVER TRUNCATE MD_S_3_W /2) AND MDWide_1.5

MD1 = MDWide_1.5 NOT MD_HI_EXC
MD2 = MDWide_4.5 NOT MD_HI_EXC

VARIABLE MD_A_2pre ((MD_A_2 + (MD_S_1 * MD_S_1 * 3.142))/(2 * MD_S_1))*((MD_A_2 + (MD_S_1 * MD_S_1 * 3.142))/(2 * MD_S_1))/3.141
MDHO = HOLES MD INNER < MD_A_2pre 

MDHOC = MDHO NOT MD

MDnAS2 = AREA MD > MD_S_2_L*MD_W_1  // filter small metal for MD.S.2
MDnAS3 = AREA MDnAS2 > MD_S_3_L*MD_W_1  // filter small metal for MD.S.3





MD.W.1 { @ Width >= ^MD_W_1 um 
  INT MD < MD_W_1 ABUT < 90 SINGULAR REGION
}
MD.W.2 { @ Max. width [except bond pad] <= ^MD_W_2 um 
  SIZE MD_MAX_WIDTH BY MD_W_2 /2 UNDEROVER TRUNCATE MD_W_2 /2
}
MD.S.1 { @ Space >= ^MD_S_1 um 
  EXT MD < MD_S_1 ABUT < 90 SINGULAR REGION
}
// MD.S.2.S80 is checked by MD.S.2
MD.S.2 { @ Space [at least one metal line width > ^MD_S_2_W um (W1) and
             @ the parallel metal run length > ^MD_S_2_L um (L1)] >= ^MD_S_2 um
  X = EXT MD1 MDnAS2 < MD_S_2 OPPOSITE REGION MEASURE ALL
  Y = X NOT MD
  ENCLOSE RECTANGLE Y GRID MD_S_2_L+GRID
}
MD.S.3 { @ Space [at least one metal line width > ^MD_S_3_W um (W2) and
             @ the parallel metal run length > ^MD_S_3_L um (L2)] >= ^MD_S_3 um
  X = EXT MD2 MDnAS3 < MD_S_3 OPPOSITE REGION MEASURE ALL
  Y = X NOT MD
  ENCLOSE RECTANGLE Y GRID MD_S_3_L+GRID
}
MD.EN.1 { @ Enclosure of VIAD >= ^MD_EN_1 um 
  ENC VIAD MD < MD_EN_1 ABUT < 90 SINGULAR REGION
  VIAD NOT MD
}
MD.EN.2 { @ Enclosure of VIAD [at least two opposite sides] >= ^MD_EN_2 um 
  X = RECTANGLE ENCLOSURE VIAD MD ABUT < 90 SINGULAR GOOD MD_EN_1 MD_EN_2 OPPOSITE MD_EN_1 MD_EN_2 OPPOSITE
  Y = ENC [X] MD < MD_EN_2 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < VIAD_W_1 ABUT == 90 INTERSECTING ONLY REGION   // adjacent narrow sides
}
MD.A.1 { @ Area >= ^MD_A_1 um2
  AREA MD < MD_A_1
}
MD.A.2 { @ Enclosed area >= ^MD_A_2 um
  AREA MDHOC < MD_A_2
}


CHIP_NOT_MD_EXC_H = (CHIP INTERACT MDx) NOT MD_EXC_H  // For high density limit
CHIP_NOT_MD_EXC_L = (CHIP INTERACT MDx) NOT MD_EXC_L1 // For low density limit
MD_NOT_EXC_H = MDx NOT MD_EXC_H
MD_NOT_EXC_L = MDx NOT MD_EXC_L1

// For density check in DMxEXCL
CHIP_AND_DMDEXCL_L = CHIP_NOT_MD_EXC_L AND DMDEXCL  // low density check include CB
MD_AND_DMDEXCL_L = MD_NOT_EXC_L AND DMDEXCL     // low density check include CB
CHIP_AND_DMDEXCL_H = CHIP_NOT_MD_EXC_H AND DMDEXCL  // high density check exclude CB
MD_AND_DMDEXCL_H = MD_NOT_EXC_H AND DMDEXCL     // high density check exclude CB

MDx_NOT_PAD = ( MDx NOT MD_HI_EXC ) NOT LMARK

  #IFDEF DENSITY_IN_BLOCKAGE
// MD.DN.3 is checked by MD.DN.3:L
// MD.DN.3b is checked by MD.DN.3:L
MD.DN.3:L { @ MD area coverage must be > 20% range over 50umx50um step 25um (with DMDEXCL region)
  ERR1 = DENSITY MD_AND_DMDEXCL_L CHIP_AND_DMDEXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_AND_DMDEXCL_L)/AREA(CHIP_AND_DMDEXCL_L) ]
  ERR2 = DENSITY MD_NOT_EXC_L CHIP_NOT_MD_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_NOT_EXC_L)/AREA(CHIP_NOT_MD_EXC_L) ]
  K = SIZE (((ERR1 AND DMDEXCL) INSIDE ERR2) NOT MD_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K MD_AND_DMDEXCL_L CHIP_AND_DMDEXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT MD.DN.3L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(MD_AND_DMDEXCL_L)/AREA(CHIP_AND_DMDEXCL_L) ]
}
// MD.DN.3 is checked by MD.DN.3:H
// MD.DN.3e is checked by MD.DN.3:H
MD.DN.3:H { @ MD area coverage must be < 80% range over 100umx100um step 50um (with DMDEXCL region)
  ERR1 = DENSITY MD_AND_DMDEXCL_H CHIP_AND_DMDEXCL_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_AND_DMDEXCL_H)/AREA(CHIP_AND_DMDEXCL_H) ]
  ERR2 = DENSITY MD_NOT_EXC_H CHIP_NOT_MD_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_NOT_EXC_H)/AREA(CHIP_NOT_MD_EXC_H) ]	
  K = SIZE (((ERR1 AND DMDEXCL) INSIDE ERR2) NOT MD_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K MD_AND_DMDEXCL_H CHIP_AND_DMDEXCL_H > 0.8 WINDOW 100 STEP 50 BACKUP PRINT MD.DN.3H.density INSIDE OF LAYER CHIP [ !!AREA(K)*AREA(MD_AND_DMDEXCL_H)/AREA(CHIP_AND_DMDEXCL_H) ]
}
#ELSE
#IFDEF FULL_CHIP
// MD.DN.1 is checked by MD.DN.1__MD.DN.3:L
// MD.DN.3 is checked by MD.DN.1__MD.DN.3:L
// MD.DN.1b is checked by MD.DN.1__MD.DN.3:L
// MD.DN.3b is checked by MD.DN.1__MD.DN.3:L
MD.DN.1__MD.DN.3:L { @ MD area coverage must be > 20% range over 50umx50um step 25um in whole chip 
  ERR_WIN = DENSITY MD_NOT_EXC_L CHIP_NOT_MD_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_NOT_EXC_L)/AREA(CHIP_NOT_MD_EXC_L) ]
  K = SIZE (ERR_WIN NOT MD_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K MD_NOT_EXC_L CHIP_NOT_MD_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT MD.DN.1L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(MD_NOT_EXC_L)/AREA(CHIP_NOT_MD_EXC_L) ]
}
#ELSE
#IFDEF DENSITY_FOR_NONFULLCHIP
// MD.DN.1 is checked by MD.DN.1__MD.DN.3:L
// MD.DN.3 is checked by MD.DN.1__MD.DN.3:L
// MD.DN.1b is checked by MD.DN.1__MD.DN.3:L
// MD.DN.3b is checked by MD.DN.1__MD.DN.3:L
MD.DN.1__MD.DN.3:L { @ MD area coverage must be > 20% range over 50umx50um step 25um in whole chip 
  ERR_WIN = DENSITY MD_NOT_EXC_L CHIP_NOT_MD_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_NOT_EXC_L)/AREA(CHIP_NOT_MD_EXC_L) ]
  K = SIZE (ERR_WIN NOT MD_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K MD_NOT_EXC_L CHIP_NOT_MD_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT MD.DN.1L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(MD_NOT_EXC_L)/AREA(CHIP_NOT_MD_EXC_L) ]
}
#ELSE
// MD.DN.3 is checked by MD.DN.3:L
// MD.DN.3b is checked by MD.DN.1__MD.DN.3:L
MD.DN.3:L { @ MD area coverage must be > 20% range over 50umx50um step 25um (with DMDEXCL region)
  ERR1 = DENSITY MD_AND_DMDEXCL_L CHIP_AND_DMDEXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_AND_DMDEXCL_L)/AREA(CHIP_AND_DMDEXCL_L) ]
  ERR2 = DENSITY MD_NOT_EXC_L CHIP_NOT_MD_EXC_L < 0.2 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_NOT_EXC_L)/AREA(CHIP_NOT_MD_EXC_L) ]
	
  K = SIZE (((ERR1 AND DMDEXCL) INSIDE ERR2) NOT MD_EXC_L2) BY (12.5-0.002)/2 UNDEROVER TRUNCATE (12.5-0.002)/2
  DENSITY K MD_AND_DMDEXCL_L CHIP_AND_DMDEXCL_L < 0.2 WINDOW 50 STEP 25 BACKUP PRINT MD.DN.3L.density INSIDE OF LAYER CHIP [ !AREA(K) + AREA(MD_AND_DMDEXCL_L)/AREA(CHIP_AND_DMDEXCL_L) ]
}
#ENDIF
#ENDIF
// MD.DN.1 is checked by MD.DN.1__MD.DN.3:H
// MD.DN.3 is checked by MD.DN.1__MD.DN.3:H
// MD.DN.1e is checked by MD.DN.1__MD.DN.3:H
// MD.DN.3e is checked by MD.DN.1__MD.DN.3:H
MD.DN.1__MD.DN.3:H { @ MD area coverage must be < 80% range over 100umx100um step 50um 
  ERR_WIN = DENSITY MD_NOT_EXC_H CHIP_NOT_MD_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP INSIDE OF LAYER CHIP [ AREA(MD_NOT_EXC_H)/AREA(CHIP_NOT_MD_EXC_H) ]
  K = SIZE (ERR_WIN NOT MD_EXC_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
  DENSITY K MD_NOT_EXC_H CHIP_NOT_MD_EXC_H > 0.8 WINDOW 100 STEP 50 BACKUP PRINT MD.DN.1H.density INSIDE OF LAYER CHIP [ !!AREA(K)*AREA(MD_NOT_EXC_H)/AREA(CHIP_NOT_MD_EXC_H) ]
}
  #ENDIF
MD.DN.2 { @ MD local density must be < 90% range over 20umx20um step 10um 
  ERR_WIN = DENSITY MDx_NOT_PAD CHIP > 0.9 WINDOW 20 STEP 10 BACKUP [ AREA(MDx_NOT_PAD)/AREA(CHIP) ]
  K = SIZE (ERR_WIN NOT MD_HI_EXC) BY (5-0.002)/2 UNDEROVER TRUNCATE (5-0.002)/2	
  DENSITY K MDx_NOT_PAD CHIP > 0.9 WINDOW 20 STEP 10 BACKUP PRINT MD.DN.2.density [ !!AREA(K)*AREA(MDx_NOT_PAD)/AREA(CHIP) ]
}
  // MD.R.1 can't be checked





CHIP_MOM_WIVIA = COPY CHIP
CHIP_MOM_WOVIA = COPY CHIP
CONNECT CHIP_MOM_WIVIA
CONNECT CHIP_MOM_WOVIA
MOM_VIA1 = VIA1 AND (( MOMDMY_1 AND MOMDMY_2) ENCLOSE VIA1 > 4) 
MOM_VIA1_C = STAMP MOM_VIA1 BY CHIP_MOM_WIVIA
MOM_VIA2 = VIA2 AND (( MOMDMY_2 AND MOMDMY_3) ENCLOSE VIA2 > 4) 
MOM_VIA2_C = STAMP MOM_VIA2 BY CHIP_MOM_WIVIA
MOM_VIA3 = VIA3 AND (( MOMDMY_3 AND MOMDMY_4) ENCLOSE VIA3 > 4) 
MOM_VIA3_C = STAMP MOM_VIA3 BY CHIP_MOM_WIVIA
MOM_VIA4 = VIA4 AND (( MOMDMY_4 AND MOMDMY_5) ENCLOSE VIA4 > 4) 
MOM_VIA4_C = STAMP MOM_VIA4 BY CHIP_MOM_WIVIA
MOM_VIA5 = VIA5 AND (( MOMDMY_5 AND MOMDMY_6) ENCLOSE VIA5 > 4) 
MOM_VIA5_C = STAMP MOM_VIA5 BY CHIP_MOM_WIVIA
MOM_VIA6 = VIA6 AND (( MOMDMY_6 AND MOMDMY_7) ENCLOSE VIA6 > 4) 
MOM_VIA6_C = STAMP MOM_VIA6 BY CHIP_MOM_WIVIA
MOM_VIA7 = VIA7 AND (( MOMDMY_7 AND MOMDMY_8) ENCLOSE VIA7 > 4) 
MOM_VIA7_C = STAMP MOM_VIA7 BY CHIP_MOM_WIVIA
MOM_VIA8 = VIA8 AND (( MOMDMY_8 AND MOMDMY_9) ENCLOSE VIA8 > 4) 
MOM_VIA8_C = STAMP MOM_VIA8 BY CHIP_MOM_WIVIA
MOM_RV =  RV AND (( MOMDMY_9 AND MOMDMY_AP) ENCLOSE RV > 4) 
MOM_RV_C = STAMP MOM_RV BY CHIP_MOM_WIVIA
MOMDMY_1_WIVIA = MOMDMY_1 ENCLOSE MOM_VIA1
MOMDMY_1_WOVIA = MOMDMY_1 NOT MOMDMY_1_WIVIA 
MOM_M1_WIVIA = MOMDMY_1_WIVIA AND M1
MOM_M1_WOVIA = MOMDMY_1_WOVIA AND M1
MOM_M1 = MOM_M1_WIVIA OR MOM_M1_WOVIA 
MOM_M1_EDGE = M1 COIN INSIDE EDGE MOM_M1
MOM_M1_LINE_END = CONVEX EDGE MOM_M1_EDGE ANGLE1==90 ANGLE2==90
MOM_M1_SIDE_EDGE = MOM_M1_EDGE NOT COIN INSIDE EDGE MOM_M1_LINE_END
MOM_M1_CAP_EDGE_b1 = ENC MOM_M1_LINE_END MOMDMY_1 <= 4 OPPOSITE REGION
MOM_M1_CAP_EDGE_b2 = MOM_M1 NOT COIN EDGE MOM_M1_EDGE
MOM_M1_CAP_EDGE_b3 = (MOMDMY_1 TOUCH EDGE MOM_M1_CAP_EDGE_b2) NOT COIN EDGE MOM_M1_CAP_EDGE_b2
MOM_M1_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M1_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M1_CAP_EDGE_b1)   
MOM_M1_CAP_EDGE_b5 = (MOMDMY_1 NOT (MOM_M1_CAP_EDGE_b1 OR MOM_M1)) INTERACT MOM_M1 == 1
MOM_M1_CAP_EDGE    = ((MOM_M1_SIDE_EDGE  NOT COIN EDGE MOMDMY_1) NOT COIN EDGE MOM_M1_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M1_CAP_EDGE_b4 
MOM_M1_CAP_EDGE_EXP = EXPAND EDGE MOM_M1_CAP_EDGE INSIDE BY 0.001
MOM_M1_CAP_EDGE_EXP_WIVIA = MOM_M1_CAP_EDGE_EXP AND MOM_M1_WIVIA
MOM_M1_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M1_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M1_CAP_EDGE_EXP_WOVIA = MOM_M1_CAP_EDGE_EXP AND MOM_M1_WOVIA
MOM_M1_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M1_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_2_WIVIA = (MOMDMY_2 ENCLOSE MOM_VIA1) OR (MOMDMY_2 ENCLOSE MOM_VIA2)
MOMDMY_2_WOVIA = MOMDMY_2 NOT MOMDMY_2_WIVIA 
MOM_M2_WIVIA = MOMDMY_2_WIVIA AND M2
MOM_M2_WOVIA = MOMDMY_2_WOVIA AND M2
MOM_M2 = MOM_M2_WIVIA OR MOM_M2_WOVIA 
MOM_M2_EDGE = M2 COIN INSIDE EDGE MOM_M2
MOM_M2_LINE_END = CONVEX EDGE MOM_M2_EDGE ANGLE1==90 ANGLE2==90
MOM_M2_SIDE_EDGE = MOM_M2_EDGE NOT COIN INSIDE EDGE MOM_M2_LINE_END
MOM_M2_CAP_EDGE_b1 = ENC MOM_M2_LINE_END MOMDMY_2 <= 4 OPPOSITE REGION
MOM_M2_CAP_EDGE_b2 = MOM_M2 NOT COIN EDGE MOM_M2_EDGE
MOM_M2_CAP_EDGE_b3 = (MOMDMY_2 TOUCH EDGE MOM_M2_CAP_EDGE_b2) NOT COIN EDGE MOM_M2_CAP_EDGE_b2
MOM_M2_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M2_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M2_CAP_EDGE_b1)   
MOM_M2_CAP_EDGE_b5 = (MOMDMY_2 NOT (MOM_M2_CAP_EDGE_b1 OR MOM_M2)) INTERACT MOM_M2 == 1
MOM_M2_CAP_EDGE    = ((MOM_M2_SIDE_EDGE  NOT COIN EDGE MOMDMY_2) NOT COIN EDGE MOM_M2_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M2_CAP_EDGE_b4 
MOM_M2_CAP_EDGE_EXP = EXPAND EDGE MOM_M2_CAP_EDGE INSIDE BY 0.001
MOM_M2_CAP_EDGE_EXP_WIVIA = MOM_M2_CAP_EDGE_EXP AND MOM_M2_WIVIA
MOM_M2_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M2_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M2_CAP_EDGE_EXP_WOVIA = MOM_M2_CAP_EDGE_EXP AND MOM_M2_WOVIA
MOM_M2_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M2_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_3_WIVIA = (MOMDMY_3 ENCLOSE MOM_VIA2) OR (MOMDMY_3 ENCLOSE MOM_VIA3)
MOMDMY_3_WOVIA = MOMDMY_3 NOT MOMDMY_3_WIVIA 
MOM_M3_WIVIA = MOMDMY_3_WIVIA AND M3
MOM_M3_WOVIA = MOMDMY_3_WOVIA AND M3
MOM_M3 = MOM_M3_WIVIA OR MOM_M3_WOVIA 
MOM_M3_EDGE = M3 COIN INSIDE EDGE MOM_M3
MOM_M3_LINE_END = CONVEX EDGE MOM_M3_EDGE ANGLE1==90 ANGLE2==90
MOM_M3_SIDE_EDGE = MOM_M3_EDGE NOT COIN INSIDE EDGE MOM_M3_LINE_END
MOM_M3_CAP_EDGE_b1 = ENC MOM_M3_LINE_END MOMDMY_3 <= 4 OPPOSITE REGION
MOM_M3_CAP_EDGE_b2 = MOM_M3 NOT COIN EDGE MOM_M3_EDGE
MOM_M3_CAP_EDGE_b3 = (MOMDMY_3 TOUCH EDGE MOM_M3_CAP_EDGE_b2) NOT COIN EDGE MOM_M3_CAP_EDGE_b2
MOM_M3_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M3_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M3_CAP_EDGE_b1)   
MOM_M3_CAP_EDGE_b5 = (MOMDMY_3 NOT (MOM_M3_CAP_EDGE_b1 OR MOM_M3)) INTERACT MOM_M3 == 1
MOM_M3_CAP_EDGE    = ((MOM_M3_SIDE_EDGE  NOT COIN EDGE MOMDMY_3) NOT COIN EDGE MOM_M3_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M3_CAP_EDGE_b4 
MOM_M3_CAP_EDGE_EXP = EXPAND EDGE MOM_M3_CAP_EDGE INSIDE BY 0.001
MOM_M3_CAP_EDGE_EXP_WIVIA = MOM_M3_CAP_EDGE_EXP AND MOM_M3_WIVIA
MOM_M3_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M3_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M3_CAP_EDGE_EXP_WOVIA = MOM_M3_CAP_EDGE_EXP AND MOM_M3_WOVIA
MOM_M3_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M3_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_4_WIVIA = (MOMDMY_4 ENCLOSE MOM_VIA3) OR (MOMDMY_4 ENCLOSE MOM_VIA4)
MOMDMY_4_WOVIA = MOMDMY_4 NOT MOMDMY_4_WIVIA 
MOM_M4_WIVIA = MOMDMY_4_WIVIA AND M4
MOM_M4_WOVIA = MOMDMY_4_WOVIA AND M4
MOM_M4 = MOM_M4_WIVIA OR MOM_M4_WOVIA 
MOM_M4_EDGE = M4 COIN INSIDE EDGE MOM_M4
MOM_M4_LINE_END = CONVEX EDGE MOM_M4_EDGE ANGLE1==90 ANGLE2==90
MOM_M4_SIDE_EDGE = MOM_M4_EDGE NOT COIN INSIDE EDGE MOM_M4_LINE_END
MOM_M4_CAP_EDGE_b1 = ENC MOM_M4_LINE_END MOMDMY_4 <= 4 OPPOSITE REGION
MOM_M4_CAP_EDGE_b2 = MOM_M4 NOT COIN EDGE MOM_M4_EDGE
MOM_M4_CAP_EDGE_b3 = (MOMDMY_4 TOUCH EDGE MOM_M4_CAP_EDGE_b2) NOT COIN EDGE MOM_M4_CAP_EDGE_b2
MOM_M4_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M4_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M4_CAP_EDGE_b1)   
MOM_M4_CAP_EDGE_b5 = (MOMDMY_4 NOT (MOM_M4_CAP_EDGE_b1 OR MOM_M4)) INTERACT MOM_M4 == 1
MOM_M4_CAP_EDGE    = ((MOM_M4_SIDE_EDGE  NOT COIN EDGE MOMDMY_4) NOT COIN EDGE MOM_M4_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M4_CAP_EDGE_b4 
MOM_M4_CAP_EDGE_EXP = EXPAND EDGE MOM_M4_CAP_EDGE INSIDE BY 0.001
MOM_M4_CAP_EDGE_EXP_WIVIA = MOM_M4_CAP_EDGE_EXP AND MOM_M4_WIVIA
MOM_M4_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M4_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M4_CAP_EDGE_EXP_WOVIA = MOM_M4_CAP_EDGE_EXP AND MOM_M4_WOVIA
MOM_M4_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M4_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_5_WIVIA = (MOMDMY_5 ENCLOSE MOM_VIA4) OR (MOMDMY_5 ENCLOSE MOM_VIA5)
MOMDMY_5_WOVIA = MOMDMY_5 NOT MOMDMY_5_WIVIA 
MOM_M5_WIVIA = MOMDMY_5_WIVIA AND M5
MOM_M5_WOVIA = MOMDMY_5_WOVIA AND M5
MOM_M5 = MOM_M5_WIVIA OR MOM_M5_WOVIA 
MOM_M5_EDGE = M5 COIN INSIDE EDGE MOM_M5
MOM_M5_LINE_END = CONVEX EDGE MOM_M5_EDGE ANGLE1==90 ANGLE2==90
MOM_M5_SIDE_EDGE = MOM_M5_EDGE NOT COIN INSIDE EDGE MOM_M5_LINE_END
MOM_M5_CAP_EDGE_b1 = ENC MOM_M5_LINE_END MOMDMY_5 <= 4 OPPOSITE REGION
MOM_M5_CAP_EDGE_b2 = MOM_M5 NOT COIN EDGE MOM_M5_EDGE
MOM_M5_CAP_EDGE_b3 = (MOMDMY_5 TOUCH EDGE MOM_M5_CAP_EDGE_b2) NOT COIN EDGE MOM_M5_CAP_EDGE_b2
MOM_M5_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M5_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M5_CAP_EDGE_b1)   
MOM_M5_CAP_EDGE_b5 = (MOMDMY_5 NOT (MOM_M5_CAP_EDGE_b1 OR MOM_M5)) INTERACT MOM_M5 == 1
MOM_M5_CAP_EDGE    = ((MOM_M5_SIDE_EDGE  NOT COIN EDGE MOMDMY_5) NOT COIN EDGE MOM_M5_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M5_CAP_EDGE_b4 
MOM_M5_CAP_EDGE_EXP = EXPAND EDGE MOM_M5_CAP_EDGE INSIDE BY 0.001
MOM_M5_CAP_EDGE_EXP_WIVIA = MOM_M5_CAP_EDGE_EXP AND MOM_M5_WIVIA
MOM_M5_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M5_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M5_CAP_EDGE_EXP_WOVIA = MOM_M5_CAP_EDGE_EXP AND MOM_M5_WOVIA
MOM_M5_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M5_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_6_WIVIA = (MOMDMY_6 ENCLOSE MOM_VIA5) OR (MOMDMY_6 ENCLOSE MOM_VIA6)
MOMDMY_6_WOVIA = MOMDMY_6 NOT MOMDMY_6_WIVIA 
MOM_M6_WIVIA = MOMDMY_6_WIVIA AND M6
MOM_M6_WOVIA = MOMDMY_6_WOVIA AND M6
MOM_M6 = MOM_M6_WIVIA OR MOM_M6_WOVIA 
MOM_M6_EDGE = M6 COIN INSIDE EDGE MOM_M6
MOM_M6_LINE_END = CONVEX EDGE MOM_M6_EDGE ANGLE1==90 ANGLE2==90
MOM_M6_SIDE_EDGE = MOM_M6_EDGE NOT COIN INSIDE EDGE MOM_M6_LINE_END
MOM_M6_CAP_EDGE_b1 = ENC MOM_M6_LINE_END MOMDMY_6 <= 4 OPPOSITE REGION
MOM_M6_CAP_EDGE_b2 = MOM_M6 NOT COIN EDGE MOM_M6_EDGE
MOM_M6_CAP_EDGE_b3 = (MOMDMY_6 TOUCH EDGE MOM_M6_CAP_EDGE_b2) NOT COIN EDGE MOM_M6_CAP_EDGE_b2
MOM_M6_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M6_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M6_CAP_EDGE_b1)   
MOM_M6_CAP_EDGE_b5 = (MOMDMY_6 NOT (MOM_M6_CAP_EDGE_b1 OR MOM_M6)) INTERACT MOM_M6 == 1
MOM_M6_CAP_EDGE    = ((MOM_M6_SIDE_EDGE  NOT COIN EDGE MOMDMY_6) NOT COIN EDGE MOM_M6_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M6_CAP_EDGE_b4 
MOM_M6_CAP_EDGE_EXP = EXPAND EDGE MOM_M6_CAP_EDGE INSIDE BY 0.001
MOM_M6_CAP_EDGE_EXP_WIVIA = MOM_M6_CAP_EDGE_EXP AND MOM_M6_WIVIA
MOM_M6_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M6_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M6_CAP_EDGE_EXP_WOVIA = MOM_M6_CAP_EDGE_EXP AND MOM_M6_WOVIA
MOM_M6_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M6_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_7_WIVIA = (MOMDMY_7 ENCLOSE MOM_VIA6) OR (MOMDMY_7 ENCLOSE MOM_VIA7)
MOMDMY_7_WOVIA = MOMDMY_7 NOT MOMDMY_7_WIVIA 
MOM_M7_WIVIA = MOMDMY_7_WIVIA AND M7
MOM_M7_WOVIA = MOMDMY_7_WOVIA AND M7
MOM_M7 = MOM_M7_WIVIA OR MOM_M7_WOVIA 
MOM_M7_EDGE = M7 COIN INSIDE EDGE MOM_M7
MOM_M7_LINE_END = CONVEX EDGE MOM_M7_EDGE ANGLE1==90 ANGLE2==90
MOM_M7_SIDE_EDGE = MOM_M7_EDGE NOT COIN INSIDE EDGE MOM_M7_LINE_END
MOM_M7_CAP_EDGE_b1 = ENC MOM_M7_LINE_END MOMDMY_7 <= 4 OPPOSITE REGION
MOM_M7_CAP_EDGE_b2 = MOM_M7 NOT COIN EDGE MOM_M7_EDGE
MOM_M7_CAP_EDGE_b3 = (MOMDMY_7 TOUCH EDGE MOM_M7_CAP_EDGE_b2) NOT COIN EDGE MOM_M7_CAP_EDGE_b2
MOM_M7_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M7_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M7_CAP_EDGE_b1)   
MOM_M7_CAP_EDGE_b5 = (MOMDMY_7 NOT (MOM_M7_CAP_EDGE_b1 OR MOM_M7)) INTERACT MOM_M7 == 1
MOM_M7_CAP_EDGE    = ((MOM_M7_SIDE_EDGE  NOT COIN EDGE MOMDMY_7) NOT COIN EDGE MOM_M7_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M7_CAP_EDGE_b4 
MOM_M7_CAP_EDGE_EXP = EXPAND EDGE MOM_M7_CAP_EDGE INSIDE BY 0.001
MOM_M7_CAP_EDGE_EXP_WIVIA = MOM_M7_CAP_EDGE_EXP AND MOM_M7_WIVIA
MOM_M7_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M7_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M7_CAP_EDGE_EXP_WOVIA = MOM_M7_CAP_EDGE_EXP AND MOM_M7_WOVIA
MOM_M7_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M7_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_8_WIVIA = (MOMDMY_8 ENCLOSE MOM_VIA7) OR (MOMDMY_8 ENCLOSE MOM_VIA8)
MOMDMY_8_WOVIA = MOMDMY_8 NOT MOMDMY_8_WIVIA 
MOM_M8_WIVIA = MOMDMY_8_WIVIA AND M8
MOM_M8_WOVIA = MOMDMY_8_WOVIA AND M8
MOM_M8 = MOM_M8_WIVIA OR MOM_M8_WOVIA 
MOM_M8_EDGE = M8 COIN INSIDE EDGE MOM_M8
MOM_M8_LINE_END = CONVEX EDGE MOM_M8_EDGE ANGLE1==90 ANGLE2==90
MOM_M8_SIDE_EDGE = MOM_M8_EDGE NOT COIN INSIDE EDGE MOM_M8_LINE_END
MOM_M8_CAP_EDGE_b1 = ENC MOM_M8_LINE_END MOMDMY_8 <= 4 OPPOSITE REGION
MOM_M8_CAP_EDGE_b2 = MOM_M8 NOT COIN EDGE MOM_M8_EDGE
MOM_M8_CAP_EDGE_b3 = (MOMDMY_8 TOUCH EDGE MOM_M8_CAP_EDGE_b2) NOT COIN EDGE MOM_M8_CAP_EDGE_b2
MOM_M8_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M8_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M8_CAP_EDGE_b1)   
MOM_M8_CAP_EDGE_b5 = (MOMDMY_8 NOT (MOM_M8_CAP_EDGE_b1 OR MOM_M8)) INTERACT MOM_M8 == 1
MOM_M8_CAP_EDGE    = ((MOM_M8_SIDE_EDGE  NOT COIN EDGE MOMDMY_8) NOT COIN EDGE MOM_M8_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M8_CAP_EDGE_b4 
MOM_M8_CAP_EDGE_EXP = EXPAND EDGE MOM_M8_CAP_EDGE INSIDE BY 0.001
MOM_M8_CAP_EDGE_EXP_WIVIA = MOM_M8_CAP_EDGE_EXP AND MOM_M8_WIVIA
MOM_M8_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M8_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M8_CAP_EDGE_EXP_WOVIA = MOM_M8_CAP_EDGE_EXP AND MOM_M8_WOVIA
MOM_M8_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M8_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_9_WIVIA = (MOMDMY_9 ENCLOSE MOM_VIA8) OR (MOMDMY_9 ENCLOSE MOM_RV)
MOMDMY_9_WOVIA = MOMDMY_9 NOT MOMDMY_9_WIVIA 
MOM_M9_WIVIA = MOMDMY_9_WIVIA AND M9
MOM_M9_WOVIA = MOMDMY_9_WOVIA AND M9
MOM_M9 = MOM_M9_WIVIA OR MOM_M9_WOVIA 
MOM_M9_EDGE = M9 COIN INSIDE EDGE MOM_M9
MOM_M9_LINE_END = CONVEX EDGE MOM_M9_EDGE ANGLE1==90 ANGLE2==90
MOM_M9_SIDE_EDGE = MOM_M9_EDGE NOT COIN INSIDE EDGE MOM_M9_LINE_END
MOM_M9_CAP_EDGE_b1 = ENC MOM_M9_LINE_END MOMDMY_9 <= 4 OPPOSITE REGION
MOM_M9_CAP_EDGE_b2 = MOM_M9 NOT COIN EDGE MOM_M9_EDGE
MOM_M9_CAP_EDGE_b3 = (MOMDMY_9 TOUCH EDGE MOM_M9_CAP_EDGE_b2) NOT COIN EDGE MOM_M9_CAP_EDGE_b2
MOM_M9_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_M9_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_M9_CAP_EDGE_b1)   
MOM_M9_CAP_EDGE_b5 = (MOMDMY_9 NOT (MOM_M9_CAP_EDGE_b1 OR MOM_M9)) INTERACT MOM_M9 == 1
MOM_M9_CAP_EDGE    = ((MOM_M9_SIDE_EDGE  NOT COIN EDGE MOMDMY_9) NOT COIN EDGE MOM_M9_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_M9_CAP_EDGE_b4 
MOM_M9_CAP_EDGE_EXP = EXPAND EDGE MOM_M9_CAP_EDGE INSIDE BY 0.001
MOM_M9_CAP_EDGE_EXP_WIVIA = MOM_M9_CAP_EDGE_EXP AND MOM_M9_WIVIA
MOM_M9_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_M9_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_M9_CAP_EDGE_EXP_WOVIA = MOM_M9_CAP_EDGE_EXP AND MOM_M9_WOVIA
MOM_M9_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_M9_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA
MOMDMY_AP_WIVIA = MOMDMY_AP ENCLOSE MOM_RV
MOMDMY_AP_WOVIA = MOMDMY_AP NOT MOMDMY_AP_WIVIA
MOM_AP_WIVIA = MOMDMY_AP_WIVIA AND AP
MOM_AP_WOVIA = MOMDMY_AP_WOVIA AND AP
MOM_AP = MOM_AP_WIVIA OR MOM_AP_WOVIA
MOM_AP_EDGE = AP COIN INSIDE EDGE MOM_AP
MOM_AP_LINE_END = CONVEX EDGE MOM_AP_EDGE ANGLE1==90 ANGLE2==90

MOM_AP_SIDE_EDGE = MOM_AP_EDGE NOT COIN INSIDE EDGE MOM_AP_LINE_END
MOM_AP_CAP_EDGE_b1 = ENC MOM_AP_LINE_END MOMDMY_AP <= 4 OPPOSITE REGION
MOM_AP_CAP_EDGE_b2 = MOM_AP NOT COIN EDGE MOM_AP_EDGE
MOM_AP_CAP_EDGE_b3 = (MOMDMY_AP TOUCH EDGE MOM_AP_CAP_EDGE_b2) NOT COIN EDGE MOM_AP_CAP_EDGE_b2
MOM_AP_CAP_EDGE_b4 = EXTENTS ((EXPAND EDGE MOM_AP_CAP_EDGE_b3 OUTSIDE BY GRID) OR MOM_AP_CAP_EDGE_b1)   
MOM_AP_CAP_EDGE_b5 = (MOMDMY_AP NOT (MOM_AP_CAP_EDGE_b1 OR MOM_AP)) INTERACT MOM_AP == 1
MOM_AP_CAP_EDGE    = ((MOM_AP_SIDE_EDGE  NOT COIN EDGE MOMDMY_AP) NOT COIN EDGE MOM_AP_CAP_EDGE_b5) NOT COIN OUTSIDE EDGE MOM_AP_CAP_EDGE_b4 
MOM_AP_CAP_EDGE_EXP = EXPAND EDGE MOM_AP_CAP_EDGE INSIDE BY 0.001
MOM_AP_CAP_EDGE_EXP_WIVIA = MOM_AP_CAP_EDGE_EXP AND MOM_AP_WIVIA
MOM_AP_CAP_EDGE_EXP_WIVIA_C = STAMP MOM_AP_CAP_EDGE_EXP_WIVIA BY CHIP_MOM_WIVIA
MOM_AP_CAP_EDGE_EXP_WOVIA = MOM_AP_CAP_EDGE_EXP AND MOM_AP_WOVIA
MOM_AP_CAP_EDGE_EXP_WOVIA_C = STAMP MOM_AP_CAP_EDGE_EXP_WOVIA BY CHIP_MOM_WOVIA

#IFDEF 28K_AP
VARIABLE AP_THICKNESS 2.8          // AP thickness is 28000A
#ELSE
VARIABLE AP_THICKNESS 1.45         // AP thickness is 14500A
#ENDIF

VARIABLE m1_thickness 0.24
VARIABLE v1_thickness 0.32
VARIABLE m2_thickness 0.31

VARIABLE v2_thickness 0.32
VARIABLE m3_thickness  0.31
VARIABLE v3_thickness 0.32
VARIABLE m4_thickness  0.31
VARIABLE v4_thickness 0.32
VARIABLE m5_thickness  0.31
VARIABLE v5_thickness 0.32
VARIABLE m6_thickness  0.31
VARIABLE v6_thickness 0.32
VARIABLE m7_thickness  0.31
VARIABLE v7_thickness 0.715
VARIABLE m8_thickness  0.85

VARIABLE v8_thickness 0.715
VARIABLE m9_thickness  0.85

#IFDEF UTM
  VARIABLE mt_thickness 3.4   // top metal is UTM
#ELSE

  VARIABLE mt_thickness 0.85  // top metal is Mz
#ENDIF



MOM.A.1 { @ Maximum sidewall area of total metals in MOM without Via <= 2.77E8
   NET AREA RATIO CHIP_MOM_WOVIA  MOM_M1_CAP_EDGE_EXP_WOVIA_C MOM_M2_CAP_EDGE_EXP_WOVIA_C MOM_M3_CAP_EDGE_EXP_WOVIA_C MOM_M4_CAP_EDGE_EXP_WOVIA_C MOM_M5_CAP_EDGE_EXP_WOVIA_C MOM_M6_CAP_EDGE_EXP_WOVIA_C MOM_M7_CAP_EDGE_EXP_WOVIA_C MOM_M8_CAP_EDGE_EXP_WOVIA_C MOM_M9_CAP_EDGE_EXP_WOVIA_C MOM_AP_CAP_EDGE_EXP_WOVIA_C > MOM_A_1
  [
    ( PERIMETER(MOM_M1_CAP_EDGE_EXP_WOVIA_C)*m1_thickness+ PERIMETER(MOM_M2_CAP_EDGE_EXP_WOVIA_C)*m2_thickness+ PERIMETER(MOM_M3_CAP_EDGE_EXP_WOVIA_C)*m3_thickness+ PERIMETER(MOM_M4_CAP_EDGE_EXP_WOVIA_C)*m4_thickness+ PERIMETER(MOM_M5_CAP_EDGE_EXP_WOVIA_C)*m5_thickness+ PERIMETER(MOM_M6_CAP_EDGE_EXP_WOVIA_C)*m6_thickness+ PERIMETER(MOM_M7_CAP_EDGE_EXP_WOVIA_C)*m7_thickness+ PERIMETER(MOM_M8_CAP_EDGE_EXP_WOVIA_C)*m8_thickness+ PERIMETER(MOM_AP_CAP_EDGE_EXP_WOVIA_C)*AP_THICKNESS+ PERIMETER(MOM_M9_CAP_EDGE_EXP_WOVIA_C)*mt_thickness )/4
  ] RDB MOM.A.1.rep
}

// MOM.S.3 is checked by MOM.S.3:M1
MOM.S.3:M1 { @ Space of Metal (M1/Mx) in MOM with Via >= 0.14
  EXT MOM_M1_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
// MOM.S.3 is checked by MOM.S.3:M2
MOM.S.3:M2 { @ Space of Metal (M1/Mx) in MOM with Via >= 0.14
  EXT MOM_M2_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
// MOM.S.3 is checked by MOM.S.3:M3
MOM.S.3:M3 { @ Space of Metal (M1/Mx) in MOM with Via >= 0.14
  EXT MOM_M3_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
// MOM.S.3 is checked by MOM.S.3:M4
MOM.S.3:M4 { @ Space of Metal (M1/Mx) in MOM with Via >= 0.14
  EXT MOM_M4_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
// MOM.S.3 is checked by MOM.S.3:M5
MOM.S.3:M5 { @ Space of Metal (M1/Mx) in MOM with Via >= 0.14
  EXT MOM_M5_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
// MOM.S.3 is checked by MOM.S.3:M6
MOM.S.3:M6 { @ Space of Metal (M1/Mx) in MOM with Via >= 0.14
  EXT MOM_M6_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
// MOM.S.3 is checked by MOM.S.3:M7
MOM.S.3:M7 { @ Space of Metal (M1/Mx) in MOM with Via >= 0.14
  EXT MOM_M7_WIVIA < MOM_S_3 ABUT < 90 SINGULAR REGION
}
// MOM.S.4 is checked by MOM.S.4:VIA1
MOM.S.4:VIA1 { @ Space of VIAx in MOM with Via in different net >= 0.15 
  A = STAMP MOM_VIA1 BY VIA1i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
// MOM.S.4 is checked by MOM.S.4:VIA2
MOM.S.4:VIA2 { @ Space of VIAx in MOM with Via in different net >= 0.15 
  A = STAMP MOM_VIA2 BY VIA2i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
// MOM.S.4 is checked by MOM.S.4:VIA3
MOM.S.4:VIA3 { @ Space of VIAx in MOM with Via in different net >= 0.15 
  A = STAMP MOM_VIA3 BY VIA3i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
// MOM.S.4 is checked by MOM.S.4:VIA4
MOM.S.4:VIA4 { @ Space of VIAx in MOM with Via in different net >= 0.15 
  A = STAMP MOM_VIA4 BY VIA4i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
// MOM.S.4 is checked by MOM.S.4:VIA5
MOM.S.4:VIA5 { @ Space of VIAx in MOM with Via in different net >= 0.15 
  A = STAMP MOM_VIA5 BY VIA5i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}
// MOM.S.4 is checked by MOM.S.4:VIA6
MOM.S.4:VIA6 { @ Space of VIAx in MOM with Via in different net >= 0.15 
  A = STAMP MOM_VIA6 BY VIA6i    
  EXT A < MOM_S_4 ABUT < 90 NOT CONNECTED SINGULAR REGION
}


MOM.A.2 { @ Maximum sidewall area of {total metals+ total Vias} in MOM with Via. <= 2E6
   NET AREA RATIO CHIP_MOM_WIVIA  MOM_M1_CAP_EDGE_EXP_WIVIA_C MOM_VIA1_C  MOM_M2_CAP_EDGE_EXP_WIVIA_C MOM_VIA2_C  MOM_M3_CAP_EDGE_EXP_WIVIA_C MOM_VIA3_C  MOM_M4_CAP_EDGE_EXP_WIVIA_C MOM_VIA4_C  MOM_M5_CAP_EDGE_EXP_WIVIA_C MOM_VIA5_C  MOM_M6_CAP_EDGE_EXP_WIVIA_C MOM_VIA6_C  MOM_M7_CAP_EDGE_EXP_WIVIA_C MOM_VIA7_C  MOM_M8_CAP_EDGE_EXP_WIVIA_C MOM_VIA8_C  MOM_M9_CAP_EDGE_EXP_WIVIA_C  MOM_RV_C MOM_AP_CAP_EDGE_EXP_WIVIA_C > MOM_A_2
  [
    ( PERIMETER(MOM_M1_CAP_EDGE_EXP_WIVIA_C)*m1_thickness+ PERIMETER(MOM_VIA1_C)*v1_thickness+ PERIMETER(MOM_M2_CAP_EDGE_EXP_WIVIA_C)*m2_thickness+ PERIMETER(MOM_VIA2_C)*v2_thickness+ PERIMETER(MOM_M3_CAP_EDGE_EXP_WIVIA_C)*m3_thickness+ PERIMETER(MOM_VIA3_C)*v3_thickness+ PERIMETER(MOM_M4_CAP_EDGE_EXP_WIVIA_C)*m4_thickness+ PERIMETER(MOM_VIA4_C)*v4_thickness+ PERIMETER(MOM_M5_CAP_EDGE_EXP_WIVIA_C)*m5_thickness+ PERIMETER(MOM_VIA5_C)*v5_thickness+ PERIMETER(MOM_M6_CAP_EDGE_EXP_WIVIA_C)*m6_thickness+ PERIMETER(MOM_VIA6_C)*v6_thickness+ PERIMETER(MOM_M7_CAP_EDGE_EXP_WIVIA_C)*m7_thickness+ PERIMETER(MOM_VIA7_C)*v7_thickness+ PERIMETER(MOM_M8_CAP_EDGE_EXP_WIVIA_C)*m8_thickness+ PERIMETER(MOM_VIA8_C)*v8_thickness+ PERIMETER(MOM_M9_CAP_EDGE_EXP_WIVIA_C)*mt_thickness+ PERIMETER(MOM_RV_C)*0.8+PERIMETER(MOM_AP_CAP_EDGE_EXP_WIVIA_C)*AP_THICKNESS )/4
  ] RDB MOM.A.2.rep
}



//DUMMY M1 CHECKS
//==================
DM1.W.1 { @ Width >= ^DM1_W_1 um
  INT DUM1 < DM1_W_1 ABUT < 90 SINGULAR REGION
}
DM1.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM1_W_2 um
  SIZE DUM1 BY DM1_W_2 /2 UNDEROVER
}
DM1.S.1 { @ Space >= ^DM1_S_1 um
  EXT DUM1 < DM1_S_1 ABUT < 90 SINGULAR REGION
}
DM1.S.2 { @ Space to Mx >= ^DM1_S_2 um
  EXT M1i DUM1 < DM1_S_2 ABUT < 90 SINGULAR REGION
  M1i AND DUM1
}
DM1.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM1_S_3 um.
  X = EXT M1Wide_4.5 DUM1 < DM1_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM1_S_2 DM1_S_3_L+0.005
}
DM1.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM1_S_4 um
  EXT FWi DUM1 < DM1_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM1
}
// DM1.S.5.0 is checked by either DM1.S.5 or DM1.S.5.1
// for sloid L-mark (old)
DM1.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM1 < DM1_S_5 ABUT < 90 SINGULAR REGION 
  DUM1 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM1.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM1 < DM1_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM1 AND LSLOT  
}
DM1.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM1
}
DM1.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM1_S_8 um
  EXT INDDMY DUM1 < DM1_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM1
}
#IFDEF FULL_CHIP
DM1.EN.1 { @ Enclosure by chip edge >= ^DM1_EN_1 um
  DUM1 NOT (SIZE CHIP_CHAMFERED BY -DM1_EN_1)
}
#ENDIF
DM1.A.1 { @ Min. area >= ^DM1_A_1 um2
  AREA DUM1 < DM1_A_1 
}
DM1.A.2 { @ Max. area <= ^DM1_A_2 um2
  AREA DUM1 > DM1_A_2 
}
#IFDEF FULL_CHIP
DM1.R.1 { @ DM1 is must. The DM1 CAD layer must be different from the M1 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM1
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM1.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM1
  HOLES DUM1
}
// DMx_O.R.1 is checked by DM1_O.R.1
DM1_O.R.1 { @ DM1_O interact M1 is not allowed.
  DUM1_O INTERACT M1_real
}



//DUMMY M2 CHECKS
//==================
DM2.W.1 { @ Width >= ^DM2_W_1 um
  INT DUM2 < DM2_W_1 ABUT < 90 SINGULAR REGION
}
DM2.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM2_W_2 um
  SIZE DUM2 BY DM2_W_2 /2 UNDEROVER
}
DM2.S.1 { @ Space >= ^DM2_S_1 um
  EXT DUM2 < DM2_S_1 ABUT < 90 SINGULAR REGION
}
DM2.S.2 { @ Space to Mx >= ^DM2_S_2 um
  EXT M2i DUM2 < DM2_S_2 ABUT < 90 SINGULAR REGION
  M2i AND DUM2
}
DM2.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM2_S_3 um.
  X = EXT M2Wide_4.5 DUM2 < DM2_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM2_S_2 DM2_S_3_L+0.005
}
DM2.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM2_S_4 um
  EXT FWi DUM2 < DM2_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM2
}
// DM2.S.5.0 is checked by either DM2.S.5 or DM2.S.5.1
// for sloid L-mark (old)
DM2.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM2 < DM2_S_5 ABUT < 90 SINGULAR REGION 
  DUM2 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM2.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM2 < DM2_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM2 AND LSLOT  
}
DM2.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM2
}
DM2.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM2_S_8 um
  EXT INDDMY DUM2 < DM2_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM2
}
#IFDEF FULL_CHIP
DM2.EN.1 { @ Enclosure by chip edge >= ^DM2_EN_1 um
  DUM2 NOT (SIZE CHIP_CHAMFERED BY -DM2_EN_1)
}
#ENDIF
DM2.A.1 { @ Min. area >= ^DM2_A_1 um2
  AREA DUM2 < DM2_A_1 
}
DM2.A.2 { @ Max. area <= ^DM2_A_2 um2
  AREA DUM2 > DM2_A_2 
}
#IFDEF FULL_CHIP
DM2.R.1 { @ DM2 is must. The DM2 CAD layer must be different from the M2 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM2
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM2.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM2
  HOLES DUM2
}
// DMx_O.R.1 is checked by DM2_O.R.1
DM2_O.R.1 { @ DM2_O interact M2 is not allowed.
  DUM2_O INTERACT M2_real
}



//DUMMY M3 CHECKS
//==================
DM3.W.1 { @ Width >= ^DM3_W_1 um
  INT DUM3 < DM3_W_1 ABUT < 90 SINGULAR REGION
}
DM3.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM3_W_2 um
  SIZE DUM3 BY DM3_W_2 /2 UNDEROVER
}
DM3.S.1 { @ Space >= ^DM3_S_1 um
  EXT DUM3 < DM3_S_1 ABUT < 90 SINGULAR REGION
}
DM3.S.2 { @ Space to Mx >= ^DM3_S_2 um
  EXT M3i DUM3 < DM3_S_2 ABUT < 90 SINGULAR REGION
  M3i AND DUM3
}
DM3.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM3_S_3 um.
  X = EXT M3Wide_4.5 DUM3 < DM3_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM3_S_2 DM3_S_3_L+0.005
}
DM3.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM3_S_4 um
  EXT FWi DUM3 < DM3_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM3
}
// DM3.S.5.0 is checked by either DM3.S.5 or DM3.S.5.1
// for sloid L-mark (old)
DM3.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM3 < DM3_S_5 ABUT < 90 SINGULAR REGION 
  DUM3 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM3.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM3 < DM3_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM3 AND LSLOT  
}
DM3.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM3
}
DM3.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM3_S_8 um
  EXT INDDMY DUM3 < DM3_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM3
}
#IFDEF FULL_CHIP
DM3.EN.1 { @ Enclosure by chip edge >= ^DM3_EN_1 um
  DUM3 NOT (SIZE CHIP_CHAMFERED BY -DM3_EN_1)
}
#ENDIF
DM3.A.1 { @ Min. area >= ^DM3_A_1 um2
  AREA DUM3 < DM3_A_1 
}
DM3.A.2 { @ Max. area <= ^DM3_A_2 um2
  AREA DUM3 > DM3_A_2 
}
#IFDEF FULL_CHIP
DM3.R.1 { @ DM3 is must. The DM3 CAD layer must be different from the M3 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM3
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM3.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM3
  HOLES DUM3
}
// DMx_O.R.1 is checked by DM3_O.R.1
DM3_O.R.1 { @ DM3_O interact M3 is not allowed.
  DUM3_O INTERACT M3_real
}



//DUMMY M4 CHECKS
//==================
DM4.W.1 { @ Width >= ^DM4_W_1 um
  INT DUM4 < DM4_W_1 ABUT < 90 SINGULAR REGION
}
DM4.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM4_W_2 um
  SIZE DUM4 BY DM4_W_2 /2 UNDEROVER
}
DM4.S.1 { @ Space >= ^DM4_S_1 um
  EXT DUM4 < DM4_S_1 ABUT < 90 SINGULAR REGION
}
DM4.S.2 { @ Space to Mx >= ^DM4_S_2 um
  EXT M4i DUM4 < DM4_S_2 ABUT < 90 SINGULAR REGION
  M4i AND DUM4
}
DM4.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM4_S_3 um.
  X = EXT M4Wide_4.5 DUM4 < DM4_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM4_S_2 DM4_S_3_L+0.005
}
DM4.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM4_S_4 um
  EXT FWi DUM4 < DM4_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM4
}
// DM4.S.5.0 is checked by either DM4.S.5 or DM4.S.5.1
// for sloid L-mark (old)
DM4.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM4 < DM4_S_5 ABUT < 90 SINGULAR REGION 
  DUM4 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM4.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM4 < DM4_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM4 AND LSLOT  
}
DM4.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM4
}
DM4.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM4_S_8 um
  EXT INDDMY DUM4 < DM4_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM4
}
#IFDEF FULL_CHIP
DM4.EN.1 { @ Enclosure by chip edge >= ^DM4_EN_1 um
  DUM4 NOT (SIZE CHIP_CHAMFERED BY -DM4_EN_1)
}
#ENDIF
DM4.A.1 { @ Min. area >= ^DM4_A_1 um2
  AREA DUM4 < DM4_A_1 
}
DM4.A.2 { @ Max. area <= ^DM4_A_2 um2
  AREA DUM4 > DM4_A_2 
}
#IFDEF FULL_CHIP
DM4.R.1 { @ DM4 is must. The DM4 CAD layer must be different from the M4 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM4
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM4.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM4
  HOLES DUM4
}
// DMx_O.R.1 is checked by DM4_O.R.1
DM4_O.R.1 { @ DM4_O interact M4 is not allowed.
  DUM4_O INTERACT M4_real
}



//DUMMY M5 CHECKS
//==================
DM5.W.1 { @ Width >= ^DM5_W_1 um
  INT DUM5 < DM5_W_1 ABUT < 90 SINGULAR REGION
}
DM5.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM5_W_2 um
  SIZE DUM5 BY DM5_W_2 /2 UNDEROVER
}
DM5.S.1 { @ Space >= ^DM5_S_1 um
  EXT DUM5 < DM5_S_1 ABUT < 90 SINGULAR REGION
}
DM5.S.2 { @ Space to Mx >= ^DM5_S_2 um
  EXT M5i DUM5 < DM5_S_2 ABUT < 90 SINGULAR REGION
  M5i AND DUM5
}
DM5.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM5_S_3 um.
  X = EXT M5Wide_4.5 DUM5 < DM5_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM5_S_2 DM5_S_3_L+0.005
}
DM5.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM5_S_4 um
  EXT FWi DUM5 < DM5_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM5
}
// DM5.S.5.0 is checked by either DM5.S.5 or DM5.S.5.1
// for sloid L-mark (old)
DM5.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM5 < DM5_S_5 ABUT < 90 SINGULAR REGION 
  DUM5 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM5.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM5 < DM5_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM5 AND LSLOT  
}
DM5.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM5
}
DM5.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM5_S_8 um
  EXT INDDMY DUM5 < DM5_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM5
}
#IFDEF FULL_CHIP
DM5.EN.1 { @ Enclosure by chip edge >= ^DM5_EN_1 um
  DUM5 NOT (SIZE CHIP_CHAMFERED BY -DM5_EN_1)
}
#ENDIF
DM5.A.1 { @ Min. area >= ^DM5_A_1 um2
  AREA DUM5 < DM5_A_1 
}
DM5.A.2 { @ Max. area <= ^DM5_A_2 um2
  AREA DUM5 > DM5_A_2 
}
#IFDEF FULL_CHIP
DM5.R.1 { @ DM5 is must. The DM5 CAD layer must be different from the M5 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM5
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM5.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM5
  HOLES DUM5
}
// DMx_O.R.1 is checked by DM5_O.R.1
DM5_O.R.1 { @ DM5_O interact M5 is not allowed.
  DUM5_O INTERACT M5_real
}



//DUMMY M6 CHECKS
//==================
DM6.W.1 { @ Width >= ^DM6_W_1 um
  INT DUM6 < DM6_W_1 ABUT < 90 SINGULAR REGION
}
DM6.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM6_W_2 um
  SIZE DUM6 BY DM6_W_2 /2 UNDEROVER
}
DM6.S.1 { @ Space >= ^DM6_S_1 um
  EXT DUM6 < DM6_S_1 ABUT < 90 SINGULAR REGION
}
DM6.S.2 { @ Space to Mx >= ^DM6_S_2 um
  EXT M6i DUM6 < DM6_S_2 ABUT < 90 SINGULAR REGION
  M6i AND DUM6
}
DM6.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM6_S_3 um.
  X = EXT M6Wide_4.5 DUM6 < DM6_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM6_S_2 DM6_S_3_L+0.005
}
DM6.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM6_S_4 um
  EXT FWi DUM6 < DM6_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM6
}
// DM6.S.5.0 is checked by either DM6.S.5 or DM6.S.5.1
// for sloid L-mark (old)
DM6.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM6 < DM6_S_5 ABUT < 90 SINGULAR REGION 
  DUM6 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM6.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM6 < DM6_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM6 AND LSLOT  
}
DM6.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM6
}
DM6.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM6_S_8 um
  EXT INDDMY DUM6 < DM6_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM6
}
#IFDEF FULL_CHIP
DM6.EN.1 { @ Enclosure by chip edge >= ^DM6_EN_1 um
  DUM6 NOT (SIZE CHIP_CHAMFERED BY -DM6_EN_1)
}
#ENDIF
DM6.A.1 { @ Min. area >= ^DM6_A_1 um2
  AREA DUM6 < DM6_A_1 
}
DM6.A.2 { @ Max. area <= ^DM6_A_2 um2
  AREA DUM6 > DM6_A_2 
}
#IFDEF FULL_CHIP
DM6.R.1 { @ DM6 is must. The DM6 CAD layer must be different from the M6 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM6
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM6.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM6
  HOLES DUM6
}
// DMx_O.R.1 is checked by DM6_O.R.1
DM6_O.R.1 { @ DM6_O interact M6 is not allowed.
  DUM6_O INTERACT M6_real
}



//DUMMY M7 CHECKS
//==================
DM7.W.1 { @ Width >= ^DM7_W_1 um
  INT DUM7 < DM7_W_1 ABUT < 90 SINGULAR REGION
}
DM7.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM7_W_2 um
  SIZE DUM7 BY DM7_W_2 /2 UNDEROVER
}
DM7.S.1 { @ Space >= ^DM7_S_1 um
  EXT DUM7 < DM7_S_1 ABUT < 90 SINGULAR REGION
}
DM7.S.2 { @ Space to Mx >= ^DM7_S_2 um
  EXT M7i DUM7 < DM7_S_2 ABUT < 90 SINGULAR REGION
  M7i AND DUM7
}
DM7.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM7_S_3 um.
  X = EXT M7Wide_4.5 DUM7 < DM7_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM7_S_2 DM7_S_3_L+0.005
}
DM7.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM7_S_4 um
  EXT FWi DUM7 < DM7_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM7
}
// DM7.S.5.0 is checked by either DM7.S.5 or DM7.S.5.1
// for sloid L-mark (old)
DM7.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM7 < DM7_S_5 ABUT < 90 SINGULAR REGION 
  DUM7 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM7.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM7 < DM7_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM7 AND LSLOT  
}
DM7.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM7
}
DM7.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM7_S_8 um
  EXT INDDMY DUM7 < DM7_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM7
}
#IFDEF FULL_CHIP
DM7.EN.1 { @ Enclosure by chip edge >= ^DM7_EN_1 um
  DUM7 NOT (SIZE CHIP_CHAMFERED BY -DM7_EN_1)
}
#ENDIF
DM7.A.1 { @ Min. area >= ^DM7_A_1 um2
  AREA DUM7 < DM7_A_1 
}
DM7.A.2 { @ Max. area <= ^DM7_A_2 um2
  AREA DUM7 > DM7_A_2 
}
#IFDEF FULL_CHIP
DM7.R.1 { @ DM7 is must. The DM7 CAD layer must be different from the M7 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM7
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM7.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM7
  HOLES DUM7
}
// DMx_O.R.1 is checked by DM7_O.R.1
DM7_O.R.1 { @ DM7_O interact M7 is not allowed.
  DUM7_O INTERACT M7_real
}



//DUMMY M8 CHECKS
//==================
DM8.W.1 { @ Width >= ^DM8_W_1 um
  INT DUM8 < DM8_W_1 ABUT < 90 SINGULAR REGION
}
DM8.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM8_W_2 um
  SIZE DUM8 BY DM8_W_2 /2 UNDEROVER
}
DM8.S.1 { @ Space >= ^DM8_S_1 um
  EXT DUM8 < DM8_S_1 ABUT < 90 SINGULAR REGION
}
DM8.S.2 { @ Space to Mx >= ^DM8_S_2 um
  EXT M8i DUM8 < DM8_S_2 ABUT < 90 SINGULAR REGION
  M8i AND DUM8
}
DM8.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM8_S_3 um.
  X = EXT M8Wide_4.5 DUM8 < DM8_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM8_S_2 DM8_S_3_L+0.005
}
DM8.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM8_S_4 um
  EXT FWi DUM8 < DM8_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM8
}
// DM8.S.5.0 is checked by either DM8.S.5 or DM8.S.5.1
// for sloid L-mark (old)
DM8.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM8 < DM8_S_5 ABUT < 90 SINGULAR REGION 
  DUM8 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM8.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM8 < DM8_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM8 AND LSLOT  
}
DM8.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM8
}
DM8.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM8_S_8 um
  EXT INDDMY DUM8 < DM8_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM8
}
#IFDEF FULL_CHIP
DM8.EN.1 { @ Enclosure by chip edge >= ^DM8_EN_1 um
  DUM8 NOT (SIZE CHIP_CHAMFERED BY -DM8_EN_1)
}
#ENDIF
DM8.A.1 { @ Min. area >= ^DM8_A_1 um2
  AREA DUM8 < DM8_A_1 
}
DM8.A.2 { @ Max. area <= ^DM8_A_2 um2
  AREA DUM8 > DM8_A_2 
}
#IFDEF FULL_CHIP
DM8.R.1 { @ DM8 is must. The DM8 CAD layer must be different from the M8 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM8
}
#ENDIF
// 'DMx.R.2' is checked by 'CSR.R.1'
DM8.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM8
  HOLES DUM8
}
// DMx_O.R.1 is checked by DM8_O.R.1
DM8_O.R.1 { @ DM8_O interact M8 is not allowed.
  DUM8_O INTERACT M8_real
}



//DUMMY M9 CHECKS
//==================
#IFNDEF UTM

DM9.W.1 { @ Width >= ^DM9_W_1 um
  INT DUM9 < DM9_W_1 ABUT < 90 SINGULAR REGION
}
DM9.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DM9_W_2 um
  SIZE DUM9 BY DM9_W_2 /2 UNDEROVER
}
DM9.S.1 { @ Space >= ^DM9_S_1 um
  EXT DUM9 < DM9_S_1 ABUT < 90 SINGULAR REGION
}
DM9.S.2 { @ Space to Mx >= ^DM9_S_2 um
  EXT M9i DUM9 < DM9_S_2 ABUT < 90 SINGULAR REGION
  M9i AND DUM9
}
DM9.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DM9_S_3 um.
  X = EXT M9Wide_4.5 DUM9 < DM9_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DM9_S_2 DM9_S_3_L+0.005
}
DM9.S.4 { @ Space to FW (Overlap is not allowed) >= ^DM9_S_4 um
  EXT FWi DUM9 < DM9_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUM9
}
// DM9.S.5.0 is checked by either DM9.S.5 or DM9.S.5.1
// for sloid L-mark (old)
DM9.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUM9 < DM9_S_5 ABUT < 90 SINGULAR REGION 
  DUM9 AND LMARK_SOLID  
}
// for hollow L-mark (new)
DM9.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUM9 < DM9_S_5_1 ABUT < 90 SINGULAR REGION 
  DUM9 AND LSLOT  
}
DM9.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUM9
}
DM9.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DM9_S_8 um
  EXT INDDMY DUM9 < DM9_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUM9
}
#IFDEF FULL_CHIP
DM9.EN.1 { @ Enclosure by chip edge >= ^DM9_EN_1 um
  DUM9 NOT (SIZE CHIP_CHAMFERED BY -DM9_EN_1)
}
#ENDIF
DM9.A.1 { @ Min. area >= ^DM9_A_1 um2
  AREA DUM9 < DM9_A_1 
}
DM9.A.2 { @ Max. area <= ^DM9_A_2 um2
  AREA DUM9 > DM9_A_2 
}
#IFDEF FULL_CHIP
DM9.R.1 { @ DM9 is must. The DM9 CAD layer must be different from the M9 CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUM9
}
#ENDIF

// 'DMx.R.2' is checked by 'CSR.R.1'

DM9.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUM9
  HOLES DUM9
}
#ENDIF

// DMx_O.R.1 is checked by DM9_O.R.1
DM9_O.R.1 { @ DM9_O interact M9 is not allowed.
  DUM9_O INTERACT M9_real
}



//DUMMY MD CHECKS
//==================
DMD.W.1 { @ Width >= ^DMD_W_1 um
  INT DUMD < DMD_W_1 ABUT < 90 SINGULAR REGION
}
DMD.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DMD_W_2 um
  SIZE DUMD BY DMD_W_2 /2 UNDEROVER
}
DMD.S.1 { @ Space >= ^DMD_S_1 um
  EXT DUMD < DMD_S_1 ABUT < 90 SINGULAR REGION
}
DMD.S.2 { @ Space to Mx >= ^DMD_S_2 um
  EXT MDi DUMD < DMD_S_2 ABUT < 90 SINGULAR REGION
  MDi AND DUMD
}
DMD.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DMD_S_3 um.
  X = EXT MDWide_4.5 DUMD < DMD_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DMD_S_2 DMD_S_3_L+0.005
}
DMD.S.4 { @ Space to FW (Overlap is not allowed) >= ^DMD_S_4 um
  EXT FWi DUMD < DMD_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUMD
}
// for sloid L-mark (old)
DMD.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUMD < DMD_S_5 ABUT < 90 SINGULAR REGION 
  DUMD AND LMARK_SOLID  
}
// for hollow L-mark (new)
DMD.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUMD < DMD_S_5_1 ABUT < 90 SINGULAR REGION 
  DUMD AND LSLOT  
}
DMD.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUMD
}
DMD.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DMD_S_8 um
  EXT INDDMY DUMD < DMD_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUMD
}
#IFDEF FULL_CHIP
DMD.EN.1 { @ Enclosure by chip edge >= ^DMD_EN_1 um
  DUMD NOT (SIZE CHIP_CHAMFERED BY -DMD_EN_1)
}
#ENDIF
DMD.A.1 { @ Min. area >= ^DMD_A_1 um2
  AREA DUMD < DMD_A_1 
}
DMD.A.2 { @ Max. area <= ^DMD_A_2 um2
  AREA DUMD > DMD_A_2 
}
#IFDEF FULL_CHIP
DMD.R.1 { @ DMD is must. The DMD CAD layer must be different from the MD CAD layer.
  (CHIP_CHAMFERED INTERACT MDi) NOT INTERACT DUMD
}
#ENDIF
DMD.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUMD
  HOLES DUMD
}
// DMx_O.R.1 is checked by DMD_O.R.1
DMD_O.R.1 { @ DMD_O interact M10 is not allowed.
  DUMD_O INTERACT MD_real
}


DM7.S.9 { @ Space to CBM [CBM between Mx and Mx+1] (Overlap is not allowed) >= ^DM7_S_9 um
  EXT CBM DUM7 < DM7_S_9 ABUT < 90 SINGULAR REGION 
  CBM AND DUM7
}



//LOGO CHECKS
//============

LOGO.S.1 { @ Space to OD, PO, or Metals (non-dummy patterns) >= ^LOGO_S_1 um
  LOGO_EXT = (SIZE LOGO BY LOGO_S_1) NOT LOGO
  LOGO_EXT AND ODi
  LOGO_EXT AND POi
  LOGO_EXT AND (M1i NOT DUM1_O)
  LOGO_EXT AND (M2i NOT DUM2_O)
  LOGO_EXT AND (M3i NOT DUM3_O)
  LOGO_EXT AND (M4i NOT DUM4_O)
  LOGO_EXT AND (M5i NOT DUM5_O)
  LOGO_EXT AND (M6i NOT DUM6_O)
  LOGO_EXT AND (M7i NOT DUM7_O)
  LOGO_EXT AND (M8i NOT DUM8_O)
  LOGO_EXT AND (M9i NOT DUM9_O)
  LOGO_EXT AND (MDi NOT DUMD_O)

}
LOGO.O.1 { @ Overlap of CB, CBD, FW, PM, UBM, DOD, DPO, or DMx is not allowed
  LOGO AND CBi
  LOGO AND CBDi
  LOGO AND FWi
  LOGO AND PMi
  LOGO AND UBMi
}

// LOGO.R.1 can not be checked.
// LOGO.R.2 is checked by related rules.


//SRAM CHECKS
//==========

SRAM.W.1 { @ (Width of SRM) interact with OD. The SRM edge should be aligned to the boundary of the cell array, which may include storage, strapping, and dummy edge cells >= ^SRAM_W_1 um
  (INT SRM < SRAM_W_1 ABUT < 90 SINGULAR REGION) INTERACT ODi
}
SRAM.EX.1 { @ (SRM extension on NW) interact with OD. Extension = 0 is allowed >= ^SRAM_EX_1 um
  (ENC NWi SRM < SRAM_EX_1 ABUT < 90 > 0 SINGULAR REGION) INTERACT ODi
}
// SRAM.BTC.S.1N90 is checked by SRAM.BTC.S.1
// SRAM.BTC.S.1N85 is checked by SRAM.BTC.S.1
// SRAM.BTC.S.1N80 is checked by SRAM.BTC.S.1
SRAM.BTC.S.1 { @ BTC space [different nets] >= ^SRAM_BTC_S_1 
  X = STAMP BTC BY COi
  EXT X < SRAM_BTC_S_1 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
// SRAM.BTC.S.2N90 is checked by SRAM.BTC.S.2
// SRAM.BTC.S.2N85 is checked by SRAM.BTC.S.2
// SRAM.BTC.S.2N80 is checked by SRAM.BTC.S.2
SRAM.BTC.S.2 { @ BTC space to M1 [different nets] >= ^SRAM_BTC_S_2 
  X = STAMP BTC BY COi
  EXT X M1i < SRAM_BTC_S_2 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
// SRAM.BTC.S.3N90 is checked by SRAM.BTC.S.3
// SRAM.BTC.S.3N85 is checked by SRAM.BTC.S.3
// SRAM.BTC.S.3N80 is checked by SRAM.BTC.S.3
SRAM.BTC.S.3 { @ BTC space to CO [different nets] >= ^SRAM_BTC_S_3 
  X = STAMP BTC BY COi
  EXT X COi < SRAM_BTC_S_3 ABUT < 90 SINGULAR REGION NOT CONNECTED
}
SRAM.R.12 { @ SRAMDMY(186;4) overlap SRAMDMY(186;0) is not allowed
  SRAMDMY_PERI AND SRAMDMY
}
SRAM.R.13 { @ SRM must fully cover GATE
  GATEi = POi AND ODi  // all gate includes SRAM region
  GATEi CUT SRM
}
NW.S.1:SRM_SRAMDMY { @ Spacing between NW along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (NW_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(NW_S_1 + GRID)
  C = A NOT B
  D = NWi NOT OUTSIDE C
  E = EXT D < NW_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}
OD.S.1:SRM_SRAMDMY { @ Spacing between OD along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (OD_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(OD_S_1 + GRID)
  C = A NOT B
  D = ODi NOT OUTSIDE C
  E = EXT D < OD_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}
PO.S.1:SRM_SRAMDMY { @ Spacing between POLY along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (PO_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(PO_S_1 + GRID)
  C = A NOT B
  D = POi NOT OUTSIDE C
  E = EXT D < PO_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}
NP.S.1:SRM_SRAMDMY { @ Spacing between NP along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (NP_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(NP_S_1 + GRID)
  C = A NOT B
  D = NPi NOT OUTSIDE C
  E = EXT D < NP_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}
PP.S.1:SRM_SRAMDMY { @ Spacing between PP along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (PP_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(PP_S_1 + GRID)
  C = A NOT B
  D = PPi NOT OUTSIDE C
  E = EXT D < PP_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}
CO.S.1:SRM_SRAMDMY { @ Spacing between CO along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (CO_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(CO_S_1 + GRID)
  C = A NOT B
  D = COi NOT OUTSIDE C
  E = EXT D < CO_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}
M1.S.1:SRM_SRAMDMY { @ Spacing between M1 along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (M1_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(M1_S_1 + GRID)
  C = A NOT B
  D = M1i NOT OUTSIDE C
  E = EXT D < M1_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}
VIA1.S.1:SRM_SRAMDMY { @ Spacing between VIA1 along the boundary of SRAMDMY
  A = SIZE SRAM_EXCLUDE BY (VIA1_S_1 + GRID)
  B = SIZE SRAM_EXCLUDE BY -(VIA1_S_1 + GRID)
  C = A NOT B
  D = VIA1i NOT OUTSIDE C
  E = EXT D < VIA1_S_1 ABUT < 90 SINGULAR REGION
  E CUT SRAM_EXCLUDE
  E TOUCH SRAM_EXCLUDE

}


//CHIP CORNER RULE CHECKS
//=======================

#IFDEF FULL_CHIP
// CSR.R.1 is checked by CSR.R.1:excludeRRuleRequired
CSR.R.1:excludeRRuleRequired { @ excludeRRuleRequired is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND excludeRRuleRequired     
}
// CSR.R.1 is checked by CSR.R.1:excludeRRuleRecommended
CSR.R.1:excludeRRuleRecommended { @ excludeRRuleRecommended is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND excludeRRuleRecommended     
}
// CSR.R.1 is checked by CSR.R.1:excludeRRuleAnalog
CSR.R.1:excludeRRuleAnalog { @ excludeRRuleAnalog is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND excludeRRuleAnalog     
}
// CSR.R.1 is checked by CSR.R.1:excludeRRuleGuideline
CSR.R.1:excludeRRuleGuideline { @ excludeRRuleGuideline is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND excludeRRuleGuideline     
}
// CSR.R.1 is checked by CSR.R.1:RODMY
CSR.R.1:RODMY { @ RODMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RODMY     
}
// CSR.R.1 is checked by CSR.R.1:DNWi
CSR.R.1:DNWi { @ DNWi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DNWi     
}
// CSR.R.1 is checked by CSR.R.1:NWi
CSR.R.1:NWi { @ NWi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NWi     
}
// CSR.R.1 is checked by CSR.R.1:NWi_OTHERS
CSR.R.1:NWi_OTHERS { @ NWi_OTHERS is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NWi_OTHERS     
}
// CSR.R.1 is checked by CSR.R.1:OD_18i
CSR.R.1:OD_18i { @ OD_18i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_18i     
}
// CSR.R.1 is checked by CSR.R.1:OD_25i
CSR.R.1:OD_25i { @ OD_25i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_25i     
}
// CSR.R.1 is checked by CSR.R.1:OD_2533
CSR.R.1:OD_2533 { @ OD_2533 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_2533     
}
// CSR.R.1 is checked by CSR.R.1:OD_33i
CSR.R.1:OD_33i { @ OD_33i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_33i     
}
// CSR.R.1 is checked by CSR.R.1:OD_DECAP
CSR.R.1:OD_DECAP { @ OD_DECAP is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND OD_DECAP     
}
// CSR.R.1 is checked by CSR.R.1:PPi
CSR.R.1:PPi { @ PPi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PPi     
}
// CSR.R.1 is checked by CSR.R.1:NPi
CSR.R.1:NPi { @ NPi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NPi     
}
// CSR.R.1 is checked by CSR.R.1:COi
CSR.R.1:COi { @ COi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND COi     
}
// CSR.R.1 is checked by CSR.R.1:CBi
CSR.R.1:CBi { @ CBi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CBi     
}
// CSR.R.1 is checked by CSR.R.1:CB2i
CSR.R.1:CB2i { @ CB2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CB2i     
}
// CSR.R.1 is checked by CSR.R.1:RPOi
CSR.R.1:RPOi { @ RPOi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RPOi     
}
// CSR.R.1 is checked by CSR.R.1:NT_Ni
CSR.R.1:NT_Ni { @ NT_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NT_Ni     
}
// CSR.R.1 is checked by CSR.R.1:NCap_NTNi
CSR.R.1:NCap_NTNi { @ NCap_NTNi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NCap_NTNi     
}
// CSR.R.1 is checked by CSR.R.1:FW_APi
CSR.R.1:FW_APi { @ FW_APi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND FW_APi     
}
// CSR.R.1 is checked by CSR.R.1:FW_CUi
CSR.R.1:FW_CUi { @ FW_CUi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND FW_CUi     
}
// CSR.R.1 is checked by CSR.R.1:PMi
CSR.R.1:PMi { @ PMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PMi     
}
// CSR.R.1 is checked by CSR.R.1:PM1i
CSR.R.1:PM1i { @ PM1i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PM1i     
}
// CSR.R.1 is checked by CSR.R.1:PM2i
CSR.R.1:PM2i { @ PM2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PM2i     
}
// CSR.R.1 is checked by CSR.R.1:SEALRINGi
CSR.R.1:SEALRINGi { @ SEALRINGi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SEALRINGi     
}
// CSR.R.1 is checked by CSR.R.1:VTH_Ni
CSR.R.1:VTH_Ni { @ VTH_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTH_Ni     
}
// CSR.R.1 is checked by CSR.R.1:VTH_Pi
CSR.R.1:VTH_Pi { @ VTH_Pi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTH_Pi     
}
// CSR.R.1 is checked by CSR.R.1:ULVT_Ni
CSR.R.1:ULVT_Ni { @ ULVT_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ULVT_Ni     
}
// CSR.R.1 is checked by CSR.R.1:ULVT_Pi
CSR.R.1:ULVT_Pi { @ ULVT_Pi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ULVT_Pi     
}
// CSR.R.1 is checked by CSR.R.1:VTL_Ni
CSR.R.1:VTL_Ni { @ VTL_Ni is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTL_Ni     
}
// CSR.R.1 is checked by CSR.R.1:VTL_Pi
CSR.R.1:VTL_Pi { @ VTL_Pi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VTL_Pi     
}
// CSR.R.1 is checked by CSR.R.1:CBDi
CSR.R.1:CBDi { @ CBDi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CBDi     
}
// CSR.R.1 is checked by CSR.R.1:UBMi
CSR.R.1:UBMi { @ UBMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND UBMi     
}
// CSR.R.1 is checked by CSR.R.1:RH
CSR.R.1:RH { @ RH is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RH     
}
// CSR.R.1 is checked by CSR.R.1:ESD3
CSR.R.1:ESD3 { @ ESD3 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ESD3     
}
// CSR.R.1 is checked by CSR.R.1:VARi
CSR.R.1:VARi { @ VARi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VARi     
}
// CSR.R.1 is checked by CSR.R.1:APi
CSR.R.1:APi { @ APi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND APi     
}
// CSR.R.1 is checked by CSR.R.1:Cu_PPIi
CSR.R.1:Cu_PPIi { @ Cu_PPIi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND Cu_PPIi     
}
// CSR.R.1 is checked by CSR.R.1:RVi
CSR.R.1:RVi { @ RVi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RVi     
}
// CSR.R.1 is checked by CSR.R.1:SANi
CSR.R.1:SANi { @ SANi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SANi     
}
// CSR.R.1 is checked by CSR.R.1:CBMi
CSR.R.1:CBMi { @ CBMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CBMi     
}
// CSR.R.1 is checked by CSR.R.1:CTMi
CSR.R.1:CTMi { @ CTMi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CTMi     
}
// CSR.R.1 is checked by CSR.R.1:SRM
CSR.R.1:SRM { @ SRM is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRM     
}
// CSR.R.1 is checked by CSR.R.1:LMARK
CSR.R.1:LMARK { @ LMARK is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND LMARK     
}
// CSR.R.1 is checked by CSR.R.1:BJTDMY
CSR.R.1:BJTDMY { @ BJTDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND BJTDMY     
}
// CSR.R.1 is checked by CSR.R.1:DIODMY
CSR.R.1:DIODMY { @ DIODMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DIODMY     
}
// CSR.R.1 is checked by CSR.R.1:NWDMY
CSR.R.1:NWDMY { @ NWDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND NWDMY     
}
// CSR.R.1 is checked by CSR.R.1:RPDMY
CSR.R.1:RPDMY { @ RPDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RPDMY     
}
// CSR.R.1 is checked by CSR.R.1:DPDMY
CSR.R.1:DPDMY { @ DPDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DPDMY     
}
// CSR.R.1 is checked by CSR.R.1:PLDMY
CSR.R.1:PLDMY { @ PLDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PLDMY     
}
// CSR.R.1 is checked by CSR.R.1:SDI
CSR.R.1:SDI { @ SDI is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SDI     
}
// CSR.R.1 is checked by CSR.R.1:PMDMY
CSR.R.1:PMDMY { @ PMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PMDMY     
}
// CSR.R.1 is checked by CSR.R.1:ESD1DMY
CSR.R.1:ESD1DMY { @ ESD1DMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ESD1DMY     
}
// CSR.R.1 is checked by CSR.R.1:ESD2DMY
CSR.R.1:ESD2DMY { @ ESD2DMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ESD2DMY     
}
// CSR.R.1 is checked by CSR.R.1:CDUDMY
CSR.R.1:CDUDMY { @ CDUDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CDUDMY     
}
// CSR.R.1 is checked by CSR.R.1:CSRDMY
CSR.R.1:CSRDMY { @ CSRDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CSRDMY     
}
// CSR.R.1 is checked by CSR.R.1:LOGO
CSR.R.1:LOGO { @ LOGO is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND LOGO     
}
// CSR.R.1 is checked by CSR.R.1:INDDMY
CSR.R.1:INDDMY { @ INDDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND INDDMY     
}
// CSR.R.1 is checked by CSR.R.1:CTMDMY
CSR.R.1:CTMDMY { @ CTMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND CTMDMY     
}
// CSR.R.1 is checked by CSR.R.1:WBDMY
CSR.R.1:WBDMY { @ WBDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND WBDMY     
}
// CSR.R.1 is checked by CSR.R.1:LUPWDMY
CSR.R.1:LUPWDMY { @ LUPWDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND LUPWDMY     
}
// CSR.R.1 is checked by CSR.R.1:VDDDMY
CSR.R.1:VDDDMY { @ VDDDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VDDDMY     
}
// CSR.R.1 is checked by CSR.R.1:VSSDMY
CSR.R.1:VSSDMY { @ VSSDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VSSDMY     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_1
CSR.R.1:MOMDMY_1 { @ MOMDMY_1 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_1     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_2
CSR.R.1:MOMDMY_2 { @ MOMDMY_2 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_2     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_3
CSR.R.1:MOMDMY_3 { @ MOMDMY_3 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_3     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_4
CSR.R.1:MOMDMY_4 { @ MOMDMY_4 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_4     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_5
CSR.R.1:MOMDMY_5 { @ MOMDMY_5 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_5     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_6
CSR.R.1:MOMDMY_6 { @ MOMDMY_6 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_6     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_7
CSR.R.1:MOMDMY_7 { @ MOMDMY_7 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_7     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_8
CSR.R.1:MOMDMY_8 { @ MOMDMY_8 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_8     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_9
CSR.R.1:MOMDMY_9 { @ MOMDMY_9 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_9     
}
// CSR.R.1 is checked by CSR.R.1:MOMDMY_AP
CSR.R.1:MOMDMY_AP { @ MOMDMY_AP is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MOMDMY_AP     
}
// CSR.R.1 is checked by CSR.R.1:RTMOMDMY
CSR.R.1:RTMOMDMY { @ RTMOMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RTMOMDMY     
}
// CSR.R.1 is checked by CSR.R.1:RFDMY
CSR.R.1:RFDMY { @ RFDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RFDMY     
}
// CSR.R.1 is checked by CSR.R.1:SRAMDMY
CSR.R.1:SRAMDMY { @ SRAMDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRAMDMY     
}
// CSR.R.1 is checked by CSR.R.1:SRAMDMY_PERI
CSR.R.1:SRAMDMY_PERI { @ SRAMDMY_PERI is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRAMDMY_PERI     
}
// CSR.R.1 is checked by CSR.R.1:SRAMDMY6_PERI
CSR.R.1:SRAMDMY6_PERI { @ SRAMDMY6_PERI is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SRAMDMY6_PERI     
}
// CSR.R.1 is checked by CSR.R.1:SBDDMY
CSR.R.1:SBDDMY { @ SBDDMY is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND SBDDMY     
}
// CSR.R.1 is checked by CSR.R.1:MATCHING
CSR.R.1:MATCHING { @ MATCHING is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MATCHING     
}
// CSR.R.1 is checked by CSR.R.1:M1_real
CSR.R.1:M1_real { @ M1_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M1_real     
}
// CSR.R.1 is checked by CSR.R.1:M1i
CSR.R.1:M1i { @ M1i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M1i     
}
// CSR.R.1 is checked by CSR.R.1:DUM1
CSR.R.1:DUM1 { @ DUM1 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM1     
}
// CSR.R.1 is checked by CSR.R.1:DUM1_O
CSR.R.1:DUM1_O { @ DUM1_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM1_O     
}
// CSR.R.1 is checked by CSR.R.1:M2_real
CSR.R.1:M2_real { @ M2_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M2_real     
}
// CSR.R.1 is checked by CSR.R.1:M2i
CSR.R.1:M2i { @ M2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M2i     
}
// CSR.R.1 is checked by CSR.R.1:DUM2
CSR.R.1:DUM2 { @ DUM2 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM2     
}
// CSR.R.1 is checked by CSR.R.1:DUM2_O
CSR.R.1:DUM2_O { @ DUM2_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM2_O     
}
// CSR.R.1 is checked by CSR.R.1:M3_real
CSR.R.1:M3_real { @ M3_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M3_real     
}
// CSR.R.1 is checked by CSR.R.1:M3i
CSR.R.1:M3i { @ M3i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M3i     
}
// CSR.R.1 is checked by CSR.R.1:DUM3
CSR.R.1:DUM3 { @ DUM3 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM3     
}
// CSR.R.1 is checked by CSR.R.1:DUM3_O
CSR.R.1:DUM3_O { @ DUM3_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM3_O     
}
// CSR.R.1 is checked by CSR.R.1:M4_real
CSR.R.1:M4_real { @ M4_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M4_real     
}
// CSR.R.1 is checked by CSR.R.1:M4i
CSR.R.1:M4i { @ M4i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M4i     
}
// CSR.R.1 is checked by CSR.R.1:DUM4
CSR.R.1:DUM4 { @ DUM4 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM4     
}
// CSR.R.1 is checked by CSR.R.1:DUM4_O
CSR.R.1:DUM4_O { @ DUM4_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM4_O     
}
// CSR.R.1 is checked by CSR.R.1:M5_real
CSR.R.1:M5_real { @ M5_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M5_real     
}
// CSR.R.1 is checked by CSR.R.1:M5i
CSR.R.1:M5i { @ M5i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M5i     
}
// CSR.R.1 is checked by CSR.R.1:DUM5
CSR.R.1:DUM5 { @ DUM5 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM5     
}
// CSR.R.1 is checked by CSR.R.1:DUM5_O
CSR.R.1:DUM5_O { @ DUM5_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM5_O     
}
// CSR.R.1 is checked by CSR.R.1:M6_real
CSR.R.1:M6_real { @ M6_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M6_real     
}
// CSR.R.1 is checked by CSR.R.1:M6i
CSR.R.1:M6i { @ M6i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M6i     
}
// CSR.R.1 is checked by CSR.R.1:DUM6
CSR.R.1:DUM6 { @ DUM6 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM6     
}
// CSR.R.1 is checked by CSR.R.1:DUM6_O
CSR.R.1:DUM6_O { @ DUM6_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM6_O     
}
// CSR.R.1 is checked by CSR.R.1:M7_real
CSR.R.1:M7_real { @ M7_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M7_real     
}
// CSR.R.1 is checked by CSR.R.1:M7i
CSR.R.1:M7i { @ M7i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M7i     
}
// CSR.R.1 is checked by CSR.R.1:DUM7
CSR.R.1:DUM7 { @ DUM7 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM7     
}
// CSR.R.1 is checked by CSR.R.1:DUM7_O
CSR.R.1:DUM7_O { @ DUM7_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM7_O     
}
// CSR.R.1 is checked by CSR.R.1:M8_real
CSR.R.1:M8_real { @ M8_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M8_real     
}
// CSR.R.1 is checked by CSR.R.1:M8i
CSR.R.1:M8i { @ M8i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M8i     
}
// CSR.R.1 is checked by CSR.R.1:DUM8
CSR.R.1:DUM8 { @ DUM8 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM8     
}
// CSR.R.1 is checked by CSR.R.1:DUM8_O
CSR.R.1:DUM8_O { @ DUM8_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM8_O     
}
// CSR.R.1 is checked by CSR.R.1:M9_real
CSR.R.1:M9_real { @ M9_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M9_real     
}
// CSR.R.1 is checked by CSR.R.1:M9i
CSR.R.1:M9i { @ M9i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M9i     
}
// CSR.R.1 is checked by CSR.R.1:DUM9
CSR.R.1:DUM9 { @ DUM9 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM9     
}
// CSR.R.1 is checked by CSR.R.1:DUM9_O
CSR.R.1:DUM9_O { @ DUM9_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUM9_O     
}
// CSR.R.1 is checked by CSR.R.1:MD_real
CSR.R.1:MD_real { @ MD_real is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MD_real     
}
// CSR.R.1 is checked by CSR.R.1:MDi
CSR.R.1:MDi { @ MDi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MDi     
}
// CSR.R.1 is checked by CSR.R.1:DUMD
CSR.R.1:DUMD { @ DUMD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUMD     
}
// CSR.R.1 is checked by CSR.R.1:DUMD_O
CSR.R.1:DUMD_O { @ DUMD_O is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DUMD_O     
}
// CSR.R.1 is checked by CSR.R.1:VIA1i
CSR.R.1:VIA1i { @ VIA1i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA1i     
}
// CSR.R.1 is checked by CSR.R.1:VIA2i
CSR.R.1:VIA2i { @ VIA2i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA2i     
}
// CSR.R.1 is checked by CSR.R.1:VIA3i
CSR.R.1:VIA3i { @ VIA3i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA3i     
}
// CSR.R.1 is checked by CSR.R.1:VIA4i
CSR.R.1:VIA4i { @ VIA4i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA4i     
}
// CSR.R.1 is checked by CSR.R.1:VIA5i
CSR.R.1:VIA5i { @ VIA5i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA5i     
}
// CSR.R.1 is checked by CSR.R.1:VIA6i
CSR.R.1:VIA6i { @ VIA6i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA6i     
}
// CSR.R.1 is checked by CSR.R.1:VIA7i
CSR.R.1:VIA7i { @ VIA7i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA7i     
}
// CSR.R.1 is checked by CSR.R.1:VIA8i
CSR.R.1:VIA8i { @ VIA8i is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIA8i     
}
// CSR.R.1 is checked by CSR.R.1:VIADi
CSR.R.1:VIADi { @ VIADi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND VIADi     
}
// CSR.R.1 is checked by CSR.R.1:ODi
CSR.R.1:ODi { @ ODi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ODi     
}
// CSR.R.1 is checked by CSR.R.1:ODi_OTHERS
CSR.R.1:ODi_OTHERS { @ ODi_OTHERS is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ODi_OTHERS     
}
// CSR.R.1 is checked by CSR.R.1:ODi_RFDRAIN
CSR.R.1:ODi_RFDRAIN { @ ODi_RFDRAIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ODi_RFDRAIN     
}
// CSR.R.1 is checked by CSR.R.1:DOD
CSR.R.1:DOD { @ DOD is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DOD     
}
// CSR.R.1 is checked by CSR.R.1:POi
CSR.R.1:POi { @ POi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND POi     
}
// CSR.R.1 is checked by CSR.R.1:POi_OTHERS
CSR.R.1:POi_OTHERS { @ POi_OTHERS is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND POi_OTHERS     
}
// CSR.R.1 is checked by CSR.R.1:DPO
CSR.R.1:DPO { @ DPO is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND DPO     
}
// CSR.R.1 is checked by CSR.R.1:PSPOi
CSR.R.1:PSPOi { @ PSPOi is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND PSPOi     
}
// CSR.R.1 is checked by CSR.R.1:RES200
CSR.R.1:RES200 { @ RES200 is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND RES200     
}
// CSR.R.1 is checked by CSR.R.1:ESDIMP
CSR.R.1:ESDIMP { @ ESDIMP is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND ESDIMP     
}
// CSR.R.1 is checked by CSR.R.1:M1_PIN
CSR.R.1:M1_PIN { @ M1_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M1_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M1_PIN_TEXT
CSR.R.1:M1_PIN_TEXT { @ M1_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M1_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M2_PIN
CSR.R.1:M2_PIN { @ M2_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M2_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M2_PIN_TEXT
CSR.R.1:M2_PIN_TEXT { @ M2_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M2_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M3_PIN
CSR.R.1:M3_PIN { @ M3_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M3_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M3_PIN_TEXT
CSR.R.1:M3_PIN_TEXT { @ M3_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M3_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M4_PIN
CSR.R.1:M4_PIN { @ M4_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M4_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M4_PIN_TEXT
CSR.R.1:M4_PIN_TEXT { @ M4_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M4_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M5_PIN
CSR.R.1:M5_PIN { @ M5_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M5_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M5_PIN_TEXT
CSR.R.1:M5_PIN_TEXT { @ M5_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M5_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M6_PIN
CSR.R.1:M6_PIN { @ M6_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M6_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M6_PIN_TEXT
CSR.R.1:M6_PIN_TEXT { @ M6_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M6_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M7_PIN
CSR.R.1:M7_PIN { @ M7_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M7_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M7_PIN_TEXT
CSR.R.1:M7_PIN_TEXT { @ M7_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M7_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M8_PIN
CSR.R.1:M8_PIN { @ M8_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M8_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M8_PIN_TEXT
CSR.R.1:M8_PIN_TEXT { @ M8_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M8_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:M9_PIN
CSR.R.1:M9_PIN { @ M9_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M9_PIN     
}
// CSR.R.1 is checked by CSR.R.1:M9_PIN_TEXT
CSR.R.1:M9_PIN_TEXT { @ M9_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND M9_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:MD_PIN
CSR.R.1:MD_PIN { @ MD_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MD_PIN     
}
// CSR.R.1 is checked by CSR.R.1:MD_PIN_TEXT
CSR.R.1:MD_PIN_TEXT { @ MD_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND MD_PIN_TEXT     
}
// CSR.R.1 is checked by CSR.R.1:AP_PIN
CSR.R.1:AP_PIN { @ AP_PIN is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND AP_PIN     
}
// CSR.R.1 is checked by CSR.R.1:AP_PIN_TEXT
CSR.R.1:AP_PIN_TEXT { @ AP_PIN_TEXT is not allowed inside the empty area of chip corner.
  EMPTY_AREA AND AP_PIN_TEXT     
}

#ENDIF
// Chip corner stress relief check
CC_CO = (CO AND CSRDMY) NOT VIA_EXD
CC_M1 = M1 AND CSRDMY
CC_V1 = (VIA1 AND CSRDMY) NOT VIA_EXD
CC_M2 = M2 AND CSRDMY
CC_V2 = (VIA2 AND CSRDMY) NOT VIA_EXD
CC_M3 = M3 AND CSRDMY
CC_V3 = (VIA3 AND CSRDMY) NOT VIA_EXD
CC_M4 = M4 AND CSRDMY
CC_V4 = (VIA4 AND CSRDMY) NOT VIA_EXD
CC_M5 = M5 AND CSRDMY
CC_V5 = (VIA5 AND CSRDMY) NOT VIA_EXD
CC_M6 = M6 AND CSRDMY
CC_V6 = (VIA6 AND CSRDMY) NOT VIA_EXD
CC_M7 = M7 AND CSRDMY
CC_V7 = (VIA7 AND CSRDMY) NOT VIA_EXD
CC_M8 = M8 AND CSRDMY
CC_V8 = (VIA8 AND CSRDMY) NOT VIA_EXD
CC_M9 = M9 AND CSRDMY
CC_VD = (VIAD AND CSRDMY) NOT VIA_EXD
// CSR.R.2 is checked by CSR.R.2:A
CSR.R.2:A { @ CSR structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD 
  CSRDMY NOT INTERACT ODi 
  CSRDMY NOT INTERACT PPi 
  CSRDMY NOT INTERACT M1x 
  CSRDMY NOT INTERACT M2x 
  CSRDMY NOT INTERACT M3x 
  CSRDMY NOT INTERACT M4x 
  CSRDMY NOT INTERACT M5x 
  CSRDMY NOT INTERACT M6x 
  CSRDMY NOT INTERACT M7x 
  CSRDMY NOT INTERACT M8x 
  CSRDMY NOT INTERACT M9x 
  CSRDMY NOT ENCLOSE COi 
  CSRDMY NOT ENCLOSE VIA1i 
  CSRDMY NOT ENCLOSE VIA2i 
  CSRDMY NOT ENCLOSE VIA3i 
  CSRDMY NOT ENCLOSE VIA4i 
  CSRDMY NOT ENCLOSE VIA5i 
  CSRDMY NOT ENCLOSE VIA6i 
  CSRDMY NOT ENCLOSE VIA7i 
  CSRDMY NOT ENCLOSE VIA8i 
}
// CSR.R.2 is checked by CSR.R.2:C
CSR.R.2:C { @ CSR structure must be covered with CSRDMY
  SR_EDGE NOT INTERACT CSRDMY
}
    CC_MH1all = HOLES (SIZE CC_M1 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH1 = CC_MH1all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH1_L = CC_MH1all INTERACT LSLOT 
    CC_MH2all = HOLES (SIZE CC_M2 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH2 = CC_MH2all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH2_L = CC_MH2all INTERACT LSLOT 
    CC_MH3all = HOLES (SIZE CC_M3 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH3 = CC_MH3all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH3_L = CC_MH3all INTERACT LSLOT 
    CC_MH4all = HOLES (SIZE CC_M4 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH4 = CC_MH4all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH4_L = CC_MH4all INTERACT LSLOT 
    CC_MH5all = HOLES (SIZE CC_M5 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH5 = CC_MH5all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH5_L = CC_MH5all INTERACT LSLOT 
    CC_MH6all = HOLES (SIZE CC_M6 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH6 = CC_MH6all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH6_L = CC_MH6all INTERACT LSLOT 
    CC_MH7all = HOLES (SIZE CC_M7 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH7 = CC_MH7all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH7_L = CC_MH7all INTERACT LSLOT 
    CC_MH8all = HOLES (SIZE CC_M8 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH8 = CC_MH8all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH8_L = CC_MH8all INTERACT LSLOT 
    CC_MH9all = HOLES (SIZE CC_M9 BY 0.6 UNDEROVER)   // filter non-check metal
    CC_MH9 = CC_MH9all NOT INTERACT LSLOT             // filter LMARK HOLE 
    CC_MH9_L = CC_MH9all INTERACT LSLOT 
#IFDEF UTM
// CSR.R.2 is checked by CSR.R.2:B
CSR.R.2:B { @ M1~M9 must be stacked and coincident the edge .
  XOR CC_M1 CC_M2 
  XOR CC_M2 CC_M3 
  XOR CC_M3 CC_M4 
  XOR CC_M4 CC_M5 
  XOR CC_M5 CC_M6 
  XOR CC_M6 CC_M7 
  XOR CC_M7 CC_M8 
  NOT CC_M8 CC_M9  // Top metal in L-mark seal-ring corner is solid
}
// CSR.R.2 is checked by CSR.R.2:D
CSR.R.2:D { @ M1~M9 at same level have a exactive spacing value ^CSR_R_2
  CC_MH1pre = HOLES (SIZE CC_M1 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH1 = CC_MH1pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH1 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH1 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH2pre = HOLES (SIZE CC_M2 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH2 = CC_MH2pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH2 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH2 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH3pre = HOLES (SIZE CC_M3 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH3 = CC_MH3pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH3 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH3 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH4pre = HOLES (SIZE CC_M4 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH4 = CC_MH4pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH4 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH4 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH5pre = HOLES (SIZE CC_M5 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH5 = CC_MH5pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH5 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH5 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH6pre = HOLES (SIZE CC_M6 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH6 = CC_MH6pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH6 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH6 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH7pre = HOLES (SIZE CC_M7 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH7 = CC_MH7pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH7 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH7 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH8pre = HOLES (SIZE CC_M8 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH8 = CC_MH8pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH8 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH8 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
}
#ELSE



#IFDEF LmarkSealringCorner
// CSR.R.2 is checked by CSR.R.2:B
CSR.R.2:B { @ M1~M9 must be stacked and coincident the edge .
  XOR CC_M1 CC_M2 
  XOR CC_M2 CC_M3 
  XOR CC_M3 CC_M4 
  XOR CC_M4 CC_M5 
  XOR CC_M5 CC_M6 
  XOR CC_M6 CC_M7 
  XOR CC_M7 CC_M8 
  NOT CC_M8 CC_M9  // Top metal in L-mark seal-ring corner is solid
}
// CSR.R.2 is checked by CSR.R.2:D
CSR.R.2:D { @ M1~M9 at same level have a exactive spacing value ^CSR_R_2
  CC_MH1pre = HOLES (SIZE CC_M1 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH1 = CC_MH1pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH1 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH1 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH2pre = HOLES (SIZE CC_M2 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH2 = CC_MH2pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH2 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH2 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH3pre = HOLES (SIZE CC_M3 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH3 = CC_MH3pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH3 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH3 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH4pre = HOLES (SIZE CC_M4 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH4 = CC_MH4pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH4 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH4 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH5pre = HOLES (SIZE CC_M5 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH5 = CC_MH5pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH5 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH5 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH6pre = HOLES (SIZE CC_M6 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH6 = CC_MH6pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH6 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH6 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH7pre = HOLES (SIZE CC_M7 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH7 = CC_MH7pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH7 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH7 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH8pre = HOLES (SIZE CC_M8 BY 0.6 UNDEROVER)      // filter non-check metal
  CC_MH8 = CC_MH8pre NOT INTERACT (HOLES (M9i AND LMARK) EMPTY) // filter LMARK 
  INT CC_MH8 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH8 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
}
#ELSE
// CSR.R.2 is checked by CSR.R.2:B
CSR.R.2:B { @ M1~M9 must be stacked and coincident the edge .
  XOR CC_M1 CC_M2 
  XOR CC_M2 CC_M3 
  XOR CC_M3 CC_M4 
  XOR CC_M4 CC_M5 
  XOR CC_M5 CC_M6 
  XOR CC_M6 CC_M7 
  XOR CC_M7 CC_M8 
  XOR CC_M8 CC_M9 
}
// CSR.R.2 is checked by CSR.R.2:D
CSR.R.2:D { @ M1~M9 at same level have a exactive spacing value ^CSR_R_2
  CC_MH1 = HOLES CC_M1       
  INT CC_MH1 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH1 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH2 = HOLES CC_M2       
  INT CC_MH2 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH2 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH3 = HOLES CC_M3       
  INT CC_MH3 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH3 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH4 = HOLES CC_M4       
  INT CC_MH4 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH4 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH5 = HOLES CC_M5       
  INT CC_MH5 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH5 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH6 = HOLES CC_M6       
  INT CC_MH6 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH6 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH7 = HOLES CC_M7       
  INT CC_MH7 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH7 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH8 = HOLES CC_M8       
  INT CC_MH8 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH8 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
  CC_MH9 = HOLES CC_M9       
  INT CC_MH9 < CSR_R_2 ABUT < 90 PARALLEL ONLY REGION
  SIZE CC_MH9 BY CSR_R_2 /2 UNDEROVER TRUNCATE CSR_R_2 /2
}
#ENDIF
#ENDIF




CSR.S.1 { @ CO space >= ^CSR_S_1 um.
   EXT CC_CO < CSR_S_1 ABUT < 90 SINGULAR REGION  
}
CSR.S.2 { @ VIA1~VIA6 space at the same level >= ^CSR_S_2 um.
   EXT CC_V1 < CSR_S_2 ABUT < 90 SINGULAR REGION 
   EXT CC_V2 < CSR_S_2 ABUT < 90 SINGULAR REGION 
   EXT CC_V3 < CSR_S_2 ABUT < 90 SINGULAR REGION 
   EXT CC_V4 < CSR_S_2 ABUT < 90 SINGULAR REGION 
   EXT CC_V5 < CSR_S_2 ABUT < 90 SINGULAR REGION 
   EXT CC_V6 < CSR_S_2 ABUT < 90 SINGULAR REGION 
}
CSR.S.3 { @ Space between two VIA7/VIA8/VIAD >= ^CSR_S_3 um.
   EXT CC_V7 < CSR_S_3 ABUT < 90 SINGULAR REGION 
   EXT CC_V8 < CSR_S_3 ABUT < 90 SINGULAR REGION 
   EXT CC_VD < CSR_S_3 ABUT < 90 SINGULAR REGION 
}

// CSR.EN.1U can not be checked by DRC
// CSR.EN.2U can not be checked by DRC
// CSR.EN.3U can not be checked by DRC
// CSR.R.3 can not be checked by DRC
LMARK_METAL_CSR = LMARK_METAL AND CSRDMY // L-mark in CSR
LMARK_SLOT_CSR = LSLOT AND CSRDMY  // L shaped oxide in L-mark metal
LMARK_MS_CSR = LMARK_METAL_CSR OR LMARK_SLOT_CSR

#IFDEF LmarkSealringCorner

CSR.W.1 { @ Width of L-slot = ^CSR_W_1
   SIZE LMARK_SLOT_CSR BY CSR_W_1/2 UNDEROVER
   INT LMARK_SLOT_CSR < CSR_W_1 ABUT < 90 ANGLED == 0 REGION
}
// CSR.W.2a is checked by CSR.W.2
// CSR.W.2b is checked by CSR.W.2
CSR.W.2 { @ Width of 45 degree corner of L-slot, >= ^CSR_W_2_1 um <= ^CSR_W_2_2 um
   X = ANGLE LMARK_SLOT_CSR == 45
   Y = EXPAND EDGE X INSIDE BY CSR_W_2_2+GRID    
   Y OUTSIDE LMARK_METAL_CSR
   INT LMARK_SLOT_CSR < CSR_W_2_1 ABUT < 90 ANGLED == 2 REGION
}
// CSR.W.3 is checked by related rules [CO.W.2 and {VIAx.W.2/VIAy.W.2/VIAn.W.2}]
// CSR.L.1a is checked by CSR.L.1
// CSR.L.1b is checked by CSR.L.1
CSR.L.1 { @ Length of L-slot, >= ^CSR_L_1_1 um <= ^CSR_L_1_2 um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 135
   LENGTH X < CSR_L_1_1  
   LENGTH X > CSR_L_1_2 
   Y = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 225
   LENGTH Y < CSR_L_1_1  
   LENGTH Y > CSR_L_1_2 
}  
#IFDEF WLCSPSealringCorner
#IFDEF UTM
// CSR.EN.4a is checked by CSR.EN.4	
// CSR.EN.4b is checked by CSR.EN.4	
CSR.EN.4 { @ L-mark metal in CSR enclosure of L-slot [in the direction of L-slot length](Except WLCSP sealring region) >= ^CSR_EN_4_1 um <= ^CSR_EN_4_2 um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 90
   ENC X LMARK_MS_CSR < CSR_EN_4_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_MS_CSR > CSR_EN_4_2 < 100 ABUT < 90 OPPOSITE REGION
}
#ELSE

// CSR.EN.4.1a is checked by CSR.EN.4.1	
// CSR.EN.4.1b is checked by CSR.EN.4.1	
CSR.EN.4.1 { @ L-mark metal in CSR enclosure of L-slot [in the direction of L-slot length](for WLCSP sealring region) >= ^CSR_EN_4_1_1 um <= ^CSR_EN_4_1_2 um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 90
   ENC X LMARK_MS_CSR < CSR_EN_4_1_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_MS_CSR > CSR_EN_4_1_2 < 100 ABUT < 90 OPPOSITE REGION
}
#ENDIF  //UTM

#ELSE
// CSR.EN.4a is checked by CSR.EN.4	
// CSR.EN.4b is checked by CSR.EN.4	
CSR.EN.4 { @ L-mark metal in CSR enclosure of L-slot [in the direction of L-slot length](Except WLCSP sealring region) >= ^CSR_EN_4_1 um <= ^CSR_EN_4_2 um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 90
   ENC X LMARK_MS_CSR < CSR_EN_4_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_MS_CSR > CSR_EN_4_2 < 100 ABUT < 90 OPPOSITE REGION
}
#ENDIF   //WLCSPSealringCorner
#IFDEF WLCSPSealringCorner
TM_SR_EXT = (EXTENT (M9i OR MDi)) INTERACT CSRDMY
TM_SR_CORNER_A = INT TM_SR_EXT <= CSR_EN_5_1_L1 ABUT == 90 REGION INTERSECTING ONLY
TM_SR_CORNER_B = INT TM_SR_EXT <= CSR_EN_5_1_L2 ABUT == 90 REGION INTERSECTING ONLY
// CSR.EN.5.1 is checked by CSR.EN.5.1:M1
// CSR.EN.5.1a is checked by CSR.EN.5.1:M1
// CSR.EN.5.1b is checked by CSR.EN.5.1:M1
CSR.EN.5.1:M1 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M1i
   TM_SR_CORNER_B NOT INTERACT M1i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:M2
// CSR.EN.5.1a is checked by CSR.EN.5.1:M2
// CSR.EN.5.1b is checked by CSR.EN.5.1:M2
CSR.EN.5.1:M2 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M2i
   TM_SR_CORNER_B NOT INTERACT M2i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:M3
// CSR.EN.5.1a is checked by CSR.EN.5.1:M3
// CSR.EN.5.1b is checked by CSR.EN.5.1:M3
CSR.EN.5.1:M3 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M3i
   TM_SR_CORNER_B NOT INTERACT M3i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:M4
// CSR.EN.5.1a is checked by CSR.EN.5.1:M4
// CSR.EN.5.1b is checked by CSR.EN.5.1:M4
CSR.EN.5.1:M4 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M4i
   TM_SR_CORNER_B NOT INTERACT M4i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:M5
// CSR.EN.5.1a is checked by CSR.EN.5.1:M5
// CSR.EN.5.1b is checked by CSR.EN.5.1:M5
CSR.EN.5.1:M5 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M5i
   TM_SR_CORNER_B NOT INTERACT M5i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:M6
// CSR.EN.5.1a is checked by CSR.EN.5.1:M6
// CSR.EN.5.1b is checked by CSR.EN.5.1:M6
CSR.EN.5.1:M6 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M6i
   TM_SR_CORNER_B NOT INTERACT M6i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:M7
// CSR.EN.5.1a is checked by CSR.EN.5.1:M7
// CSR.EN.5.1b is checked by CSR.EN.5.1:M7
CSR.EN.5.1:M7 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M7i
   TM_SR_CORNER_B NOT INTERACT M7i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:M8
// CSR.EN.5.1a is checked by CSR.EN.5.1:M8
// CSR.EN.5.1b is checked by CSR.EN.5.1:M8
CSR.EN.5.1:M8 { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND M8i
   TM_SR_CORNER_B NOT INTERACT M8i
}
// CSR.EN.5.1 is checked by CSR.EN.5.1:LMARK
CSR.EN.5.1:LMARK { @ An empty isosceles triangle area must exist butted to the WLCSP sealring outside corner.
   TM_SR_CORNER_A AND LMARK_METAL
   TM_SR_CORNER_B NOT INTERACT LMARK_METAL
}
#ELSE
// CSR.EN.5a is checked by CSR.EN.5
// CSR.EN.5b is checked by CSR.EN.5
CSR.EN.5 { @ L-mark metal in CSR enclosure of L-slot 
           @ [perpendicular to the direction of the L-slot length]
       @ (Except WLCSP sealring region) >= ^CSR_EN_5_1 um <= ^CSR_EN_5_2 um
   X = CONVEX EDGE LMARK_SLOT_CSR ANGLE1 == 90 ANGLE2 == 225
   ENC X LMARK_MS_CSR < CSR_EN_5_1 ABUT < 90 OPPOSITE REGION
   ENC X LMARK_MS_CSR > CSR_EN_5_2 < 100 ABUT < 90 OPPOSITE REGION
}
#ENDIF

CSR.EN.6 { @ Metal enclosure of (CO,VIAx,VIAy,VIAn) around L-slot >= ^CSR_EN_6 um
   EXT CC_MH1_L SR_CO < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   CC_MH1_L AND SR_CO    
   EXT CC_MH2_L SR_VIA1 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   CC_MH2_L AND SR_VIA1
   EXT CC_MH3_L SR_VIA2 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   CC_MH3_L AND SR_VIA2
   EXT CC_MH4_L SR_VIA3 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   CC_MH4_L AND SR_VIA3
   EXT CC_MH5_L SR_VIA4 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   CC_MH5_L AND SR_VIA4
   EXT CC_MH6_L SR_VIA5 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   CC_MH6_L AND SR_VIA5
   EXT CC_MH7_L SR_VIA6 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   CC_MH7_L AND SR_VIA6
   EXT LMARK_SLOT_CSR SR_VIA7 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_VIA7	
   EXT LMARK_SLOT_CSR SR_VIA8 < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_VIA8	
   EXT LMARK_SLOT_CSR SR_VIAD < CSR_EN_6 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND SR_VIAD	
}



CSR.EN.7 { @ Metal enclosure by L-mark metal in CSR around L-slot >= ^CSR_EN_7 um
   EXT LMARK_SLOT_CSR M1i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M1i
   EXT LMARK_SLOT_CSR M2i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M2i
   EXT LMARK_SLOT_CSR M3i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M3i
   EXT LMARK_SLOT_CSR M4i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M4i
   EXT LMARK_SLOT_CSR M5i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M5i
   EXT LMARK_SLOT_CSR M6i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M6i
   EXT LMARK_SLOT_CSR M7i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M7i
   EXT LMARK_SLOT_CSR M8i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   LMARK_SLOT_CSR AND M8i
   X = LMARK_SLOT_CSR INTERACT MDi
   EXT X M9i < CSR_EN_7 ABUT < 90 OPPOSITE REGION
   X AND M9i
}
#ENDIF





// Seal-Ring Rule Check
//=====================

#IFDEF LmarkSealringCorner
SR_MS1 = (INT SR_M1 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW1 = (SR_M1 NOT SR_MS1) NOT CSRDMY
SR_MS2 = (INT SR_M2 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW2 = (SR_M2 NOT SR_MS2) NOT CSRDMY
SR_MS3 = (INT SR_M3 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW3 = (SR_M3 NOT SR_MS3) NOT CSRDMY
SR_MS4 = (INT SR_M4 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW4 = (SR_M4 NOT SR_MS4) NOT CSRDMY
SR_MS5 = (INT SR_M5 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW5 = (SR_M5 NOT SR_MS5) NOT CSRDMY
SR_MS6 = (INT SR_M6 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW6 = (SR_M6 NOT SR_MS6) NOT CSRDMY
SR_MS7 = (INT SR_M7 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW7 = (SR_M7 NOT SR_MS7) NOT CSRDMY
SR_MS8 = (INT SR_M8 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW8 = (SR_M8 NOT SR_MS8) NOT CSRDMY
SR_MS9 = (INT SR_M9 <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW9 = (SR_M9 NOT SR_MS9) NOT CSRDMY
SR_MS10 = (INT SR_MD <= 5 ABUT < 90 REGION) NOT CSRDMY
SR_MW10 = (SR_MD NOT SR_MS10) NOT CSRDMY
#ELSE
SR_MS1 = INT SR_M1 <= 5 ABUT < 90 REGION 
SR_MW1 = SR_M1 NOT SR_MS1
SR_MS2 = INT SR_M2 <= 5 ABUT < 90 REGION 
SR_MW2 = SR_M2 NOT SR_MS2
SR_MS3 = INT SR_M3 <= 5 ABUT < 90 REGION 
SR_MW3 = SR_M3 NOT SR_MS3
SR_MS4 = INT SR_M4 <= 5 ABUT < 90 REGION 
SR_MW4 = SR_M4 NOT SR_MS4
SR_MS5 = INT SR_M5 <= 5 ABUT < 90 REGION 
SR_MW5 = SR_M5 NOT SR_MS5
SR_MS6 = INT SR_M6 <= 5 ABUT < 90 REGION 
SR_MW6 = SR_M6 NOT SR_MS6
SR_MS7 = INT SR_M7 <= 5 ABUT < 90 REGION 
SR_MW7 = SR_M7 NOT SR_MS7
SR_MS8 = INT SR_M8 <= 5 ABUT < 90 REGION 
SR_MW8 = SR_M8 NOT SR_MS8
SR_MS9 = INT SR_M9 <= 5 ABUT < 90 REGION 
SR_MW9 = SR_M9 NOT SR_MS9
SR_MS10 = INT SR_MD <= 5 ABUT < 90 REGION 
SR_MW10 = SR_MD NOT SR_MS10
#ENDIF
#IFDEF MSRF
SR:WARNING1 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
  SEALRING NOT ODi 
  SEALRING NOT PPi 
  SEALRING NOT M1x 
  SEALRING NOT M2x 
  SEALRING NOT M3x 
  SEALRING NOT M4x 
  SEALRING NOT M5x 
  SEALRING NOT M6x 
  SEALRING NOT M7x 
  SR_M1 NOT ENCLOSE COi 
  SR_M2 NOT ENCLOSE VIA1i 
  SR_M3 NOT ENCLOSE VIA2i 
  SR_M4 NOT ENCLOSE VIA3i 
  SR_M5 NOT ENCLOSE VIA4i 
  SR_M6 NOT ENCLOSE VIA5i 
  SR_M7 NOT ENCLOSE VIA6i 
  SR_M8 NOT ENCLOSE VIA7i 
  SR_M9 NOT ENCLOSE VIA8i 
}
#ELSE
#IFDEF WLCSPSealringCorner
#IFDEF UTM
SR:WARNING1 { @ Sealring structure must include Mtop-1~M1/VIAtop~VIA1/CO/PP/OD
  SEALRING NOT ODi 
  SEALRING NOT PPi 
  SEALRING NOT M1x 
  SEALRING NOT M2x 
  SEALRING NOT M3x 
  SEALRING NOT M4x 
  SEALRING NOT M5x 
  SEALRING NOT M6x 
  SEALRING NOT M7x 
  SEALRING NOT M8x 
  SR_M1 NOT ENCLOSE COi 
  SR_M2 NOT ENCLOSE VIA1i 
  SR_M3 NOT ENCLOSE VIA2i 
  SR_M4 NOT ENCLOSE VIA3i 
  SR_M5 NOT ENCLOSE VIA4i 
  SR_M6 NOT ENCLOSE VIA5i 
  SR_M7 NOT ENCLOSE VIA6i 
  SR_M8 NOT ENCLOSE VIA7i 
  SR_M9 NOT ENCLOSE VIA8i 
}
#ELSE
SR:WARNING1 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
  SEALRING NOT ODi 
  SEALRING NOT PPi 
  SEALRING NOT M1x 
  SEALRING NOT M2x 
  SEALRING NOT M3x 
  SEALRING NOT M4x 
  SEALRING NOT M5x 
  SEALRING NOT M6x 
  SEALRING NOT M7x 
  SEALRING NOT M8x 
  SEALRING NOT M9x 
  SR_M1 NOT ENCLOSE COi 
  SR_M2 NOT ENCLOSE VIA1i 
  SR_M3 NOT ENCLOSE VIA2i 
  SR_M4 NOT ENCLOSE VIA3i 
  SR_M5 NOT ENCLOSE VIA4i 
  SR_M6 NOT ENCLOSE VIA5i 
  SR_M7 NOT ENCLOSE VIA6i 
  SR_M8 NOT ENCLOSE VIA7i 
  SR_M9 NOT ENCLOSE VIA8i 
}
#ENDIF // UTM
#ELSE


SR:WARNING1 { @ Sealring structure must include Mtop~M1/VIAtop~VIA1/CO/PP/OD
  SEALRING NOT ODi 
  SEALRING NOT PPi 
  SEALRING NOT M1x 
  SEALRING NOT M2x 
  SEALRING NOT M3x 
  SEALRING NOT M4x 
  SEALRING NOT M5x 
  SEALRING NOT M6x 
  SEALRING NOT M7x 
  SEALRING NOT M8x 
  SEALRING NOT M9x 
  SR_M1 NOT ENCLOSE COi 
  SR_M2 NOT ENCLOSE VIA1i 
  SR_M3 NOT ENCLOSE VIA2i 
  SR_M4 NOT ENCLOSE VIA3i 
  SR_M5 NOT ENCLOSE VIA4i 
  SR_M6 NOT ENCLOSE VIA5i 
  SR_M7 NOT ENCLOSE VIA6i 
  SR_M8 NOT ENCLOSE VIA7i 
  SR_M9 NOT ENCLOSE VIA8i 
}
#ENDIF
#ENDIF


#IFDEF FULL_CHIP
SR.S.1 { @ Width of assembly isolation >= ^SR_S_1 um
  ISOR AND DNWi
  ISOR AND NWi
  (ISOR AND POi) NOT INSIDE CDUDMY
  ISOR AND DPO
  (ISOR AND ODi) NOT INSIDE CDUDMY
  ISOR AND DOD
  ISOR AND CBMi
  ISOR AND CTMi
  (ISOR AND COi) NOT INSIDE CDUDMY
  ISOR AND VIA1i
  ISOR AND VIA2i
  ISOR AND VIA3i
  ISOR AND VIA4i
  ISOR AND VIA5i
  ISOR AND VIA6i
  ISOR AND VIA7i
  ISOR AND VIA8i
  ISOR AND VIADi // For CuRDL
  ISOR AND RVi	 // For AlRDL
  ISOR AND UBMi
  ISOR AND CBDi
  ISOR AND CBi
  ISOR AND CB2i
}

// SR.S.1 is checked by SR.S.1:M1
SR.S.1:M1 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M1i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM1 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M2
SR.S.1:M2 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M2i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM2 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M3
SR.S.1:M3 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M3i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM3 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M4
SR.S.1:M4 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M4i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM4 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M5
SR.S.1:M5 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M5i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM5 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M6
SR.S.1:M6 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M6i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM6 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M7
SR.S.1:M7 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M7i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM7 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M8
SR.S.1:M8 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M8i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM8 AND ISOR
}
// SR.S.1 is checked by SR.S.1:M9
SR.S.1:M9 { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((M9i NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUM9 AND ISOR
}
// SR.S.1 is checked by SR.S.1:MD
SR.S.1:MD { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
            @ 1. Connect circuit to sealring through M1~Mtop if needed for WLCSP sealring 
  ((MDi NOT INTERACT SEALRING) NOT INSIDE CDUDMY) AND ISOR 
  DUMD AND ISOR
}
#IFDEF WLCSPSealringCorner
// SR.S.1 is checked by SR.S.1:AP
SR.S.1:AP { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
	   @ 2. Connect circuit to sealring through AP, it is only allowed connecting to the most inner sealring (AP overlap with CB2 is not allowed)  
  (APi NOT INTERACT SEALRING) AND ISOR
  (APi AND SRCSR) AND CB2i
}
#ELSE
// SR.S.1 is checked by SR.S.1:AP
SR.S.1:AP { @ Width of Assembly isolation >= ^SR_S_1 um, Only M1~Mtop and CDU allowed in assembly isolation region
	   @ 2. Connect circuit to sealring through AP is not allowed  
  APi AND ISOR
}

SR.S.1.1 { @ It is not allowed to use AP-MD to connect circuit and seal-ring for Flip Chip to avoid the encroachment of AP-MD by UBM etch process. (Except WLCSP sealring region) 
  CHIP_UBM = CHIP INTERACT UBMi
  (ISOR INTERACT CHIP_UBM) AND APi
}
#ENDIF // WLCSPSealringCorner
SR.R.1 { @ SEALRING layer is a must if either you add sealring by themselves or metal fuse is used
  CHIP_WISR NOT INTERACT SEALRINGi
  (CHIP_NOSR INTERACT PMDMY) NOT INTERACT SEALRINGi
}
#ENDIF

SR_OD = OD INTERACT SRCSR
HOLE_SR_OD = HOLES SR_OD
CHECK_SR_OD = SR_OD OR HOLE_SR_OD
// SR.EN.1 is checked by SR.EN.1:M1
SR.EN.1:M1 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M1K = (M1 AND SRCSR) AND CHIPx
  SR_M1_C = M1K INSIDE CSRDMY
  HOLE_SR_M1_C = HOLES SR_M1_C
  CHECK_SR_M1_C= SR_M1_C OR HOLE_SR_M1_C
  ENC CHECK_SR_M1_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M1 = HOLES SR_M1
  CHECK_SR_M1 = SR_M1 OR HOLE_SR_M1
  CHECK_SR_M1 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M1 != 45
  A2 = ANGLE CHECK_SR_M1 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M2
SR.EN.1:M2 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M2K = (M2 AND SRCSR) AND CHIPx
  SR_M2_C = M2K INSIDE CSRDMY
  HOLE_SR_M2_C = HOLES SR_M2_C
  CHECK_SR_M2_C= SR_M2_C OR HOLE_SR_M2_C
  ENC CHECK_SR_M2_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M2 = HOLES SR_M2
  CHECK_SR_M2 = SR_M2 OR HOLE_SR_M2
  CHECK_SR_M2 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M2 != 45
  A2 = ANGLE CHECK_SR_M2 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M3
SR.EN.1:M3 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M3K = (M3 AND SRCSR) AND CHIPx
  SR_M3_C = M3K INSIDE CSRDMY
  HOLE_SR_M3_C = HOLES SR_M3_C
  CHECK_SR_M3_C= SR_M3_C OR HOLE_SR_M3_C
  ENC CHECK_SR_M3_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M3 = HOLES SR_M3
  CHECK_SR_M3 = SR_M3 OR HOLE_SR_M3
  CHECK_SR_M3 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M3 != 45
  A2 = ANGLE CHECK_SR_M3 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M4
SR.EN.1:M4 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M4K = (M4 AND SRCSR) AND CHIPx
  SR_M4_C = M4K INSIDE CSRDMY
  HOLE_SR_M4_C = HOLES SR_M4_C
  CHECK_SR_M4_C= SR_M4_C OR HOLE_SR_M4_C
  ENC CHECK_SR_M4_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M4 = HOLES SR_M4
  CHECK_SR_M4 = SR_M4 OR HOLE_SR_M4
  CHECK_SR_M4 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M4 != 45
  A2 = ANGLE CHECK_SR_M4 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M5
SR.EN.1:M5 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M5K = (M5 AND SRCSR) AND CHIPx
  SR_M5_C = M5K INSIDE CSRDMY
  HOLE_SR_M5_C = HOLES SR_M5_C
  CHECK_SR_M5_C= SR_M5_C OR HOLE_SR_M5_C
  ENC CHECK_SR_M5_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M5 = HOLES SR_M5
  CHECK_SR_M5 = SR_M5 OR HOLE_SR_M5
  CHECK_SR_M5 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M5 != 45
  A2 = ANGLE CHECK_SR_M5 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M6
SR.EN.1:M6 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M6K = (M6 AND SRCSR) AND CHIPx
  SR_M6_C = M6K INSIDE CSRDMY
  HOLE_SR_M6_C = HOLES SR_M6_C
  CHECK_SR_M6_C= SR_M6_C OR HOLE_SR_M6_C
  ENC CHECK_SR_M6_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M6 = HOLES SR_M6
  CHECK_SR_M6 = SR_M6 OR HOLE_SR_M6
  CHECK_SR_M6 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M6 != 45
  A2 = ANGLE CHECK_SR_M6 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M7
SR.EN.1:M7 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M7K = (M7 AND SRCSR) AND CHIPx
  SR_M7_C = M7K INSIDE CSRDMY
  HOLE_SR_M7_C = HOLES SR_M7_C
  CHECK_SR_M7_C= SR_M7_C OR HOLE_SR_M7_C
  ENC CHECK_SR_M7_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M7 = HOLES SR_M7
  CHECK_SR_M7 = SR_M7 OR HOLE_SR_M7
  CHECK_SR_M7 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M7 != 45
  A2 = ANGLE CHECK_SR_M7 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M8
SR.EN.1:M8 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M8K = (M8 AND SRCSR) AND CHIPx
  SR_M8_C = M8K INSIDE CSRDMY
  HOLE_SR_M8_C = HOLES SR_M8_C
  CHECK_SR_M8_C= SR_M8_C OR HOLE_SR_M8_C
  ENC CHECK_SR_M8_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M8 = HOLES SR_M8
  CHECK_SR_M8 = SR_M8 OR HOLE_SR_M8
  CHECK_SR_M8 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M8 != 45
  A2 = ANGLE CHECK_SR_M8 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:M9
SR.EN.1:M9 { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  M9K = (M9 AND SRCSR) AND CHIPx
  SR_M9_C = M9K INSIDE CSRDMY
  HOLE_SR_M9_C = HOLES SR_M9_C
  CHECK_SR_M9_C= SR_M9_C OR HOLE_SR_M9_C
  ENC CHECK_SR_M9_C CHECK_SR_OD < SR_EN_1 REGION 
  HOLE_SR_M9 = HOLES SR_M9
  CHECK_SR_M9 = SR_M9 OR HOLE_SR_M9
  CHECK_SR_M9 NOT CHECK_SR_OD
  A1 = ANGLE CHECK_SR_M9 != 45
  A2 = ANGLE CHECK_SR_M9 == 45
  ENC A1 CHECK_SR_OD < SR_EN_1 ABUT < 90 OPPOSITE REGION
  ENC A2 CHECK_SR_OD < SR_EN_1-GRID ABUT < 90 REGION
}
// SR.EN.1 is checked by SR.EN.1:MD
SR.EN.1:MD { @ {OD INTERACT SEALRING} enclosure of metal with the outer edge of sealring >= ^SR_EN_1 um
  SR_MD_C = MD INTERACT SRCSR
  HOLE_SR_MD = HOLES SR_MD_C
  CHECK_SR_MD = SR_MD_C OR HOLE_SR_MD
  CHECK_SR_MD NOT CHECK_SR_OD
  E = ENC CHECK_SR_MD CHECK_SR_OD < SR_EN_1 ABUT < 90 REGION 
  G = E COINCIDENT INSIDE EDGE CHIPx
  E WITH EDGE G
}

MM_SR_MS1 = (SR_M1 INTERACT (INT SR_M1 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW1 = (SR_M1 NOT MM_SR_MS1) NOT CSRDMY
MM_SR_MS2 = (SR_M2 INTERACT (INT SR_M2 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW2 = (SR_M2 NOT MM_SR_MS2) NOT CSRDMY
MM_SR_MS3 = (SR_M3 INTERACT (INT SR_M3 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW3 = (SR_M3 NOT MM_SR_MS3) NOT CSRDMY
MM_SR_MS4 = (SR_M4 INTERACT (INT SR_M4 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW4 = (SR_M4 NOT MM_SR_MS4) NOT CSRDMY
MM_SR_MS5 = (SR_M5 INTERACT (INT SR_M5 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW5 = (SR_M5 NOT MM_SR_MS5) NOT CSRDMY
MM_SR_MS6 = (SR_M6 INTERACT (INT SR_M6 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW6 = (SR_M6 NOT MM_SR_MS6) NOT CSRDMY
MM_SR_MS7 = (SR_M7 INTERACT (INT SR_M7 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW7 = (SR_M7 NOT MM_SR_MS7) NOT CSRDMY
MM_SR_MS8 = (SR_M8 INTERACT (INT SR_M8 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW8 = (SR_M8 NOT MM_SR_MS8) NOT CSRDMY
MM_SR_MS9 = (SR_M9 INTERACT (INT SR_M9 <= 3 ABUT < 90 REGION)) NOT CSRDMY
MM_SR_MW9 = (SR_M9 NOT MM_SR_MS9) NOT CSRDMY



SR.CO_VIA:WARNING1 { @ line-co and line-viax must be continuous
  CONVEX EDGE SR_CO ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*CO_W_2
  CONVEX EDGE SR_VIA1 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA1_W_2
  CONVEX EDGE SR_VIA2 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA2_W_2
  CONVEX EDGE SR_VIA3 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA3_W_2
  CONVEX EDGE SR_VIA4 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA4_W_2
  CONVEX EDGE SR_VIA5 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA5_W_2
  CONVEX EDGE SR_VIA6 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA6_W_2
  CONVEX EDGE SR_VIA7 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA7_W_2
  CONVEX EDGE SR_VIA8 ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIA8_W_2
  CONVEX EDGE SR_VIAD ANGLE1 <= 90 ANGLE2 < 180 WITH LENGTH < 2*VIAD_W_2

}
#IFDEF FULL_CHIP
#IFDEF WLCSPSealringCorner
SR.AP:WARNING1 { @ AP is must in seal-ring if AlRDL or AlPad is used ; 
             @ AP enclosure of CB/CBD/CB2 in seal-ring >= 1
  SRCSRx = SRCSR INTERACT (CHIP INTERACT AP) // AlRDL or AlRad is used
  SRx_CB  = CBi  INSIDE SRCSRx
  SRx_CBD = CBDi INSIDE SRCSRx
  SRx_CB2 = CB2i INSIDE SRCSRx
  SRx_RV  = RVi INSIDE SRCSRx
  SRx_AP  = AP INSIDE SRCSRx
  SRx_CB  NOT AP
  SRx_CBD NOT AP
  SRx_RV  NOT AP
  ENC SRx_CB  AP < 1-GRID ABUT < 90 SINGULAR REGION
  ENC SRx_CBD AP < 1-GRID ABUT < 90 SINGULAR REGION
  ENC SRx_RV AP < 1-GRID ABUT < 90 SINGULAR REGION
}
#ELSE
SR.AP:WARNING1 { @ AP is must in seal-ring if AlRDL or AlPad is used ; 
             @ AP enclosure of CB/CBD/CB2 in seal-ring >= 1
  SRCSRx = SRCSR INTERACT (CHIP INTERACT AP) // AlRDL or AlRad is used
  SRx_CB  = CBi  INSIDE SRCSRx
  SRx_CBD = CBDi INSIDE SRCSRx
  SRx_CB2 = CB2i INSIDE SRCSRx
  SRx_RV  = RVi INSIDE SRCSRx
  SRx_AP  = AP INSIDE SRCSRx
  SRx_CB  NOT AP
  SRx_CBD NOT AP
  SRx_CB2 NOT AP
  SRx_RV  NOT AP
  ENC SRx_CB  AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_CBD AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_CB2 AP < 1 ABUT < 90 SINGULAR REGION
  ENC SRx_RV AP < 1 ABUT < 90 SINGULAR REGION
}
#ENDIF // WLCSPSealringCorner
SR.CB2:WARNING1 { @ CB2 is must in seal-ring if AlCu RDL or AlCu fuse is used
  CHIP_ALRDL = CHIP INTERACT ( RVi OR FW_APi)
  CHIP_APMD = CHIP_ALRDL NOT INTERACT MDi
  SR_EDGEx =  SR_EDGE INTERACT CHIP_APMD  
  SR_EDGEx NOT INTERACT CB2i
}

SR.CB:WARNING1 { @ CB is must in seal-ring if wire bond is used 
  CHIP_INT_CB = (CHIP INTERACT CBi) NOT INTERACT UBMi
  SR_EDGEx = SR_EDGE INTERACT CHIP_INT_CB  
  SR_EDGEx NOT INTERACT CBi
}

SR.CBD_RV:WARNING1 { @  CBD is must in seal-ring if flip chip (without AlCu fuse or AlCu RDL) is used
                 @  Either CBD or RV is must in seal-ring if flip chip(with AlCu fuse or AlCu RDL) is used
  CHIP_UBM = CHIP INTERACT UBMi
  CHIP_UBM_1 = CHIP_UBM INTERACT ( RVi OR FW_APi) 
  CHIP_UBM_2 = CHIP_UBM NOT INTERACT ( RVi OR FW_APi) 
  SR_EDGEx1 = SR_EDGE INTERACT CHIP_UBM_1
  SR_EDGEx1 NOT INTERACT (CBDi OR RVi)
  SR_EDGEx2 = SR_EDGE INTERACT CHIP_UBM_2
  SR_EDGEx2 NOT INTERACT CBDi
   
}

SR.UBM:WARNING1 { @ Do not draw UBM on Chip corner stress relief pattern/Seal ring/Assembly isolation  
  SRCSR AND UBMi
}
#ENDIF


//CDU CHECKS
//==========

CDU.R.1 { @ CDUDMY must be inside the assembly isolation beside seal ring.
  CDUDMY NOT INSIDE ISOR 
  ISOR NOT INTERACT CDUDMY  
}
CDU.R.2 { @ OD/POLY/CO/M1 must be inside layer CDUDMY. 
  CDUDMY NOT ENCLOSE ODi
  CDUDMY NOT ENCLOSE POi
  CDUDMY NOT ENCLOSE COi
  CDUDMY NOT ENCLOSE M1i
}

// Latch-Up CHECKS
//================
#IFDEF DISCONNECT_ALL_RESISTOR
NSTPiu = NSTPi NOT EMPTYi
PSTPiu = PSTPi NOT EMPTYi
NSDiu  = NSDc  NOT EMPTYi
PSDiu  = PSDc  NOT EMPTYi
CBiu   = CBi   NOT EMPTYi 
CB2iu  = CB2i  NOT EMPTYi
UBMniu = UBMn NOT EMPTYi
UBMdiu = UBMd NOT EMPTYi
PWR_M1iu_BY_TEXT = M1i WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1i WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1i WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2i WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2i WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2i WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3i WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3i WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3i WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4i WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4i WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4i WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5i WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5i WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5i WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6i WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6i WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6i WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_M7iu_BY_TEXT = M7i WITH TEXT VDD_TEXT M7_PIN_TEXT PRIMARY ONLY
GND_M7iu_BY_TEXT = M7i WITH TEXT VSS_TEXT M7_PIN_TEXT PRIMARY ONLY
PAD_M7iu_BY_TEXT = M7i WITH TEXT PAD_TEXT M7_PIN_TEXT PRIMARY ONLY
PWR_M8iu_BY_TEXT = M8i WITH TEXT VDD_TEXT M8_PIN_TEXT PRIMARY ONLY
GND_M8iu_BY_TEXT = M8i WITH TEXT VSS_TEXT M8_PIN_TEXT PRIMARY ONLY
PAD_M8iu_BY_TEXT = M8i WITH TEXT PAD_TEXT M8_PIN_TEXT PRIMARY ONLY
PWR_M9iu_BY_TEXT = M9i WITH TEXT VDD_TEXT M9_PIN_TEXT PRIMARY ONLY
GND_M9iu_BY_TEXT = M9i WITH TEXT VSS_TEXT M9_PIN_TEXT PRIMARY ONLY
PAD_M9iu_BY_TEXT = M9i WITH TEXT PAD_TEXT M9_PIN_TEXT PRIMARY ONLY
PWR_MDiu_BY_TEXT = MDi WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_BY_TEXT = MDi WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDiu_BY_TEXT = MDi WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APi WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APi WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APi WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ELSE
#IFDEF CONNECT_ALL_RESISTOR 
NSTPiu = NSTPu NOT EMPTYi
PSTPiu = PSTPu NOT EMPTYi
NSDiu  = NSDu  NOT EMPTYi
PSDiu  = PSDu  NOT EMPTYi
CBiu   = CBu   NOT EMPTYi 
CB2iu  = CB2u  NOT EMPTYi
UBMniu = UBMnu NOT EMPTYi
UBMdiu = UBMdu NOT EMPTYi
PWR_M1iu_BY_TEXT = M1u WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1u WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1u WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2u WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2u WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2u WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3u WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3u WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3u WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4u WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4u WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4u WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5u WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5u WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5u WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6u WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6u WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6u WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_M7iu_BY_TEXT = M7u WITH TEXT VDD_TEXT M7_PIN_TEXT PRIMARY ONLY
GND_M7iu_BY_TEXT = M7u WITH TEXT VSS_TEXT M7_PIN_TEXT PRIMARY ONLY
PAD_M7iu_BY_TEXT = M7u WITH TEXT PAD_TEXT M7_PIN_TEXT PRIMARY ONLY
PWR_M8iu_BY_TEXT = M8u WITH TEXT VDD_TEXT M8_PIN_TEXT PRIMARY ONLY
GND_M8iu_BY_TEXT = M8u WITH TEXT VSS_TEXT M8_PIN_TEXT PRIMARY ONLY
PAD_M8iu_BY_TEXT = M8u WITH TEXT PAD_TEXT M8_PIN_TEXT PRIMARY ONLY
PWR_M9iu_BY_TEXT = M9u WITH TEXT VDD_TEXT M9_PIN_TEXT PRIMARY ONLY
GND_M9iu_BY_TEXT = M9u WITH TEXT VSS_TEXT M9_PIN_TEXT PRIMARY ONLY
PAD_M9iu_BY_TEXT = M9u WITH TEXT PAD_TEXT M9_PIN_TEXT PRIMARY ONLY
PWR_MDiu_BY_TEXT = MDu WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_BY_TEXT = MDu WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDiu_BY_TEXT = MDu WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APu WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APu WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APu WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ELSE
NSTPiu = NSTPj NOT EMPTYi
PSTPiu = PSTPj NOT EMPTYi
NSDiu  = NSDj  NOT EMPTYi
PSDiu  = PSDj  NOT EMPTYi
CBiu   = CBj   NOT EMPTYi 
CB2iu  = CB2j  NOT EMPTYi
UBMniu = UBMnj NOT EMPTYi
UBMdiu = UBMdj NOT EMPTYi
PWR_M1iu_BY_TEXT = M1j WITH TEXT VDD_TEXT M1_PIN_TEXT PRIMARY ONLY
GND_M1iu_BY_TEXT = M1j WITH TEXT VSS_TEXT M1_PIN_TEXT PRIMARY ONLY
PAD_M1iu_BY_TEXT = M1j WITH TEXT PAD_TEXT M1_PIN_TEXT PRIMARY ONLY
PWR_M2iu_BY_TEXT = M2j WITH TEXT VDD_TEXT M2_PIN_TEXT PRIMARY ONLY
GND_M2iu_BY_TEXT = M2j WITH TEXT VSS_TEXT M2_PIN_TEXT PRIMARY ONLY
PAD_M2iu_BY_TEXT = M2j WITH TEXT PAD_TEXT M2_PIN_TEXT PRIMARY ONLY
PWR_M3iu_BY_TEXT = M3j WITH TEXT VDD_TEXT M3_PIN_TEXT PRIMARY ONLY
GND_M3iu_BY_TEXT = M3j WITH TEXT VSS_TEXT M3_PIN_TEXT PRIMARY ONLY
PAD_M3iu_BY_TEXT = M3j WITH TEXT PAD_TEXT M3_PIN_TEXT PRIMARY ONLY
PWR_M4iu_BY_TEXT = M4j WITH TEXT VDD_TEXT M4_PIN_TEXT PRIMARY ONLY
GND_M4iu_BY_TEXT = M4j WITH TEXT VSS_TEXT M4_PIN_TEXT PRIMARY ONLY
PAD_M4iu_BY_TEXT = M4j WITH TEXT PAD_TEXT M4_PIN_TEXT PRIMARY ONLY
PWR_M5iu_BY_TEXT = M5j WITH TEXT VDD_TEXT M5_PIN_TEXT PRIMARY ONLY
GND_M5iu_BY_TEXT = M5j WITH TEXT VSS_TEXT M5_PIN_TEXT PRIMARY ONLY
PAD_M5iu_BY_TEXT = M5j WITH TEXT PAD_TEXT M5_PIN_TEXT PRIMARY ONLY
PWR_M6iu_BY_TEXT = M6j WITH TEXT VDD_TEXT M6_PIN_TEXT PRIMARY ONLY
GND_M6iu_BY_TEXT = M6j WITH TEXT VSS_TEXT M6_PIN_TEXT PRIMARY ONLY
PAD_M6iu_BY_TEXT = M6j WITH TEXT PAD_TEXT M6_PIN_TEXT PRIMARY ONLY
PWR_M7iu_BY_TEXT = M7j WITH TEXT VDD_TEXT M7_PIN_TEXT PRIMARY ONLY
GND_M7iu_BY_TEXT = M7j WITH TEXT VSS_TEXT M7_PIN_TEXT PRIMARY ONLY
PAD_M7iu_BY_TEXT = M7j WITH TEXT PAD_TEXT M7_PIN_TEXT PRIMARY ONLY
PWR_M8iu_BY_TEXT = M8j WITH TEXT VDD_TEXT M8_PIN_TEXT PRIMARY ONLY
GND_M8iu_BY_TEXT = M8j WITH TEXT VSS_TEXT M8_PIN_TEXT PRIMARY ONLY
PAD_M8iu_BY_TEXT = M8j WITH TEXT PAD_TEXT M8_PIN_TEXT PRIMARY ONLY
PWR_M9iu_BY_TEXT = M9j WITH TEXT VDD_TEXT M9_PIN_TEXT PRIMARY ONLY
GND_M9iu_BY_TEXT = M9j WITH TEXT VSS_TEXT M9_PIN_TEXT PRIMARY ONLY
PAD_M9iu_BY_TEXT = M9j WITH TEXT PAD_TEXT M9_PIN_TEXT PRIMARY ONLY
PWR_MDiu_BY_TEXT = MDj WITH TEXT VDD_TEXT MD_PIN_TEXT PRIMARY ONLY
GND_MDiu_BY_TEXT = MDj WITH TEXT VSS_TEXT MD_PIN_TEXT PRIMARY ONLY
PAD_MDiu_BY_TEXT = MDj WITH TEXT PAD_TEXT MD_PIN_TEXT PRIMARY ONLY
PWR_APiu_BY_TEXT = APj WITH TEXT VDD_TEXT AP_PIN_TEXT PRIMARY ONLY
GND_APiu_BY_TEXT = APj WITH TEXT VSS_TEXT AP_PIN_TEXT PRIMARY ONLY
PAD_APiu_BY_TEXT = APj WITH TEXT PAD_TEXT AP_PIN_TEXT PRIMARY ONLY
#ENDIF
#ENDIF

// Power PAD
NSTPux = NSTPiu NOT INTERACT RNWEL
VDD_CB = NET AREA RATIO CBiu NSTPux > 0
VSS_CB = NET AREA RATIO CBiu PSTPiu > 0
VDD_CB2 = NET AREA RATIO CB2iu NSTPux > 0
VSS_CB2 = NET AREA RATIO CB2iu PSTPiu > 0
VDD_UBMn = NET AREA RATIO UBMniu NSTPux > 0
VSS_UBMn = NET AREA RATIO UBMniu PSTPiu > 0
VDD_UBMd = NET AREA RATIO UBMdiu NSTPux > 0
VSS_UBMd = NET AREA RATIO UBMdiu PSTPiu > 0
VDD_CB_BY_DUMMY = CBiu INTERACT VDDDMY
VSS_CB_BY_DUMMY = CBiu INTERACT VSSDMY
VDD_CB2_BY_DUMMY = CB2iu INTERACT VDDDMY
VSS_CB2_BY_DUMMY = CB2iu INTERACT VSSDMY
VDD_UBMn_BY_DUMMY = UBMniu INTERACT VDDDMY
VSS_UBMn_BY_DUMMY = UBMniu INTERACT VSSDMY
VDD_UBMd_BY_DUMMY = UBMdiu INTERACT VDDDMY
VSS_UBMd_BY_DUMMY = UBMdiu INTERACT VSSDMY
// Signal PAD
IO_CB  = (((CBiu NOT VDD_CB) NOT VSS_CB) NOT VDD_CB_BY_DUMMY) NOT VSS_CB_BY_DUMMY
IO_CB2 = (((CB2iu NOT VDD_CB2) NOT VSS_CB2) NOT VDD_CB2_BY_DUMMY) NOT VSS_CB2_BY_DUMMY
IO_UBMn = (((UBMniu NOT VDD_UBMn) NOT VSS_UBMn) NOT VDD_UBMn_BY_DUMMY) NOT VSS_UBMn_BY_DUMMY
IO_UBMd = (((UBMdiu NOT VDD_UBMd) NOT VSS_UBMd) NOT VDD_UBMd_BY_DUMMY) NOT VSS_UBMd_BY_DUMMY

PSD_PAD = NET AREA RATIO PSDiu CBiu CB2iu UBMniu UBMdiu > 0 [!!AREA(CBiu)+!!AREA(CB2iu)+!!AREA(UBMniu)+!!AREA(UBMdiu)]
NSD_PAD = NET AREA RATIO NSDiu CBiu CB2iu UBMniu UBMdiu > 0 [!!AREA(CBiu)+!!AREA(CB2iu)+!!AREA(UBMniu)+!!AREA(UBMdiu)]
PSD_IOPAD_stp = NET AREA RATIO PSDiu IO_CB IO_CB2 IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB)+!!AREA(IO_CB2)+!!AREA(IO_UBMn)+!!AREA(IO_UBMd)]
NSD_IOPAD_stp = NET AREA RATIO NSDiu IO_CB IO_CB2 IO_UBMn IO_UBMd > 0 [!!AREA(IO_CB)+!!AREA(IO_CB2)+!!AREA(IO_UBMn)+!!AREA(IO_UBMd)]
MOS = DACT INTERACT GATE
#IFDEF DEFINE_PAD_BY_TEXT
PSD_PAD_TEXT = NET AREA RATIO PSDiu OVER PAD_M9iu_BY_TEXT PAD_M8iu_BY_TEXT PAD_M7iu_BY_TEXT PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT PAD_MDiu_BY_TEXT > 0
NSD_PAD_TEXT = NET AREA RATIO NSDiu OVER PAD_M9iu_BY_TEXT PAD_M8iu_BY_TEXT PAD_M7iu_BY_TEXT PAD_M6iu_BY_TEXT PAD_M5iu_BY_TEXT PAD_M4iu_BY_TEXT PAD_M3iu_BY_TEXT PAD_M2iu_BY_TEXT PAD_M1iu_BY_TEXT PAD_APiu_BY_TEXT PAD_MDiu_BY_TEXT > 0
PSD_VDD_VSS_PAD_TEXT = NET AREA RATIO PSDiu OVER PWR_M9iu_BY_TEXT PWR_M8iu_BY_TEXT PWR_M7iu_BY_TEXT PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT PWR_MDiu_BY_TEXT GND_M9iu_BY_TEXT GND_M8iu_BY_TEXT GND_M7iu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT GND_MDiu_BY_TEXT > 0 
NSD_VDD_VSS_PAD_TEXT = NET AREA RATIO NSDiu OVER PWR_M9iu_BY_TEXT PWR_M8iu_BY_TEXT PWR_M7iu_BY_TEXT PWR_M6iu_BY_TEXT PWR_M5iu_BY_TEXT PWR_M4iu_BY_TEXT PWR_M3iu_BY_TEXT PWR_M2iu_BY_TEXT PWR_M1iu_BY_TEXT PWR_APiu_BY_TEXT PWR_MDiu_BY_TEXT GND_M9iu_BY_TEXT GND_M8iu_BY_TEXT GND_M7iu_BY_TEXT GND_M6iu_BY_TEXT GND_M5iu_BY_TEXT GND_M4iu_BY_TEXT GND_M3iu_BY_TEXT GND_M2iu_BY_TEXT GND_M1iu_BY_TEXT GND_APiu_BY_TEXT GND_MDiu_BY_TEXT > 0 
PSD_IOPAD = PSDiu INTERACT ((PSD_IOPAD_stp OR PSD_PAD_TEXT) NOT PSD_VDD_VSS_PAD_TEXT)
NSD_IOPAD = NSDiu INTERACT ((NSD_IOPAD_stp OR NSD_PAD_TEXT) NOT NSD_VDD_VSS_PAD_TEXT)
PMOS_filter = COPY EMPTYi
NMOS_filter = COPY EMPTYi
#ELSE
PSD_IOPAD = PSDiu INTERACT PSD_IOPAD_stp
NSD_IOPAD = NSDiu INTERACT NSD_IOPAD_stp
MOS_filter_DMY = CHIP INTERACT (VDDDMY OR VSSDMY)
PMOS_filter = (MOS INTERACT PSD_PAD == 1 BY NET) NOT MOS_filter_DMY
NMOS_filter = (MOS INTERACT NSD_PAD == 1 BY NET) NOT MOS_filter_DMY
#ENDIF
SD_IOPAD = PSD_IOPAD OR NSD_IOPAD
ODRES_a    = ODRES AND (RH OR RPDMY)
DUMMY_MOS = (MOS NOT INTERACT CO) NOT INTERACT (POLY INTERACT CO)
DUMMY_DIODE = (DACT NOT INTERACT POLY) NOT INTERACT CO
G_DIODE   = MOS INTERACT ((GATE INTERACT PP) INTERACT NP)
DACT_real = ((((DACT NOT INTERACT ODRES_a) NOT INTERACT RNWEL) NOT DUMMY_MOS) NOT G_DIODE) NOT DUMMY_DIODE
PACT_real = PACT AND DACT_real
NACT_real = NACT AND DACT_real

// ESD device [covered by dummy layers]
// ESD device [connected to Signal PAD but not connected to one PAD only]
POST_DRIVER_ACT2 = ((DACT_real NOT PMOS_filter) NOT NMOS_filter) INTERACT SD_IOPAD

POST_DRIVER_ACT = COPY POST_DRIVER_ACT2


// For LUP.1/LUP.2/LUP.4 - GuardRing
//====================================
NW_inside_guard_ring_pre1 = NWi NOT NSTPi
NW_inside_guard_ring_pre2 = NW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE NSTPi
NW_inside_guard_ring = NW_inside_guard_ring_pre1 NOT WITH EDGE NW_inside_guard_ring_pre2
PW_inside_guard_ring_pre1 = PWELi NOT PSTPi
PW_inside_guard_ring_pre2 = PW_inside_guard_ring_pre1 NOT COIN OUTSIDE EDGE PSTPi
PW_inside_guard_ring = PW_inside_guard_ring_pre1 NOT WITH EDGE PW_inside_guard_ring_pre2
NTAP_guard_ring_hole = ((HOLES NSTPi INNER) INSIDE NWi) OR NW_inside_guard_ring
PTAP_guard_ring_hole = ((HOLES PSTPi INNER) INSIDE PWELi) OR PW_inside_guard_ring

// For LUP.1 - I/O PAD N/P ACTIVE
//=================================
POST_DRIVER_PACT = (POST_DRIVER_ACT INTERACT PSDiu) NOT INSIDE LUPWDMY
POST_DRIVER_NACT = (POST_DRIVER_ACT INTERACT NSDiu) NOT INSIDE LUPWDMY

// For LUP.2
//==================
POST_DRIVER_PMOS = (POST_DRIVER_PACT INTERACT GATE) NOT G_DIODE
POST_DRIVER_PMOS_NW = STAMP POST_DRIVER_PMOS BY NWEL
POST_DRIVER_PMOS_NW_HV  = POST_DRIVER_PMOS_NW INTERACT OD2
POST_DRIVER_PMOS_NW_33V = POST_DRIVER_PMOS_NW_HV INTERACT OD_33
POST_DRIVER_PMOS_NW_25V = POST_DRIVER_PMOS_NW_HV INTERACT OD_25
POST_DRIVER_PMOS_NW_18V = POST_DRIVER_PMOS_NW_HV INTERACT OD_18
POST_DRIVER_PMOS_NW_LV  = POST_DRIVER_PMOS_NW NOT POST_DRIVER_PMOS_NW_HV
POST_DRIVER_NMOS = (POST_DRIVER_NACT INTERACT GATE) NOT G_DIODE
POST_DRIVER_NMOS_RW = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNW
POST_DRIVER_NMOS_RW_HV  = POST_DRIVER_NMOS_RW INTERACT OD2
POST_DRIVER_NMOS_RW_33V = POST_DRIVER_NMOS_RW_HV INTERACT OD_33
POST_DRIVER_NMOS_RW_25V = POST_DRIVER_NMOS_RW_HV INTERACT OD_25
POST_DRIVER_NMOS_RW_18V = POST_DRIVER_NMOS_RW_HV INTERACT OD_18
POST_DRIVER_NMOS_RW_LV  = POST_DRIVER_NMOS_RW NOT POST_DRIVER_NMOS_RW_HV
POST_DRIVER_NMOS_PW = POST_DRIVER_NMOS NOT POST_DRIVER_NMOS_RW
POST_DRIVER_NMOS_PW_HV  = POST_DRIVER_NMOS_PW INTERACT OD2
POST_DRIVER_NMOS_PW_33V = POST_DRIVER_NMOS_PW_HV INTERACT OD_33
POST_DRIVER_NMOS_PW_25V = POST_DRIVER_NMOS_PW_HV INTERACT OD_25
POST_DRIVER_NMOS_PW_18V = POST_DRIVER_NMOS_PW_HV INTERACT OD_18
POST_DRIVER_NMOS_PW_LV  = POST_DRIVER_NMOS_PW NOT POST_DRIVER_NMOS_PW_HV

// For LUP.2 - Peripheral N/P MOS
//=================================
BESIDE_POST_DRIVER = SIZE (POST_DRIVER_NMOS OR POST_DRIVER_PMOS) BY LUP_2g
BESIDE_POST_DRIVER_NMOS = ((NACT_real INTERACT GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_NMOS
BESIDE_POST_DRIVER_PMOS = ((PACT_real INTERACT GATE) NOT OUTSIDE BESIDE_POST_DRIVER) NOT POST_DRIVER_PMOS

// For LUP.3/LUP.5 - Wide GuardRing
//====================================
PTAP_guard_ring_holex = PTAP_guard_ring_hole ENCLOSE (POST_DRIVER_NACT OR BESIDE_POST_DRIVER_NMOS)
NTAP_guard_ring_holex = NTAP_guard_ring_hole ENCLOSE (POST_DRIVER_PACT OR BESIDE_POST_DRIVER_PMOS)
PTAP_guard_ring_wide = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_3g_W
NTAP_guard_ring_wide = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_3g_W

PW_inside_guard_ring_wide_pre = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide
PW_inside_guard_ring_wide = PW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide_pre
NW_inside_guard_ring_wide_pre = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide
NW_inside_guard_ring_wide = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide_pre

PTAP_guard_ring_wide_hole = ((HOLES PTAP_guard_ring_wide INNER) INSIDE PWELi) OR PW_inside_guard_ring_wide
NTAP_guard_ring_wide_hole = ((HOLES NTAP_guard_ring_wide INNER) INSIDE NWi) OR NW_inside_guard_ring_wide

POST_DRIVER_PMOS_NWi = STAMP POST_DRIVER_PMOS BY NWi
POST_DRIVER_PMOS_NWi_HV  = POST_DRIVER_PMOS_NWi INTERACT OD2
POST_DRIVER_PMOS_NWi_33V = POST_DRIVER_PMOS_NWi_HV INTERACT OD_33
POST_DRIVER_PMOS_NWi_25V = POST_DRIVER_PMOS_NWi_HV INTERACT OD_25
POST_DRIVER_PMOS_NWi_18V = POST_DRIVER_PMOS_NWi_HV INTERACT OD_18
POST_DRIVER_PMOS_NWi_LV  = POST_DRIVER_PMOS_NWi NOT POST_DRIVER_PMOS_NWi_HV
DNWc = STAMP DNW BY NWi
POST_DRIVER_NMOS_RWi = STAMP (POST_DRIVER_NMOS INSIDE DNW) BY DNWc
POST_DRIVER_NMOS_RWi_HV  = POST_DRIVER_NMOS_RWi INTERACT OD2
POST_DRIVER_NMOS_RWi_33V = POST_DRIVER_NMOS_RWi_HV INTERACT OD_33
POST_DRIVER_NMOS_RWi_25V = POST_DRIVER_NMOS_RWi_HV INTERACT OD_25
POST_DRIVER_NMOS_RWi_18V = POST_DRIVER_NMOS_RWi_HV INTERACT OD_18
POST_DRIVER_NMOS_RWi_LV  = POST_DRIVER_NMOS_RWi NOT POST_DRIVER_NMOS_RWi_HV

// For LUP.5
//==================
BESIDE_POST_DRIVER_PMOS_NW = STAMP BESIDE_POST_DRIVER_PMOS BY NWEL
BESIDE_POST_DRIVER_NMOS_RW = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNW
BESIDE_POST_DRIVER_NMOS_PW = BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_RW

BESIDE_POST_DRIVER_PMOS_NW_NG = BESIDE_POST_DRIVER_PMOS_NW NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RW_NG = BESIDE_POST_DRIVER_NMOS_RW NOT INSIDE PTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_PW_NG = BESIDE_POST_DRIVER_NMOS_PW NOT INSIDE PTAP_guard_ring_wide_hole

BESIDE_POST_DRIVER_PMOS_NWi = STAMP BESIDE_POST_DRIVER_PMOS BY NWi
BESIDE_POST_DRIVER_NMOS_RWi = STAMP (BESIDE_POST_DRIVER_NMOS INSIDE DNW) BY DNWc

BESIDE_POST_DRIVER_PMOS_NWi_NG = BESIDE_POST_DRIVER_PMOS_NWi NOT INSIDE NTAP_guard_ring_wide_hole
BESIDE_POST_DRIVER_NMOS_RWi_NG = BESIDE_POST_DRIVER_NMOS_RWi NOT INSIDE PTAP_guard_ring_wide_hole

#IFDEF GUIDELINE_LUP
LUP.1g { @ Any N+Active or an N+Active cluster connected to an I/O pad must be surrounded by a P+ guard-ring.
        @ Any P+Active or a P+Active cluster connected to an I/O pad must be surrounded by a N+ guard-ring.
  POST_DRIVER_NACT NOT INSIDE PTAP_guard_ring_hole
  POST_DRIVER_PACT NOT INSIDE NTAP_guard_ring_hole
}

LUP.2g { @ Within ^LUP_2g um space from the MOS connected to an I/O pad, a P+ guard-ring is required to surround an NMOS or an NMOS cluster. And an N+ guard-ring is required to surround a PMOS or a PMOS cluster.
  X = EXT POST_DRIVER_PMOS_NW BESIDE_POST_DRIVER_NMOS_RW < 8 ABUT < 90 SINGULAR REGION CONNECTED
  Y = EXT POST_DRIVER_PMOS_NWi BESIDE_POST_DRIVER_NMOS_RWi < 8 ABUT < 90 SINGULAR REGION NOT CONNECTED
  BESIDE_POST_DRIVER_NMOS_waive = (BESIDE_POST_DRIVER_NMOS_RWi NOT INTERACT X) NOT INTERACT Y
  (BESIDE_POST_DRIVER_NMOS NOT BESIDE_POST_DRIVER_NMOS_waive) NOT INSIDE PTAP_guard_ring_hole
  BESIDE_POST_DRIVER_PMOS NOT INSIDE NTAP_guard_ring_hole
}
//LUP.3.0 is checked by LUP.3.1g and LUP.3.2g
LUP.3.1g { @ For the 1.2V, 1.05V or 1.0V N/PMOS which connects to an I/O pad, space between the NMOS and the PMOS. Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_1g um
  EXT POST_DRIVER_NMOS_PW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_LV POST_DRIVER_PMOS_NW_LV < LUP_3_1g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV POST_DRIVER_PMOS_NWi_LV < LUP_3_1g ABUT < 90 SINGULAR REGION NOT CONNECTED 
}
LUP.3.2g { @ For the 1.8V N/PMOS which connects to an I/O pad directly, space between the 1.8V NMOS and the 1.8V/1.2V/1.0V PMOS, space between the 1.8V PMOS and the 1.8V/1.2V/1.0V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.  >= ^LUP_3_2g um
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_18V < LUP_3_2g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_18V POST_DRIVER_PMOS_NW_LV  < LUP_3_2g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_18V < LUP_3_2g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_18V < LUP_3_2g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_18V POST_DRIVER_PMOS_NW_LV  < LUP_3_2g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_18V < LUP_3_2g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_18V < LUP_3_2g ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_18V POST_DRIVER_PMOS_NWi_LV  < LUP_3_2g ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_18V < LUP_3_2g ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.3.3g { @ For the 2.5V N/PMOS which connects to an I/O pad directly, space between the 2.5V NMOS and the 2.5V/1.2V/1.0V PMOS, space between the 2.5V PMOS and the 2.5V/1.2V/1.0V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW.>= ^LUP_3_3g um
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_3g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_3g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_3g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_25V < LUP_3_3g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_25V POST_DRIVER_PMOS_NW_LV  < LUP_3_3g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_25V < LUP_3_3g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_25V < LUP_3_3g ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_25V POST_DRIVER_PMOS_NWi_LV  < LUP_3_3g ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_25V < LUP_3_3g ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.3.4g { @ For the 3.3V N/PMOS which connects to an I/O pad directly, space between the 3.3V NMOS and the 3.3V/1.2V/1.0V PMOS, space between the 3.3V PMOS and the 3.3V/1.2V/1.0V NMOS, Except the NMOS is enclosed by a DNW and the NW of the checked PMOS is not interacted to the DNW. >= ^LUP_3_4g um
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_4g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_4g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_PW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_4g ABUT < 90 SINGULAR REGION
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_33V < LUP_3_4g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_33V POST_DRIVER_PMOS_NW_LV  < LUP_3_4g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RW_LV  POST_DRIVER_PMOS_NW_33V < LUP_3_4g ABUT < 90 SINGULAR REGION CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_33V < LUP_3_4g ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_33V POST_DRIVER_PMOS_NWi_LV  < LUP_3_4g ABUT < 90 SINGULAR REGION NOT CONNECTED
  EXT POST_DRIVER_NMOS_RWi_LV  POST_DRIVER_PMOS_NWi_33V < LUP_3_4g ABUT < 90 SINGULAR REGION NOT CONNECTED
}
LUP.4g { @ Width of the N+ guard-ring, P+ guard-ring, N+ STRAP and P+ STRAP for the Active connected to an I/O pad, and also MOS within 20um space from the MOS connected to an I/O pad. >= ^LUP_4g um
  PTAP_guard_ring_wide2 = (PSTPi TOUCH PTAP_guard_ring_holex) WITH WIDTH >= LUP_4g
  NTAP_guard_ring_wide2 = (NSTPi TOUCH NTAP_guard_ring_holex) WITH WIDTH >= LUP_4g
  
  PW_inside_guard_ring_wide2_pre = PW_inside_guard_ring NOT COIN OUTSIDE EDGE PTAP_guard_ring_wide2
  PW_inside_guard_ring_wide2 = NW_inside_guard_ring NOT WITH EDGE PW_inside_guard_ring_wide2_pre
  NW_inside_guard_ring_wide2_pre = NW_inside_guard_ring NOT COIN OUTSIDE EDGE NTAP_guard_ring_wide2
  NW_inside_guard_ring_wide2 = NW_inside_guard_ring NOT WITH EDGE NW_inside_guard_ring_wide2_pre
  
  PTAP_guard_ring_wide2_hole = ((HOLES PTAP_guard_ring_wide2 INNER) INSIDE PWELi) OR PW_inside_guard_ring_wide2
  NTAP_guard_ring_wide2_hole = ((HOLES NTAP_guard_ring_wide2 INNER) INSIDE NWi) OR NW_inside_guard_ring_wide2
  PTAP_guard_ring_hole_check = PTAP_guard_ring_holex NOT INSIDE PTAP_guard_ring_wide2_hole
  NTAP_guard_ring_hole_check = NTAP_guard_ring_holex NOT INSIDE NTAP_guard_ring_wide2_hole
  PTAP_guard_ring_check = PSTPi COIN OUTSIDE EDGE PTAP_guard_ring_hole_check
  NTAP_guard_ring_check = NSTPi COIN OUTSIDE EDGE NTAP_guard_ring_hole_check
  INT PTAP_guard_ring_check PSTPi < LUP_4g ABUT < 90 REGION
  INT NTAP_guard_ring_check NSTPi < LUP_4g ABUT < 90 REGION
}
LUP.5.1g { @ Minimum space >= ^LUP_5_1g um
@ 1. between 1.2V-1.0V NMOS which connects to the IO pad and the PMOS in the internal circuit 
@ 2. between 1.2V-1.0V PMOS which connects to the IO pad and the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_1g  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_LV BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_1g  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_LV BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_1g  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1g ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_LV BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_1g ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_LV BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_1g ABUT <90 SINGULAR REGION NOT CONNECTED
}
LUP.5.2g { @ Minimum space >= ^LUP_5_2g um
@ 1. between 1.8V NMOS which connects to the IO pad and the PMOS in the internal circuit 
@ 2. between 1.8V PMOS which connects to the IO pad and the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_2g  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_18V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_2g  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_18V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_2g  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_18V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2g ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_18V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_2g ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_18V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_2g ABUT <90 SINGULAR REGION NOT CONNECTED
}
LUP.5.3g { @ Minimum space >= ^LUP_5_3g um
@ 1. between 2.5V NMOS which connects to the IO pad and the PMOS in the internal circuit 
@ 2. between 2.5V PMOS which connects to the IO pad and the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_3g  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_25V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_3g  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_25V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_3g  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_25V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3g ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_25V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_3g ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_25V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_3g ABUT <90 SINGULAR REGION NOT CONNECTED
}
LUP.5.4g { @ Minimum space >= ^LUP_5_4g um
@ 1. between 3.3V NMOS which connects to the IO pad and the PMOS in the internal circuit 
@ 2. between 3.3V PMOS which connects to the IO pad and the NMOS in the internal circuit  
   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_PW  < LUP_5_4g  ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_PMOS_NW_33V BESIDE_POST_DRIVER_NMOS_RW  < LUP_5_4g  ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_PMOS_NWi_33V BESIDE_POST_DRIVER_NMOS_RWi < LUP_5_4g  ABUT <90 SINGULAR REGION NOT CONNECTED
   EXT POST_DRIVER_NMOS_PW_33V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_4g ABUT <90 SINGULAR REGION
   EXT POST_DRIVER_NMOS_RW_33V BESIDE_POST_DRIVER_PMOS_NW  < LUP_5_4g ABUT <90 SINGULAR REGION CONNECTED
   EXT POST_DRIVER_NMOS_RWi_33V BESIDE_POST_DRIVER_PMOS_NWi  < LUP_5_4g ABUT <90 SINGULAR REGION NOT CONNECTED
}
#ENDIF

CO_PACT = COi OR (PSDc NOT OUTSIDE COi)
NPUi = NSTPi INTERACT CO_PACT
NPUi_SRAM = NPUi INSIDE SRM 
NSTP_OS = SIZE NPUi BY LUP_6 INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NSTP_OS_SRAM = SIZE NPUi_SRAM BY LUP_6_SRAM INSIDE OF NWi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PACT_CHECK = ((PACTi INTERACT COi) INTERACT POi) NOT POi
PACT_CHECK_NON_SRAM = PACT_CHECK NOT INSIDE SRM 
PACT_CHECK_SRAM =  PACT_CHECK INSIDE SRM

CO_NACT = COi OR (NSDc NOT OUTSIDE COi)
PPUi = PSTPi INTERACT CO_NACT
PPUi_SRAM = PPUi INSIDE SRM
PSTP_OS = SIZE PPUi BY LUP_6 INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
PSTP_OS_SRAM = SIZE PPUi_SRAM BY LUP_6_SRAM INSIDE OF PWELi STEP NW_S_1*0.7 TRUNCATE NW_S_1*0.7
NACT_CHECK = ((NACTi INTERACT COi) INTERACT POi) NOT POi
NACT_CHECK_NON_SRAM = NACT_CHECK NOT INSIDE SRM 
NACT_CHECK_SRAM =  NACT_CHECK INSIDE SRM

LUP.6 { @ Any point inside NMOS source/drain space to the nearest PW STRAP in the same PW <= ^LUP_6 um
        @ Any point inside PMOS source/drain space to the nearest NW STRAP in the same NW <= ^LUP_6 um
        @ In SRAM bit cell region, the rule is relaxed to ^LUP_6_SRAM um
  PACT_CHECK_NON_SRAM NOT NSTP_OS
  PACT_CHECK_SRAM NOT (NSTP_OS OR NSTP_OS_SRAM)
  NACT_CHECK_NON_SRAM NOT PSTP_OS
  NACT_CHECK_SRAM NOT (PSTP_OS OR PSTP_OS_SRAM)

}

// ESDIMP CHECKS
//==============

ESDIMP.W.1 { @ Width >= ^ESDIMP_W_1 um
  INT ESDIMP < ESDIMP_W_1 ABUT < 90 SINGULAR REGION
}
ESDIMP.S.1 { @ Space >= ^ESDIMP_S_1 um
  EXT ESDIMP < ESDIMP_S_1 ABUT < 90 SINGULAR REGION
}
ESDIMP.S.2 { @ Space >= ^ESDIMP_S_2 um
  EXT ESDIMP ESD3 < ESDIMP_S_1 ABUT < 90 SINGULAR REGION
}
ESDIMP.EN.1 { @ (OD NOT PO) enclosure of ESDIMP. ESDIMP must be fully inside (OD NOT PO) >= 0.4 
  OD_NPO = OD NOT POLY
  ENC ESDIMP OD_NPO < ESDIMP_EN_1 ABUT < 90 SINGULAR REGION
  ESDIMP NOT OD_NPO
}
ESDIMP.A.1 { @ Area >= 1 
  AREA ESDIMP < ESDIMP_A_1
}
ESDIMP.A.2 { @ Enclosed area >= 1 
  A = HOLES ESDIMP INNER
  B = A NOT ESDIMP
  AREA B < ESDIMP_A_2
}
ESDIMP.R.1 { @ ESDIMP must be fully inside N+ ACTIVE   
  ESDIMP NOT NACT
}

#IFDEF GUIDELINE_ESD

// I/O ESD Guidance
//==================
PMOSi = (PACTi INTERACT POi) INTERACT COi //Interact CONTi to filter out filler cell.
NMOSi = (NACTi INTERACT POi) INTERACT COi
EPMOS = PMOSi AND SDI
ENMOS = NMOSi AND SDI
EMOS = EPMOS OR ENMOS
PASD = PACT NOT POLY  // Source/Drain of PMOS
NASD = NACT NOT POLY  // Source/Drain of NMOS
EPSD = SDI AND PASD
ENSD = SDI AND NASD
EGTE = SDI AND GATE
ECO  = (CO AND SDI) AND OD

// Define ESD Gate Type
//======================
EGTE_FULL_RPO = EGTE INSIDE RPO
EGTE_PART_RPO = EGTE CUT RPO  
EGTE_NO_RPO = EGTE NOT INTERACT RPO

REG_ENMOS = (ENMOS INTERACT EGTE_PART_RPO) NOT INTERACT EGTE_FULL_RPO
REG_EPMOS = (EPMOS INTERACT EGTE_PART_RPO) NOT INTERACT EGTE_FULL_RPO
TOL_ENMOS = (ENMOS INTERACT EGTE_PART_RPO) INTERACT EGTE_FULL_RPO
PCL_ENMOS = ENMOS NOT INTERACT RPO

REG_EGTE = EGTE AND (REG_ENMOS OR REG_EPMOS)
TOL_EGTE = EGTE AND (TOL_ENMOS OR REG_EPMOS)
PCL_EGTE = EGTE AND (PCL_ENMOS OR REG_ENMOS)

// For ESD.1g
//=============
NSDc_HVMOS = (NSDc INTERACT NMOSi) INTERACT OD2
NSDc_LVMOS = (NSDc INTERACT NMOSi) NOT INTERACT OD2
PSDc_HVMOS = (PSDc INTERACT PMOSi) INTERACT OD2
PSDc_LVMOS = (PSDc INTERACT PMOSi) NOT INTERACT OD2
NSDc_HVMOS_SDI = NSDc_HVMOS INTERACT SDI 
NSDc_LVMOS_SDI = NSDc_LVMOS INTERACT SDI 
PSDc_HVMOS_SDI = PSDc_HVMOS INTERACT SDI 
PSDc_LVMOS_SDI = PSDc_LVMOS INTERACT SDI 
HV_GATEc = STAMP HV_GATE BY ILP1i
LV_GATEc = STAMP LV_GATE BY ILP1i


// For ESD.6g
//=============
CONNECT ENSD NSDu
CONNECT EPSD PSDu
ENSDi = COPY ENSD
EPSDi = COPY EPSD
CONNECT ENSDi NSDc
CONNECT EPSDi PSDc

PSTP_real = PSTPi NOT DIODMY
NSTP_real = NSTPi NOT DIODMY
ENSD_SOURCE_pre = NET AREA RATIO ENSDi PSTP_real > 0 [!!AREA(ENSDi)*!!AREA(PSTP_real)]
EPSD_SOURCE_pre = NET AREA RATIO EPSDi NSTP_real > 0 [!!AREA(EPSDi)*!!AREA(NSTP_real)]
ENSD_SOURCE = ENSD_SOURCE_pre OR ((ENSD NOT PCL_ENMOS) OUTSIDE RPO)
EPSD_SOURCE = EPSD_SOURCE_pre OR (EPSD OUTSIDE RPO)
ENSD_DRAIN = ENSD NOT ENSD_SOURCE
EPSD_DRAIN = EPSD NOT EPSD_SOURCE
ENSD_DRAINx = ENSD_DRAIN INTERACT CO
ENMOSc = STAMP ENMOS BY ENSD_DRAINx
EPMOSc = STAMP EPMOS BY EPSD_DRAIN 

#IFDEF FULL_CHIP
ESD.WARN.1 { @ SDI is not in whole chip. If SDI does not exist, the ESD related DRC will not work well.
  CHIPx NOT INTERACT SDI
}
#ENDIF
ESD.WARN.2 { @ SDI encloure of ACTIVE >= 0
  (DACT INTERACT SDI) NOT SDI
}

ESD.1g { @ Use thin oxide transistor for thin oxide power clamp and thin oxide I/O buffers; use thick oxide transistor for the thick oxide Power Clamp and thick oxide I/O buffers
  NET AREA RATIO NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0 
    [!!AREA(NSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))] 
    RDB ESD.1g.hv_n.rep NSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
  NET AREA RATIO PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc PSTPi > 0
    [!!AREA(PSDc_HVMOS_SDI)*!AREA(PSTPi)*(!!AREA(NSDc_LVMOS)+!!AREA(PSDc_LVMOS)+!!AREA(LV_GATEc))]
    RDB ESD.1g.hv_p.rep PSDc_HVMOS_SDI NSDc_LVMOS PSDc_LVMOS LV_GATEc
} 

ESD.3g { @ Unit finger width of NMOS and PMOS for I/O buffer and Power Clamp >= ^ESD_3g_MIN um <= ^ESD_3g_MAX um
  EGTE_W = EGTE INSIDE EDGE OD
  PATH LENGTH EGTE_W < ESD_3g_MIN
  PATH LENGTH EGTE_W > ESD_3g_MAX
}

ESD.4g { @ The OD area of the edge side of I/O buffer and Power Clamp should be Source or Bulk rather than Drain, 
@ to avoid an unwanted parasitic bipolar effect or an abnormal discharge path in ESD zapping.
@ DRC only flag (((OD INTERACT SDI) NOT PO) INTERACT one Gate) does not connect to STRAP.
  EDGE_NSD = NSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_NSD PSTPu > 0 [!!AREA(EDGE_NSD)*!AREA(PSTPu)]
  EDGE_PSD = PSDu INTERACT EGTE == 1
  NET AREA RATIO EDGE_PSD NSTPu > 0 [!!AREA(EDGE_PSD)*!AREA(NSTPu)]
}

ESD.5g { @ For same type OD of the I/O buffer and Power Clamp should be surrounded by a guard-ring. All other type ODs should be placed outside this guard-ring.
  EPMOS NOT INSIDE NTAP_guard_ring_hole
  ENMOS NOT INSIDE PTAP_guard_ring_hole
}

ESD.6g { @ Butted STRAP and the STRAP which are between two sources of the N/PMOS in the same I/O buffer and Power Clamp are strictly prohibited. 
  A = (EXT ENMOSc < ESD_6g ABUT < 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
  A INTERACT PSTPi
  B = (EXT EPMOSc < ESD_6g ABUT < 90 OPPOSITE REGION CONNECTED) NOT INTERACT GATE
  B INTERACT NSTPi
}

NWELc = COPY NWEL
CONNECT NWELc
PWELc = COPY PWEL
CONNECT PWELc

ESD.7g { @ Except the ESD device, either one of the following two conditions must be followed.
@ 1. the space of two same type ODs >= ^ESD_7g um   2. two same type ODs should be separated by different type OD.    
@ The same type ODs are N+OD and N+OD in the same PW, or P+OD and P+OD in the same NW, which connect to two different Pad.
  PACT_CHECK = (PACT INTERACT PSD_IOPAD) NOT EPMOS 
  PACT_CHECK_CB = STAMP PACT_CHECK BY PSD_IOPAD
  P1 = EXT PACT_CHECK_CB < ESD_7g ABUT < 90 SINGULAR REGION NOT CONNECTED
  PACT_CHECK_NW = STAMP (PACT_CHECK INTERACT P1) BY NWELc
  P2 = EXT PACT_CHECK_NW < ESD_7g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_P3 = P1 AND P2
  (ESD_P3 NOT NSTPi) INTERACT PACT_CHECK_CB > 1 BY NET
  
  NACT_CHECK = (NACT INTERACT NSD_IOPAD) NOT ENMOS 
  NACT_CHECK_CB = STAMP NACT_CHECK BY NSD_IOPAD
  N1 = EXT NACT_CHECK_CB < ESD_7g ABUT < 90 SINGULAR REGION NOT CONNECTED
  NACT_CHECK_PW = STAMP (NACT_CHECK INTERACT N1) BY PWELc
  N2 = EXT NACT_CHECK_PW < ESD_7g ABUT < 90 SINGULAR REGION CONNECTED
  ESD_N3 = N1 AND N2
  (ESD_N3 NOT PSTPi) INTERACT NACT_CHECK_CB > 1 BY NET
}
// ESD.8gU, ESD.9gU, ESD.10gUC, and ESD.11gU can not be checked by DRC

ESD.12g { @ It is not allowed to use OD RPO resistor or NW resistor connected to PAD
  ODR_T = ((OD NOT POLY) INTERACT ODRES_a) NOT ODRES_a
  ODRuT = STAMP ODR_T BY COu
  NET AREA RATIO ODRuT CBu CB2u UBMnu UBMdu > 0 [!!AREA(ODRuT)*(!!AREA(CBu)+!!AREA(CB2u)+!!AREA(UBMnu)+!!AREA(UBMnu))] 
  NET AREA RATIO NWRuT CBu CB2u UBMnu UBMdu > 0 [!!AREA(NWRuT)*(!!AREA(CBu)+!!AREA(CB2u)+!!AREA(UBMnu)+!!AREA(UBMdu))]
}
// ESD.13gU, ESD.14gU, and ESD.15gU can not be checked by DRC

// Regular I/O
//============

ESD_GATE_W = GATE_W INSIDE EDGE SDI
ESD_PMOS_GATE_W = ESD_GATE_W INSIDE EDGE PP
ESD_NMOS_GATE_W = ESD_GATE_W INSIDE EDGE NP
ESD_PMOS_GATE_W_EXP = EXPAND EDGE ESD_PMOS_GATE_W INSIDE BY GRID
ESD_NMOS_GATE_W_EXP = EXPAND EDGE ESD_NMOS_GATE_W INSIDE BY GRID
ESD_PMOS_GATE_W_EXPc = STAMP ESD_PMOS_GATE_W_EXP BY EPMOSc
ESD_NMOS_GATE_W_EXPc = STAMP ESD_NMOS_GATE_W_EXP BY ENMOSc

ESD.16g { @ Total finger width for NMOS in same connection of drain > ^ESD_16g um 
@ ESD.24g is also checked by ESD.16g 
  NET AREA RATIO ESD_NMOS_GATE_W_EXPc < ESD_16g
    [(AREA(ESD_NMOS_GATE_W_EXPc)/2)/GRID]
    RDB ESD.16g.NMOS.rep ESD_NMOS_GATE_W_EXPc
}

ESD.17g { @ Total finger width for PMOS in same connection of drain > ^ESD_17g um
@ ESD.25g is also checked by ESD.17g   
  NET AREA RATIO ESD_PMOS_GATE_W_EXPc < ESD_17g
    [(AREA(ESD_PMOS_GATE_W_EXPc)/2)/GRID]
    RDB ESD.17g.PMOS.rep ESD_PMOS_GATE_W_EXPc
}

REG_EGTE_HV_33V = REG_EGTE AND OD_33
REG_EGTE_HV_25V = REG_EGTE AND OD_25
REG_EGTE_HV_18V = REG_EGTE AND OD_18
REG_EGTE_LV     = REG_EGTE NOT OD2

// ESD.18.1g is checked by ESD.18g
// ESD.18.2g is checked by ESD.18g
// ESD.18.3g is checked by ESD.18g
// ESD.18.4g is checked by ESD.18g

ESD.18g { @ Channel length of 3.3V I/O and Power Clamp >= ^ESD_18g_33V
@ Channel length of 2.5V I/O and Power Clamp >= ^ESD_18g_25V
@ Channel length of 1.8V I/O and Power Clamp >= ^ESD_18g_18V 
@ Channel length of 1.0V/1.05V/1.2V I/O and Power Clamp >= ^ESD_18g_10V
  INT REG_EGTE_HV_33V < ESD_18g_33V ABUT < 90 SINGULAR REGION
  INT REG_EGTE_HV_25V < ESD_18g_25V ABUT < 90 SINGULAR REGION
  INT REG_EGTE_HV_18V < ESD_18g_18V ABUT < 90 SINGULAR REGION
  INT REG_EGTE_LV     < ESD_18g_10V ABUT < 90 SINGULAR REGION
}

ESD.19g { @ The NMOS and PMOS should have an unsilicided area on the drain side. 
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
          @ DRC only flags no RPO in this device.
  REG_EGTE NOT INTERACT RPO
}

ESD.20g { @ Overlap of RPO on the drain side to the poly gate for Regular I/O == ^ESD_20g um
  REG_EGTE OUTSIDE RPO
  REG_EGTE_W = REG_EGTE INSIDE EDGE OD
  X = REG_EGTE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_20g
  REG_EGTE WITH EDGE X > 1
  (REG_EGTE AND RPO) XOR Y
}

ESD.21g { @ Width of the RPO on drain side for NMOS Regular I/O >= ^ESD_21g um
  REG_ENSD = (ENSD INTERACT REG_EGTE) AND RPO
  INT REG_ENSD < ESD_21g ABUT < 90 SINGULAR REGION
}

ESD.22g { @ Width of the RPO on drain side for PMOS Regular I/O >= ^ESD_22g um
  REG_EPSD = (EPSD INTERACT REG_EGTE) AND RPO
  INT REG_EPSD < ESD_22g ABUT < 90 SINGULAR REGION
}

ESD.23g { @ Space of poly to CO on source side for Regular I/O >= ^ESD_23g um
  EXT ECO REG_EGTE < ESD_23g ABUT < 90 SINGULAR REGION
}

// HV Tolerant I/O
//================

TOL_ENOD = ENSD INTERACT TOL_EGTE
TOL_ENG  = (TOL_ENOD NOT INTERACT ECO) NOT INTERACT PSTP
TOL_ENSD = TOL_ENOD NOT TOL_ENG
TOL_ENS  = TOL_ENSD OUTSIDE RPO
TOL_END  = TOL_ENSD NOT OUTSIDE RPO

// ESD.24g is checked by ESD.16g
// ESD.25g is checked by ESD.17g

TOL_EGTE_HV_5V = TOL_EGTE AND OD_33
TOL_EGTE_HV_33V = TOL_EGTE AND OD_25
TOL_EGTE_HV_25V = TOL_EGTE AND OD_18

// ESD.26.1g is checked by ESD.26g
// ESD.26.2g is checked by ESD.26g
// ESD.26.3g is checked by ESD.26g
ESD.26g { @ Channel length of 5V NMOS/PMOS HV Tolerant I/O >= ^ESD_26g_5V um
@ Channel length of 3.3V NMOS/PMOS HV TOlerant I/O >= ^ESD_26g_33V
@ Channel length of 2.5V NMOS/PMOS HV TOlerant I/O >= ^ESD_26g_25V
  INT TOL_EGTE_HV_5V  < ESD_26g_5V ABUT < 90 SINGULAR REGION
  INT TOL_EGTE_HV_33V < ESD_26g_33V ABUT < 90 SINGULAR REGION
  INT TOL_EGTE_HV_25V < ESD_26g_25V ABUT < 90 SINGULAR REGION
}

ESD.27g { @ The NMOS and PMOS should have an unsilicided area on the drain side. 
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
          @ DRC only flags no RPO in this device.
  TOL_EGTE NOT INTERACT RPO
}

ESD.28g { @ Overlap of RPO on the drain side to the poly gate for NMOS HV Tolerant I/O == ^ESD_28g um
  TOL_ENGTE1 = TOL_EGTE INTERACT TOL_END
  TOL_ENGTE2 = TOL_EGTE INTERACT TOL_ENS
  TOL_ENGTE1 NOT RPO
  TOL_ENGTE2 OUTSIDE RPO
  TOL_ENG NOT INTERACT TOL_ENGTE2
  TOL_ENGTE2_W = TOL_ENGTE2 INSIDE EDGE OD
  X = TOL_ENGTE2_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_28g
  (TOL_ENGTE2 AND RPO) XOR Y
}

ESD.29g { @ Overlap of RPO on the drain side to the poly gate for PMOS HV Tolerant I/O == ^ESD_29g um
  TOL_EPGTE = TOL_EGTE INTERACT EPSD
  TOL_EPGTE OUTSIDE RPO
  TOL_EPGTE_W = TOL_EPGTE INSIDE EDGE OD
  X = TOL_EPGTE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_29g
  TOL_EPGTE WITH EDGE X > 1
  (TOL_EPGTE AND RPO) XOR Y
}

ESD.30g { @ Width of the RPO on drain side for NMOS HV Tolerant I/O >= ^ESD_30g um
  TOL_ENSD = TOL_END AND RPO
  INT TOL_ENSD < ESD_30g ABUT < 90 SINGULAR REGION
}

ESD.31g { @ Width of the RPO on drain side for PMOS HV Tolerant I/O >= ^ESD_31g um
		  @ ESD.31g and ESD.22g share same checking method, show up in pairs	
  TOL_EPSD = (EPSD INTERACT TOL_EGTE) AND RPO
  INT TOL_EPSD < ESD_31g ABUT < 90 SINGULAR REGION
}

ESD.32g { @ Space of poly to CO on source side for HV Tolerant I/O >= ^ESD_32g um
		  @ ESD.32g and ESD.23g share same checking method, show up in pairs	
  EXT ECO TOL_EGTE < ESD_32g ABUT < 90 SINGULAR REGION
}

ESD.33g { @ Space of poly gate(N2) to poly gate(N3) for NMOS HV Tolerant I/O == ^ESD_33g um
  INT TOL_ENG < ESD_33g ABUT < 90 SINGULAR REGION
  TOL_ENG WITH WIDTH > ESD_33g
  (TOL_EGTE AND NP) NOT INTERACT TOL_ENG
}

ESD.34g { @ The NMOS HV Tolerant I/O should have ESD3
  (TOL_ENMOS NOT INTERACT ESD3) NOT INTERACT ESDIMP
}
// ESD.35gU can not be checked by DRC


// Power Clamp
//============

PCL_GATE_W = ESD_GATE_W COIN INSIDE EDGE PCL_EGTE
PCL_HV_GATE_W = PCL_GATE_W INSIDE EDGE OD_33
PCL_LV_GATE_W = PCL_GATE_W NOT INSIDE EDGE OD_33
PCL_HV_GATE_W_EXP = EXPAND EDGE PCL_HV_GATE_W INSIDE BY GRID
PCL_LV_GATE_W_EXP = EXPAND EDGE PCL_LV_GATE_W INSIDE BY GRID
PCL_HV_GATE_W_EXPc = STAMP PCL_HV_GATE_W_EXP BY ENMOSc
PCL_LV_GATE_W_EXPc = STAMP PCL_LV_GATE_W_EXP BY ENMOSc

ESD.36g { @ Total finger width for 3.3V Power Clamp in same connection of drain >= ^ESD_36g um
  NET AREA RATIO PCL_HV_GATE_W_EXPc < ESD_36g
    [(AREA(PCL_HV_GATE_W_EXPc)/2)/GRID]
    RDB ESD.36g.rep PCL_HV_GATE_W_EXPc
}

ESD.37g { @ Total finger width for 2.5V/1.8V/1.2V/1.05V/1.0V Power Clamp in same connection of drain >= ^ESD_37g um
  NET AREA RATIO PCL_LV_GATE_W_EXPc < ESD_37g
    [(AREA(PCL_LV_GATE_W_EXPc)/2)/GRID]
    RDB ESD.37g.rep PCL_LV_GATE_W_EXPc
}

PCL_EGTE_33V = PCL_EGTE AND OD_33
PCL_EGTE_25V = PCL_EGTE AND OD_25
PCL_EGTE_18V = PCL_EGTE AND OD_18
PCL_EGTE_LV = PCL_EGTE NOT OD2

// ESD.38.1g is checked by ESD.38g
// ESD.38.2g is checked by ESD.38g
// ESD.38.3g is checked by ESD.38g
// ESD.38.4g is checked by ESD.38g
ESD.38g { @ Channel length for 3.3V NMOS/PMOS Power Clamp >= ^ESD_38g_33V um
@ Channel length of 2.5V Power Clamp >= ^ESD_38g_25V
@ Channel length of 1.8V Power Clamp >= ^ESD_38g_18V
@ Channel length of 1.2V/1.05V/1.0V Power Clamp >= ^ESD_38g_LV
  INT PCL_EGTE_33V < ESD_38g_33V ABUT < 90 SINGULAR REGION
  INT PCL_EGTE_25V < ESD_38g_25V ABUT < 90 SINGULAR REGION
  INT PCL_EGTE_18V < ESD_38g_18V ABUT < 90 SINGULAR REGION
  INT PCL_EGTE_LV < ESD_38g_LV ABUT < 90 SINGULAR REGION
}

ESD.39g { @ The 3.3V Power Clamp should have an unsilicided area on the drain side. 
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
          @ DRC only flags no RPO in this device.
  PCL_EGTE_33V NOT INTERACT RPO
}

ESD.40g { @ Overlap of RPO on the drain side to the poly gate for 3.3V Power Clamp == ^ESD_40g um
  PCL_EGTE_33V OUTSIDE RPO
  PCL_EGTE_W = PCL_EGTE_33V INSIDE EDGE OD
  X = PCL_EGTE_W INSIDE EDGE RPO
  Y = EXPAND EDGE X INSIDE BY ESD_40g
  PCL_EGTE_33V WITH EDGE X > 1
  (PCL_EGTE_33V AND RPO) XOR Y
}

ESD.41g { @ Width of the RPO on drain side for 3.3V power clamp >= ^ESD_41g um
		  @ ESD.41g and ESD.21g share same method, show up in pairs
  PCL_ENSD = (ENSD INTERACT PCL_EGTE_33V) AND RPO
  INT PCL_ENSD < ESD_41g ABUT < 90 SINGULAR REGION
}

ESD.42g { @ Space of poly to CO on source side for 3.3V Power Clamp >= ^ESD_42g um
		  @ ESD.42g and ESD.23g share same method, show up in pairs
  EXT ECO PCL_EGTE_33V < ESD_42g ABUT < 90 SINGULAR REGION
}

// 1.8V REGULAR IO
//=================
EGTE_RPO = EGTE INTERACT RPO
RegularIO_type2_NMOS = (ENMOS INTERACT RPO) NOT INTERACT EGTE_RPO
RegularIO_type2_PMOS = (EPMOS INTERACT RPO) NOT INTERACT EGTE_RPO
RegularIO_type2_MOS  = RegularIO_type2_NMOS OR RegularIO_type2_PMOS
RegularIO_type2_NMOS_DRAIN = ENSD_DRAIN AND RegularIO_type2_NMOS
RegularIO_type2_PMOS_DRAIN = EPSD_DRAIN AND RegularIO_type2_PMOS
RegularIO_type2_MOS_DRAIN = RegularIO_type2_NMOS_DRAIN OR RegularIO_type2_PMOS_DRAIN 
RegularIO_type2_NMOS_GATE = EGTE AND RegularIO_type2_NMOS
RegularIO_type2_PMOS_GATE = EGTE AND RegularIO_type2_PMOS
RegularIO_type2_GATE      = EGTE AND RegularIO_type2_MOS
RegularIO_type2_NMOS_GATE_W = ESD_GATE_W INSIDE EDGE RegularIO_type2_NMOS
RegularIO_type2_PMOS_GATE_W = ESD_GATE_W INSIDE EDGE RegularIO_type2_PMOS
RegularIO_type2_NMOS_GATE_W_EXP  = EXPAND EDGE RegularIO_type2_NMOS_GATE_W INSIDE BY GRID 
RegularIO_type2_PMOS_GATE_W_EXP  = EXPAND EDGE RegularIO_type2_PMOS_GATE_W INSIDE BY GRID 
RegularIO_type2_NMOS_GATE_W_EXPc = STAMP RegularIO_type2_NMOS_GATE_W_EXP BY ENMOSc
RegularIO_type2_PMOS_GATE_W_EXPc = STAMP RegularIO_type2_PMOS_GATE_W_EXP BY EPMOSc
HV_RegularIO_type2_NMOS_GATE_W = RegularIO_type2_NMOS_GATE_W INSIDE EDGE OD_18
HV_RegularIO_type2_PMOS_GATE_W = RegularIO_type2_PMOS_GATE_W INSIDE EDGE OD_18

ESD.44g { @ Total finger width for NMOS in same connection >= ^ESD_44g um
  NET AREA RATIO RegularIO_type2_NMOS_GATE_W_EXPc < ESD_44g
   [ ( AREA(RegularIO_type2_NMOS_GATE_W_EXPc) / 2 ) / GRID ]
   RDB ESD.44g.rep  RegularIO_type2_NMOS_GATE_W_EXPc
}

ESD.45g { @ Total finger width for PMOS in same connection >= ^ESD_45g um
  NET AREA RATIO RegularIO_type2_PMOS_GATE_W_EXPc < ESD_45g
   [ ( AREA(RegularIO_type2_PMOS_GATE_W_EXPc) / 2 ) / GRID ]
   RDB ESD.45g.rep  RegularIO_type2_PMOS_GATE_W_EXPc
}

ESD.46g { @ Channel length (in OD18) >= ^ESD_46g
  INT HV_RegularIO_type2_NMOS_GATE_W < ESD_46g ABUT < 90 REGION
  INT HV_RegularIO_type2_PMOS_GATE_W < ESD_46g ABUT < 90 REGION
}

ESD.47g { @ The NMOS and PMOS should have an unsilicided area on the drain side. 
          @ That is, the RPO mask should block the drain side of the device.
          @ (except the contact region which should remain silicided).
          @ DRC only flags no RPO in this device.
  (ENMOS OR EPMOS) NOT INTERACT (RPO NOT EGTE_RPO)
}

ESD.48g{ @ RPO on the drain side space to the poly gate = ^ESD_48g um
  X = ESD_GATE_W TOUCH OUTSIDE EDGE RegularIO_type2_MOS_DRAIN
  A = EXPAND EDGE X OUTSIDE BY ESD_48g  
  B = EXT RPO RegularIO_type2_GATE == ESD_48g ABUT < 90 SINGULAR REGION
  A XOR B
}

ESD.49g { @ Width of the RPO on the drain side for NMOS >= ^ESD_49g um
  A = RegularIO_type2_NMOS_DRAIN AND RPO 
  INT A < ESD_49g ABUT < 90 SINGULAR REGION
}

ESD.50g { @ Width of the RPO on the drain side for PMOS >= ^ESD_50g um
  A = RegularIO_type2_PMOS_DRAIN AND RPO 
  INT A < ESD_50g ABUT < 90 SINGULAR REGION
}

ESD.51g { @ Space of poly to CO on the source side >= ^ESD_51g um
  A = ESD_GATE_W TOUCH INSIDE EDGE RegularIO_type2_GATE
  EXT ECO A < ESD_51g ABUT < 90 REGION
}

ESD.52g { @ 1.8V regular IO INTERACT OD_25 or OD_33 is not recommended.
  RegularIO_type2_MOS INTERACT OD_25
  RegularIO_type2_MOS INTERACT OD_33
}

// 3.3V/2.5V POWER CLAMP(NCS)
//=============================
NCS_type2_NMOS = ((ENMOS INTERACT RPO) INTERACT EGTE_FULL_RPO) NOT INTERACT EGTE_PART_RPO
NCS_type2_NMOS_DRAIN = ENSD_DRAIN AND NCS_type2_NMOS
NCS_type2_NMOS_GATE = EGTE AND NCS_type2_NMOS
NCS_type2_NMOS_GATE_W = ESD_GATE_W INSIDE EDGE NCS_type2_NMOS
NCS_type2_NMOS_GATE_W_EXP  = EXPAND EDGE NCS_type2_NMOS_GATE_W INSIDE BY GRID 
NCS_type2_NMOS_GATE_W_EXPc = STAMP NCS_type2_NMOS_GATE_W_EXP BY ENMOSc
HV_NCS_type2_NMOS_GATE_W_33V = NCS_type2_NMOS_GATE_W INSIDE EDGE OD_33
HV_NCS_type2_NMOS_GATE_W_25V = NCS_type2_NMOS_GATE_W INSIDE EDGE OD_25

ESD.53g { @ Total finger width in same connection > ^ESD_53g um
   NET AREA RATIO NCS_type2_NMOS_GATE_W_EXPc < ESD_53g
   [ ( AREA(NCS_type2_NMOS_GATE_W_EXPc) / 2 ) / GRID ]
   RDB ESD.53g.rep  NCS_type2_NMOS_GATE_W_EXPc
}

// ESD.54.1g is checked by ESD.54g
// ESD.54.2g is checked by ESD.54g
ESD.54g { @ Channel length of 3.3V Power Clamp >= ^ESD_54g_33V
@ Channel length of 2.5V Power Clamp >= ^ESD_54g_25V
  INT HV_NCS_type2_NMOS_GATE_W_33V < ESD_54g_33V ABUT < 90 REGION
  INT HV_NCS_type2_NMOS_GATE_W_25V < ESD_54g_25V ABUT < 90 REGION
}

ESD.55g { @ The NMOS should have an unsilicided area on the drain/source side. 
          @ That is, the RPO mask should block the drain/source side of the device.
          @ (except the contact region which should remain silicided).
          @ DRC only flags no RPO in this device.
  NCS_type2_NMOS_GATE NOT INTERACT RPO
}

ESD.56g { @ Width of the RPO on the drain side for PMOS >= ^ESD_56g um
   A = NCS_type2_NMOS_DRAIN AND RPO 
   INT A < ESD_56g ABUT < 90 SINGULAR REGION
}

ESD.57g { @ Space of poly to CO on the source side >= ^ESD_57g um
   A = ESD_GATE_W TOUCH INSIDE EDGE NCS_type2_NMOS_GATE
   EXT ECO A < ESD_57g ABUT < 90 REGION
}
#ENDIF



// Analog Checks
//==============

POS11m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS11m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS11m_POCell =  POS11m_POCellIn AND POS11m_POCellOut
POS11m_POMarker = POi AND RRuleAnalog
POS11m_PO = ((( POS11m_POCell OR POS11m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS11m_GATE = ( GATE_NP AND POS11m_PO ) NOT OD2 
POS11m_NW = ( OD2 OR NWEL ) OR NTN 
PO.S.11m { @ Gate space to ( OD2 OR NW OR NTN ) in Core NMOS >= 1.2um
    EXT POS11m_GATE POS11m_NW < 1.2 ABUT < 90 SINGULAR REGION 
}

POEN1m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN1m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN1m_POCell =  POEN1m_POCellIn AND POEN1m_POCellOut
POEN1m_POMarker = POi AND RRuleAnalog
POEN1m_PO = ((( POEN1m_POCell OR POEN1m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN1m_GATE = ( GATE_PP AND POEN1m_PO ) NOT OD2
POEN1m_NW = NWEL NOT NTN  
PO.EN.1m { @ Gate enclosure by ( NW NOT NTN) in Core PMOS >= 1.0um
    ENC POEN1m_GATE POEN1m_NW < 1.0 ABUT < 90 SINGULAR REGION 
}

POEN2m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN2m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN2m_POCell =  POEN2m_POCellIn AND POEN2m_POCellOut
POEN2m_POMarker = POi AND RRuleAnalog
POEN2m_PO = ((( POEN2m_POCell OR POEN2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN2m_GATE = ( GATE_NP AND POEN2m_PO ) AND OD2
POEN2m_NW = OD2 NOT ( NWEL OR NTN ) 
PO.EN.2m { @ Gate enclosure by ( OD2 NOT ( NW OR NTN )) in IO NMOS >= 2.0um
    ENC POEN2m_GATE POEN2m_NW < 2.0 ABUT < 90 SINGULAR REGION 
}

POEN3m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEN3m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEN3m_POCell =  POEN3m_POCellIn AND POEN3m_POCellOut
POEN3m_POMarker = POi AND RRuleAnalog
POEN3m_PO = ((( POEN3m_POCell OR POEN3m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POEN3m_GATE = ( GATE_PP AND POEN3m_PO ) AND OD2
POEN3m_NW = ( NWEL AND OD2 ) NOT NTN
PO.EN.3m { @ Gate enclosure by ( NW AND OD2) NOT NTN in IO PMOS >= 2.0um
    ENC POEN3m_GATE POEN3m_NW < 2.0 ABUT < 90 SINGULAR REGION 
}


PP_EMOD = PACT AND BJTDMY
NP_EMOD = NACT AND BJTDMY
EMOD = PP_EMOD OR NP_EMOD
BJT.R.1 { @ RPO needs to cover 0.3um on EM OD edge from OD and STI sides
     X = ( SIZE EMOD BY 0.3 ) NOT ( SIZE EMOD BY -0.3 )
     Y = RPO INTERACT EMOD
     X XOR Y
}

RES2m_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
RES2m_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
RES2m_ODCell =  RES2m_ODCellIn AND RES2m_ODCellOut
RES2m_ODMarker = ODi AND RRuleAnalog
RES2m_OD = ((( RES2m_ODCell OR RES2m_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RES2m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
RES2m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
RES2m_POCell =  RES2m_POCellIn AND RES2m_POCellOut
RES2m_POMarker = POi AND RRuleAnalog
RES2m_PO = ((( RES2m_POCell OR RES2m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RES2m_ODRES = ODRES AND RES2m_OD
RES2m_PORES = PORES AND RES2m_PO
// RES.2m is checked by RES.2m:OD
RES.2m:OD { @ Width >= 0.4um and length >= 0.8um for unsilicided OD resistor
  INT RES2m_ODRES < 0.4 ABUT < 90 SINGULAR REGION
  RES_L = RES2m_ODRES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 0.8
  CHECK_RES = RES2m_ODRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 0.4 - GRID*2 ) INSIDE OF RES2m_ODRES STEP OD_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  Y = CHECK_RES INTERACT D
  Y NOT INSIDE DIODMY
}

// RES.2m is checked by RES.2m:PO
RES.2m:PO { @ Width >= 0.4um and length >= 0.8um for unsilicided PO resistor
  INT RES2m_PORES < 0.4 ABUT < 90 SINGULAR REGION
  RES_L = RES2m_PORES INSIDE EDGE RPO
  X = PATH LENGTH RES_L < 0.8
  CHECK_RES = RES2m_PORES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE RPO
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 0.4 - GRID*2 ) INSIDE OF RES2m_PORES STEP PO_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

NWRODR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRODR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRODR1m_NWCell =  NWRODR1m_NWCellIn AND NWRODR1m_NWCellOut
NWRODR1m_NWMarker = NWi AND RRuleAnalog
NWRODR1m_NW = ((( NWRODR1m_NWCell OR NWRODR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRODR1m_NWRES = ( NWRODR1m_NW AND NWRES ) AND NWDMY
NWROD.R.1m { @ Width >= 1.8um and length >= 20um for NW resistor with OD
  INT NWRODR1m_NWRES < 1.8 ABUT < 90 SINGULAR REGION
  RES_L = NWRODR1m_NWRES COIN INSIDE EDGE NWRODR1m_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRODR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRODR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}

NWRSTIR1m_NWCellIn = INSIDE CELL NWi CellsForRRuleAnalog  
NWRSTIR1m_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleAnalog 
NWRSTIR1m_NWCell =  NWRSTIR1m_NWCellIn AND NWRSTIR1m_NWCellOut
NWRSTIR1m_NWMarker = NWi AND RRuleAnalog
NWRSTIR1m_NW = ((( NWRSTIR1m_NWCell OR NWRSTIR1m_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleAnalog

NWRSTIR1m_NWRES = ( NWRSTIR1m_NW AND NWRES_STI ) AND NWDMY
NWRSTI.R.1m { @ Width >= 1.8um and length >= 20um for NW resistor under STI
  INT NWRSTIR1m_NWRES < 1.8 ABUT < 90 SINGULAR REGION
  RES_L = NWRSTIR1m_NWRES COIN INSIDE EDGE NWRSTIR1m_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRSTIR1m_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRSTIR1m_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}



//CTM CHECKS
//==========

VCAP = COPY VIA7
MCAP = COPY M8
MCAPx = COPY M8x
MBOT = COPY M7
MBOTx = COPY M7x
DMBOT = COPY DUM7
UTMCAP = M9 NOT CHIP    // empty

VCAP_CTM = VCAP AND CTM
VCAP_CBM = (VCAP AND CBM) NOT CTM

CTM.W.1 { @ Min. width of CTM 2 um. 
  INT CTM < 2 ABUT <90 SINGULAR REGION
}

CTM.W.2 { @ Max. width or length of CTM 100 um. 
  ENCLOSE RECTANGLE CTM 2 100.005 ORTHOGONAL ONLY
}

#IFDEF N80
CTM.S.1.S80 { @ Min. space between two CTMs 0.88 um. 
  EXT CTM < 0.88 ABUT <90 SINGULAR REGION
}
#ELSE
CTM.S.1 { @ Min. space between two CTMs 0.8 um. 
  EXT CTM < 0.8 ABUT <90 SINGULAR REGION
}
#ENDIF

CTM.R.4 { @ CTM must be an orthgonal rectangle. L shape for example is not allowed.
   NOT RECTANGLE CTM
}



//CBM CHECKS
//==========
#IFDEF N80
CTMDMY_S = AREA CTMDMY <= 44000
#ELSE
CTMDMY_S = AREA CTMDMY <= 40000
#ENDIF
CTMDMY_W = CTMDMY NOT CTMDMY_S
CBM_S = CBM AND CTMDMY_S
CBM_W = CBM AND CTMDMY_W
VCAP_CTMDMY = VCAP AND CTMDMY
MCAP_CTMDMY = MCAP AND CTMDMY
MCAPx_CTMDMY = MCAPx AND CTMDMY
MCAP_CTMDMY_S = MCAP AND CTMDMY_S
MCAPx_CTMDMY_S = MCAPx AND CTMDMY_S
MCAP_CTMDMY_W = MCAP AND CTMDMY_W
MCAPx_CTMDMY_W = MCAPx AND CTMDMY_W
MBOT_ICTMDMY = MBOT NOT OUTSIDE CTMDMY
MCAP_ICTMDMY = MCAP NOT OUTSIDE CTMDMY

UTMCAP_ICTMDMY = UTMCAP NOT OUTSIDE CTMDMY
UTMCAP_CTMDMY  = UTMCAP AND CTMDMY

CBM.W.1 { @ Min. width of CBM 2.8 um. 
  INT CBM < 2.8 ABUT <90 SINGULAR REGION
}

CBM.W.2 { @ Max. width (for either length or width) 210 um. For example, 10 m x 211 m CBM is forbidden. 
	  @ For CBM of capacitor larger than 210 x 210 um2, please use parallel combination of smaller capacitors. 
  ENCLOSE RECTANGLE CBM 2.8 210.005 ORTHOGONAL ONLY
}


#IFDEF N80
CBM.S.1.1.S80 { @ Min. space between two CBM inside CTMDMY with area <= 44000 um2: 2.2 um. 
  EXT CBM_S < 2.2 ABUT <90 SINGULAR REGION
}
CBM.S.1.2.S80 { @ Min. space between two CBM inside CTMDMY with area > 44000 um2: 2.86 um 
  EXT CBM_W < 2.86 ABUT <90 SINGULAR REGION
}
CBM.EN.1.S80 { @ Min. CTM encolsure by CBM 0.44 um. CTM cutting CBM is not allowed.
  ENC CTM CBM < 0.44 ABUT < 90 SINGULAR REGION
  NOT CTM CBM     
}

#ELSE
CBM.S.1.1 { @ Min. space between two CBM inside CTMDMY with area <= 40000 um2: 2 um. 
  EXT CBM_S < 2 ABUT <90 SINGULAR REGION
}
CBM.S.1.2 { @ Min. space between two CBM inside CTMDMY with area > 40000 um2: 2.6 um 
  EXT CBM_W < 2.6 ABUT <90 SINGULAR REGION
}
CBM.EN.1 { @ Min. CTM encolsure by CBM 0.4 um. CTM cutting CBM is not allowed.
  ENC CTM CBM < 0.4 ABUT < 90 SINGULAR REGION
  NOT CTM CBM     
}
#ENDIF


CBM.EN.2 { @ CTMDMY is equal to CBM layer sizing up 10 um on each side.
           @ DRC checking layer(CTMDMY,GDS layer 148) is needed to specify MiM capacitor region.
  A = SIZE CBM BY 10
  A XOR CTMDMY
}


CBM.S.2 { @ Min. CBM space to top Mx  0.5 um.
  EXT MBOT CBM < 0.5 ABUT<90 SINGULAR REGION
}


CBM.R.2 { @ top Mx (including top dummy Mx) interacting with CBM not allowed.
  MBOTx AND CBM
}

VARIABLE M1_DN_5 0.15

M1DN5_CBM_MERGE = SIZE (SIZE CBM BY 25) BY -25
M1DN5_CHECK_CBM = AREA M1DN5_CBM_MERGE >= 200 * 200

M1DN5_M1_CHECK = M1x AND M1DN5_CHECK_CBM
M1DN5_M2_CHECK = M2x AND M1DN5_CHECK_CBM
M1DN5_M3_CHECK = M3x AND M1DN5_CHECK_CBM
CONNECT M1DN5_CHECK_CBM M1DN5_M1_CHECK
CONNECT M1DN5_CHECK_CBM M1DN5_M2_CHECK
CONNECT M1DN5_CHECK_CBM M1DN5_M3_CHECK
    
M1.DN.5 { @ It is not allowed to have local density < ^M1_DN_5 of all 3 consecutive metal (M1,M2,M3) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um
    A = NET AREA RATIO M1DN5_CHECK_CBM M1DN5_M1_CHECK < M1_DN_5
        [AREA(M1DN5_M1_CHECK)/AREA(M1DN5_CHECK_CBM)]
        RDB M1.DN.5.M1.density
    B = NET AREA RATIO M1DN5_CHECK_CBM M1DN5_M2_CHECK < M1_DN_5
        [AREA(M1DN5_M2_CHECK)/AREA(M1DN5_CHECK_CBM)]
        RDB M1.DN.5.M2.density
    C = NET AREA RATIO M1DN5_CHECK_CBM M1DN5_M3_CHECK < M1_DN_5
        [AREA(M1DN5_M3_CHECK)/AREA(M1DN5_CHECK_CBM)]
        RDB M1.DN.5.M3.density
    (A AND B) AND C
}

VARIABLE M2_DN_5 0.15

M2DN5_CBM_MERGE = SIZE (SIZE CBM BY 25) BY -25
M2DN5_CHECK_CBM = AREA M2DN5_CBM_MERGE >= 200 * 200

M2DN5_M2_CHECK = M2x AND M2DN5_CHECK_CBM
M2DN5_M3_CHECK = M3x AND M2DN5_CHECK_CBM
M2DN5_M4_CHECK = M4x AND M2DN5_CHECK_CBM
CONNECT M2DN5_CHECK_CBM M2DN5_M2_CHECK
CONNECT M2DN5_CHECK_CBM M2DN5_M3_CHECK
CONNECT M2DN5_CHECK_CBM M2DN5_M4_CHECK
    
M2.DN.5 { @ It is not allowed to have local density < ^M2_DN_5 of all 3 consecutive metal (M2,M3,M4) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um
    A = NET AREA RATIO M2DN5_CHECK_CBM M2DN5_M2_CHECK < M2_DN_5
        [AREA(M2DN5_M2_CHECK)/AREA(M2DN5_CHECK_CBM)]
        RDB M2.DN.5.M2.density
    B = NET AREA RATIO M2DN5_CHECK_CBM M2DN5_M3_CHECK < M2_DN_5
        [AREA(M2DN5_M3_CHECK)/AREA(M2DN5_CHECK_CBM)]
        RDB M2.DN.5.M3.density
    C = NET AREA RATIO M2DN5_CHECK_CBM M2DN5_M4_CHECK < M2_DN_5
        [AREA(M2DN5_M4_CHECK)/AREA(M2DN5_CHECK_CBM)]
        RDB M2.DN.5.M4.density
    (A AND B) AND C
}

VARIABLE M3_DN_5 0.15

M3DN5_CBM_MERGE = SIZE (SIZE CBM BY 25) BY -25
M3DN5_CHECK_CBM = AREA M3DN5_CBM_MERGE >= 200 * 200

M3DN5_M3_CHECK = M3x AND M3DN5_CHECK_CBM
M3DN5_M4_CHECK = M4x AND M3DN5_CHECK_CBM
M3DN5_M5_CHECK = M5x AND M3DN5_CHECK_CBM
CONNECT M3DN5_CHECK_CBM M3DN5_M3_CHECK
CONNECT M3DN5_CHECK_CBM M3DN5_M4_CHECK
CONNECT M3DN5_CHECK_CBM M3DN5_M5_CHECK
    
M3.DN.5 { @ It is not allowed to have local density < ^M3_DN_5 of all 3 consecutive metal (M3,M4,M5) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um
    A = NET AREA RATIO M3DN5_CHECK_CBM M3DN5_M3_CHECK < M3_DN_5
        [AREA(M3DN5_M3_CHECK)/AREA(M3DN5_CHECK_CBM)]
        RDB M3.DN.5.M3.density
    B = NET AREA RATIO M3DN5_CHECK_CBM M3DN5_M4_CHECK < M3_DN_5
        [AREA(M3DN5_M4_CHECK)/AREA(M3DN5_CHECK_CBM)]
        RDB M3.DN.5.M4.density
    C = NET AREA RATIO M3DN5_CHECK_CBM M3DN5_M5_CHECK < M3_DN_5
        [AREA(M3DN5_M5_CHECK)/AREA(M3DN5_CHECK_CBM)]
        RDB M3.DN.5.M5.density
    (A AND B) AND C
}

VARIABLE M4_DN_5 0.15

M4DN5_CBM_MERGE = SIZE (SIZE CBM BY 25) BY -25
M4DN5_CHECK_CBM = AREA M4DN5_CBM_MERGE >= 200 * 200

M4DN5_M4_CHECK = M4x AND M4DN5_CHECK_CBM
M4DN5_M5_CHECK = M5x AND M4DN5_CHECK_CBM
M4DN5_M6_CHECK = M6x AND M4DN5_CHECK_CBM
CONNECT M4DN5_CHECK_CBM M4DN5_M4_CHECK
CONNECT M4DN5_CHECK_CBM M4DN5_M5_CHECK
CONNECT M4DN5_CHECK_CBM M4DN5_M6_CHECK
    
M4.DN.5 { @ It is not allowed to have local density < ^M4_DN_5 of all 3 consecutive metal (M4,M5,M6) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um
    A = NET AREA RATIO M4DN5_CHECK_CBM M4DN5_M4_CHECK < M4_DN_5
        [AREA(M4DN5_M4_CHECK)/AREA(M4DN5_CHECK_CBM)]
        RDB M4.DN.5.M4.density
    B = NET AREA RATIO M4DN5_CHECK_CBM M4DN5_M5_CHECK < M4_DN_5
        [AREA(M4DN5_M5_CHECK)/AREA(M4DN5_CHECK_CBM)]
        RDB M4.DN.5.M5.density
    C = NET AREA RATIO M4DN5_CHECK_CBM M4DN5_M6_CHECK < M4_DN_5
        [AREA(M4DN5_M6_CHECK)/AREA(M4DN5_CHECK_CBM)]
        RDB M4.DN.5.M6.density
    (A AND B) AND C
}

VARIABLE M5_DN_5 0.15

M5DN5_CBM_MERGE = SIZE (SIZE CBM BY 25) BY -25
M5DN5_CHECK_CBM = AREA M5DN5_CBM_MERGE >= 200 * 200

M5DN5_M5_CHECK = M5x AND M5DN5_CHECK_CBM
M5DN5_M6_CHECK = M6x AND M5DN5_CHECK_CBM
M5DN5_M7_CHECK = M7x AND M5DN5_CHECK_CBM
CONNECT M5DN5_CHECK_CBM M5DN5_M5_CHECK
CONNECT M5DN5_CHECK_CBM M5DN5_M6_CHECK
CONNECT M5DN5_CHECK_CBM M5DN5_M7_CHECK
    
M5.DN.5 { @ It is not allowed to have local density < ^M5_DN_5 of all 3 consecutive metal (M5,M6,M7) under ((CBM SIZING 25) SIZING -25) whose size is >= 200um X 200um
    A = NET AREA RATIO M5DN5_CHECK_CBM M5DN5_M5_CHECK < M5_DN_5
        [AREA(M5DN5_M5_CHECK)/AREA(M5DN5_CHECK_CBM)]
        RDB M5.DN.5.M5.density
    B = NET AREA RATIO M5DN5_CHECK_CBM M5DN5_M6_CHECK < M5_DN_5
        [AREA(M5DN5_M6_CHECK)/AREA(M5DN5_CHECK_CBM)]
        RDB M5.DN.5.M6.density
    C = NET AREA RATIO M5DN5_CHECK_CBM M5DN5_M7_CHECK < M5_DN_5
        [AREA(M5DN5_M7_CHECK)/AREA(M5DN5_CHECK_CBM)]
        RDB M5.DN.5.M7.density
    (A AND B) AND C
}












#IFDEF N80  
VIAn.S.3 { @ Mim {VIAn inside CBM But outside CTM} space to CTM 0.33 um.  
  EXT CTM VCAP_CBM < 0.33 ABUT < 90 SINGULAR REGION
}
#ELSE
VIAn.S.3 { @ Mim {VIAn inside CBM But outside CTM} space to CTM 0.3 um.  
  EXT CTM VCAP_CBM < 0.3 ABUT < 90 SINGULAR REGION
}
#ENDIF
VIAn.S.4 { @ Min. space between two VIAn inside CTM 0.54 um.
  EXT VCAP_CTM < 0.54 ABUT < 90 SINGULAR REGION
}


VIAn.S.5 { @ Min. space between two VIAn inside CBM 0.54 um.
  EXT VCAP_CBM < 0.54 ABUT < 90 SINGULAR REGION
}


#IFDEF N80
VIAn.EN.3 { @ Min. CTM enclosure of VIAn 0.26 um.
  ENC VCAP_CTM CTM < 0.26 ABUT<90 SINGULAR REGION
  CUT VCAP CTM    
}
VIAn.EN.4 { @ Min. CBM enclosure of VIAn 0.22 um.
  ENC VCAP_CBM CBM < 0.22 ABUT<90 SINGULAR REGION
  CUT VCAP CBM 
}
#ELSE
VIAn.EN.3 { @ Min. CTM enclosure of VIAn 0.24 um.
  ENC VCAP_CTM CTM < 0.24 ABUT<90 SINGULAR REGION
  CUT VCAP CTM    
}
VIAn.EN.4 { @ Min. CBM enclosure of VIAn 0.2 um.
  ENC VCAP_CBM CBM < 0.2 ABUT<90 SINGULAR REGION
  CUT VCAP CBM 
}
#ENDIF

VIAn.R.7 { @ At least two VIAn's are required to connect either a CTM OR a CBM.
  CTM ENCLOSE VCAP == 1
  CBM ENCLOSE VCAP_CBM == 1
  (MCAP AND CTM) ENCLOSE VCAP == 1
  (MCAP AND CBM) ENCLOSE VCAP == 1
  A = (MCAP_ICTMDMY AND MBOT_ICTMDMY) ENCLOSE VCAP == 1
  VCAP_CTMDMY INTERACT A
}





Mn.W.4 { @ Min. width of Mn [first metal above MiM capacitor connected to CTM OR CBM] inside CTMDMY region 0.84 um.
  A = NET AREA RATIO M8 CTM > 0
  B = NET AREA RATIO M8 CBM > 0
  C = INT (A OR B) < 0.84 ABUT < 90 SINGULAR REGION
  C AND CTMDMY
}

#IFDEF N80
Mn.S.4 { @ Min. space between two Mn [first metal above MiM capacitor connected to CTM OR CBM] inside CTMDMY region 0.92 um.
  EXT MCAP_CTMDMY < 0.92 ABUT < 90 SINGULAR REGION
}
#ELSE
Mn.S.4 { @ Min. space between two Mn [first metal above MiM capacitor connected to CTM OR CBM] inside CTMDMY region 0.84 um.
  EXT MCAP_CTMDMY < 0.84 ABUT < 90 SINGULAR REGION
}
#ENDIF

MCAP_S5 = SHRINK (SHRINK (SHRINK (SHRINK MCAP_CTMDMY RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
MCAP_G5 = GROW (GROW (GROW (GROW MCAP_S5 RIGHT BY 5) LEFT BY 5) TOP BY 5) BOTTOM BY 5
MCAP_Wide = MCAP_G5 AND MCAP
MCAP_Exp = SIZE MCAP_Wide BY 2 INSIDE OF MCAP STEP 0.644
MCAP_Branch = MCAP_Exp NOT MCAP_Wide
MCAP_Branch_edge = MCAP_Branch COIN INSIDE EDGE MCAP
MCAP_Check = MCAP AND (SIZE MCAP_Exp BY 1.2)
MCAP_Else = MCAP_Check NOT INTERACT MCAP_Exp
MCAP_Extend = MCAP_Check NOT MCAP_Exp 
CONNECT MCAP_Wide  MCAP
CONNECT MCAP_Check MCAP

Mn.S.5 { @ Inside CTMDMY, min. Mn space to wide Mn (both width and length > 10 um) or wide Mn branch (a small piece of Mn is connected to wide Mn within 2.0 um) 1.2 um.
  EXT MCAP_Wide MCAP_Check < 1.2 ABUT >0 <89.5 NOT CONNECTED REGION
  EXT MCAP_Branch_edge MCAP_Else < 1.2 ABUT >0 <89.5 OPPOSITE REGION
  EXT MCAP_Branch_edge MCAP_Else < 1.2 ABUT >0 <89.5 CORNER REGION
  EXT MCAP_Branch_edge MCAP_Else < 1.2 ABUT >0 <89.5 PROJ==0 REGION
  A = EXT MCAP_Exp < 1.2 ABUT > 0 < 89.5 SPACE REGION
  A NOT INTERACT MCAP_Extend
}
DISCONNECT

Mn.EN.3 { @ Min. Mn [first metal above MiM capacitor connected to CTM OR CBM] enclosure of [VIAn inside CTMDMY] inside CTMDMY 0.1 um
  ENC VCAP_CTMDMY MCAP < 0.1 ABUT<90 OUTSIDE ALSO SINGULAR REGION
}

// Mn.DN.5 is checked by Mn.DN.5:L
// Mn.DN.5a is checked by Mn.DN.5:L
Mn.DN.5:L { @ Min. Mn [first metal above MiM capacitor connected to CTM OR CBM] inside CTMDMY density range over any 200um x 200um area (checked by stepping in 100um increments) 50 %. This rule is only applied to the overlapped area of checking window and CTMDMY >= 2500 um2and the edge width of overlapped area is at least 20um.
  ERROR_WINDOW = DENSITY MCAPx_CTMDMY CTMDMY < 0.5 WINDOW 200 STEP 100 BACKUP
    [ AREA(MCAPx_CTMDMY)/AREA(CTMDMY) ]
  A = AREA (ERROR_WINDOW AND CTMDMY) >= 2500
  K = SIZE A BY 10 UNDEROVER
  DENSITY K MCAPx_CTMDMY CTMDMY < 0.5 WINDOW 200 STEP 100 BACKUP PRINT Mn.DN.5L.density 
    [ !AREA(K)+AREA(MCAPx_CTMDMY)/AREA(CTMDMY) ]

}

// Mn.DN.5 is checked by Mn.DN.5:H
// Mn.DN.5b is checked by Mn.DN.5:H
Mn.DN.5:H { @ Max. Mn [first metal above MiM capacitor connected to CTM OR CBM] inside CTMDMY density range over any 100um x 100um area (checked by stepping in 50um increments) 80 %. This rule is only applied to the overlapped area of checking window and CTMDMY >= 2500 um2
  ERROR_WINDOW = DENSITY MCAPx_CTMDMY CTMDMY > 0.8 WINDOW 100 STEP 50 BACKUP 
    [ AREA(MCAPx_CTMDMY)/AREA(CTMDMY) ]
  K = AREA (ERROR_WINDOW AND CTMDMY) >= 2500
  DENSITY K MCAPx_CTMDMY CTMDMY > 0.8 WINDOW 100 STEP 50 BACKUP PRINT Mn.DN.5H.density
    [ !!AREA(K)*AREA(MCAPx_CTMDMY)/AREA(CTMDMY) ]
}


#IFDEF UTM
//M8 CHECKS
//==========
MM_M8.W.1 { @ Min. M8 width ^M8_W_1 um 
  INT M8 < M8_W_1 ABUT < 90 SINGULAR REGION
}
MM_M8.W.2 { @ Max. width 12 um, except bond pad and INDDMY  
  SIZE (M8_MAX_WIDTH NOT INDDMY) BY M8_W_2 /2 UNDEROVER TRUNCATE M8_W_2 /2
}
  
//UTM CHECKS
//==========
  
VIAn.EN.5 { @ Min. [VIAn inside UTM] enclosure by [Mn Or Mx] ^VIAn_EN_5 um.
  ENC VIA8 M8 < VIAn_EN_5 ABUT <90 SINGULAR 
  VIA8 NOT M8
}

VIAn.R.9 { @ At least two VIA8 with space <= ^VIAn_R_9 um is required to connect UTM9 and M8.
  M9OvpM8 = M9 AND M8
  Check_VIA8 = VIA8_EXD INTERACT M9OvpM8
  VIA8Merge = SIZE Check_VIA8 BY (VIAn_R_9/2) INSIDE OF M9OvpM8 STEP 0.25
  VIA8Merge2 = VIA8Merge ENCLOSE Check_VIA8 >= 2
  Good_VIA8 = Check_VIA8 AND VIA8Merge2
  GM9OvpM8 = M9OvpM8 INTERACT Good_VIA8
  Check_VIA8 OUTSIDE GM9OvpM8
}
  
  
UTM_MAX_WIDTH = M9_MAX_WIDTH NOT (SIZE INDDMY BY 18) 
IND_UTM = M9 AND INDDMY // UTM inside INDDMY 
UTM_Wide = (SIZE IND_UTM BY 12/2 UNDEROVER TRUNCATE 12/2) AND IND_UTM
IND_UTM_A = ENC IND_UTM INDDMY < 0.01 ABUT>0<135 INTERSECTING ONLY REGION 
IND_UTM_B = M9 TOUCH OUTSIDE EDGE IND_UTM_A
IND_UTM_C = INT IND_UTM_B < 30.005 OPPOSITE REGION
IND_UTM_core = IND_UTM NOT IND_UTM_C // core inductor metal

UTM.W.1 { @ Min. UTM width ^UTM_W_1 um. 
  INT M9 < UTM_W_1 ABUT < 90 SINGULAR REGION
}
UTM.W.2 { @ Max. UTM width (except bond pad and INDDMY) outside INDDMY and bond pad ^UTM_W_2 um.
    
  SIZE UTM_MAX_WIDTH BY UTM_W_2/2 UNDEROVER
}

UTM.W.3 { @ Max. UTM width inside INDDMY ^UTM_W_3 um.
  SIZE IND_UTM_core BY UTM_W_3/2 + GRID UNDEROVER
}

UTM.W.4 { @ Max. dimension (either W or L) of an INDDMY region ^UTM_W_4 um
  ENCLOSE RECTANGLE INDDMY GRID UTM_W_4 + GRID ORTHOGONAL ONLY
}

//UTM.W.5 checked by Mn.W.4 
UTM.S.1 { @ Min. UTM space ^UTM_S_1 um.
  EXT M9 < UTM_S_1 ABUT < 90 SINGULAR REGION
}

UTM.S.2 { @ Min. UTM space inside INDDMY ^UTM_S_2 um, at least one metal width >= ^UTM_S_2A um and parallel length >= ^UTM_S_2A um.
  Y = EXT UTM_Wide IND_UTM < UTM_S_2 > UTM_S_2 - GRID OPPOSITE REGION MEASURE ALL ANGLED == 2
  X = ( EXT UTM_Wide IND_UTM < UTM_S_2 OPPOSITE REGION MEASURE ALL ) NOT Y
  ENCLOSE RECTANGLE X GRID UTM_S_2A + GRID
}
  
  
UTM.EN.1 { @ Min. UTM region enclosure of VIAn(VIA8) ^UTM_EN_1 um.
  ENC VIA8 M9 < UTM_EN_1 ABUT<90 SINGULAR
  NOT VIA8 M9
}

UTM.EN.2 { @ Min. UTM region enclosure of VIAn(VIA8) {at least two oppsite side} ^UTM_EN_2 um.
  X = RECTANGLE ENCLOSURE VIA8 M9 ABUT<90 SINGULAR GOOD UTM_EN_1 UTM_EN_2 OPPOSITE UTM_EN_1 UTM_EN_2 OPPOSITE
  Y = ENC [X] M9 < UTM_EN_2 ABUT< 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < 0.36 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}



//UTM.EN.3 checked by Mn.EN.3 

  
UTM.A.1 { @ Min. area of UTM ^UTM_A_1 um2.
  AREA M9 < UTM_A_1
}

UTM.A.2 { @ Min. UTM enclosed area ^UTM_A_2 um2. 
  UTMHO = HOLES M9 INNER
  UTMHOC = UTMHO NOT M9
  AREA UTMHOC < UTM_A_2
}
    
    
CLEAR_REGION = (SIZE INDDMY BY 18 ) NOT INDDMY
// UTM.R.2 is checked by UTM.R.2.1
UTM.R.2.1 { @ It's not allowed to have routing metal layers in the 18um clear region except 
           @ UTM, and Mtop-1 which is connected to inductor 
  IND_CO = CO INSIDE INDDMY	       
  ((M1x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION)	NOT INTERACT IND_CO

  (M2x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION

  (M3x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION

  (M4x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION

  (M5x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION

  (M6x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION

  IND_VIA7 = VIA7 INSIDE INDDMY
  ((M7x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION)	NOT INTERACT IND_VIA7

  IND_VIA8 = VIA8 INSIDE INDDMY
  ((M8x INTERACT CLEAR_REGION) NOT INSIDE CLEAR_REGION)	NOT INTERACT IND_VIA8

}
// UTM.R.2 is checked by UTM.R.2.2:VIA 
UTM.R.2.2:VIA { @ It's not allowed to have via 1~top-1 in the 18um clear region
 CLEAR_REGION AND VIA1i
 CLEAR_REGION AND VIA2i
 CLEAR_REGION AND VIA3i
 CLEAR_REGION AND VIA4i
 CLEAR_REGION AND VIA5i
 CLEAR_REGION AND VIA6i
 CLEAR_REGION AND VIA7i
 CLEAR_REGION AND VIA8i
}

CLEAR_REGION_NO_CORNER = EXPAND EDGE INDDMY OUTSIDE BY 18
    
PIN_OUT_METAL1 = (M1x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL1_EXP  = SIZE PIN_OUT_METAL1  BY 20
PIN_OUT_METAL2 = (M2x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL2_EXP  = SIZE PIN_OUT_METAL2  BY 20
PIN_OUT_METAL3 = (M3x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL3_EXP  = SIZE PIN_OUT_METAL3  BY 20
PIN_OUT_METAL4 = (M4x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL4_EXP  = SIZE PIN_OUT_METAL4  BY 20
PIN_OUT_METAL5 = (M5x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL5_EXP  = SIZE PIN_OUT_METAL5  BY 20
PIN_OUT_METAL6 = (M6x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL6_EXP  = SIZE PIN_OUT_METAL6  BY 20
PIN_OUT_METAL7 = (M7x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL7_EXP  = SIZE PIN_OUT_METAL7  BY 20
PIN_OUT_METAL8 = (M8x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL8_EXP  = SIZE PIN_OUT_METAL8  BY 20
PIN_OUT_METAL9 = (M9x CUT INDDMY) AND CLEAR_REGION_NO_CORNER
PIN_OUT_METAL9_EXP  = SIZE PIN_OUT_METAL9  BY 20

PIN_OUT_EXCL9 = COPY PIN_OUT_METAL9_EXP 

PIN_OUT_EXCL8 = PIN_OUT_METAL8_EXP OR PIN_OUT_EXCL9

PIN_OUT_EXCL7 = PIN_OUT_METAL7_EXP OR PIN_OUT_EXCL8

PIN_OUT_EXCL6 = PIN_OUT_METAL6_EXP OR PIN_OUT_EXCL7

PIN_OUT_EXCL5 = PIN_OUT_METAL5_EXP OR PIN_OUT_EXCL6

PIN_OUT_EXCL4 = PIN_OUT_METAL4_EXP OR PIN_OUT_EXCL5

PIN_OUT_EXCL3 = PIN_OUT_METAL3_EXP OR PIN_OUT_EXCL4

PIN_OUT_EXCL2 = PIN_OUT_METAL2_EXP OR PIN_OUT_EXCL3

PIN_OUT_EXCL1 = PIN_OUT_METAL1_EXP OR PIN_OUT_EXCL2


// UTM.R.2 is checked by UTM.R.2.3:M1
UTM.R.2.3:M1 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL1 
  CR_EMPTY1 = CLEAR_REGION_N NOT M1x
  ENCLOSE RECTANGLE CR_EMPTY1 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M2
UTM.R.2.3:M2 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL2 
  CR_EMPTY2 = CLEAR_REGION_N NOT M2x
  ENCLOSE RECTANGLE CR_EMPTY2 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M3
UTM.R.2.3:M3 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL3 
  CR_EMPTY3 = CLEAR_REGION_N NOT M3x
  ENCLOSE RECTANGLE CR_EMPTY3 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M4
UTM.R.2.3:M4 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL4 
  CR_EMPTY4 = CLEAR_REGION_N NOT M4x
  ENCLOSE RECTANGLE CR_EMPTY4 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M5
UTM.R.2.3:M5 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL5 
  CR_EMPTY5 = CLEAR_REGION_N NOT M5x
  ENCLOSE RECTANGLE CR_EMPTY5 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M6
UTM.R.2.3:M6 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL6 
  CR_EMPTY6 = CLEAR_REGION_N NOT M6x
  ENCLOSE RECTANGLE CR_EMPTY6 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M7
UTM.R.2.3:M7 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL7 
  CR_EMPTY7 = CLEAR_REGION_N NOT M7x
  ENCLOSE RECTANGLE CR_EMPTY7 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M8
UTM.R.2.3:M8 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL8 
  CR_EMPTY8 = CLEAR_REGION_N NOT M8x
  ENCLOSE RECTANGLE CR_EMPTY8 9 9    
}    
// UTM.R.2 is checked by UTM.R.2.3:M9
UTM.R.2.3:M9 { @ Empty area in the 18um clear region should be less than 9umx9um
  CLEAR_REGION_N = CLEAR_REGION_NO_CORNER NOT PIN_OUT_EXCL9 
  CR_EMPTY9 = CLEAR_REGION_N NOT M9x
  ENCLOSE RECTANGLE CR_EMPTY9 9 9    
}    


UTM.R.3 { @ Except for inductor structure itself (include via, under metal connect to inductor and IND guard ring inside INDDMY), all other active devices, passive devices, interconnect metal lines, any dummy metals and vias are not allowed inside an INDDMY region.
  INDDMYI = SIZE INDDMY BY -5 //exclude IND guard ring 

  INDDMY AND NWEL
  INDDMYI AND ALL_OD
  INDDMYI AND ALL_POLY
  INDDMYI AND CO

  IND_VIA8 = VIA8 AND IND_UTM
  CORE_VIA8 = VIA8 NOT IND_VIA8
  CORE_VIA8 AND INDDMY
  IND_M8 = M8 INTERACT IND_VIA8
  CORE_M8 = M8 NOT IND_M8
  CORE_M8 AND INDDMY

  IND_VIA7 = VIA7 AND IND_M8
  CORE_VIA7 = VIA7 NOT IND_VIA7
  CORE_VIA7 AND INDDMY
  IND_M7 = M7 INTERACT IND_VIA7
  CORE_M7 = M7 NOT IND_M7
  CORE_M7 AND INDDMY
  IND_VIA6 = VIA6 AND IND_M7
  CORE_VIA6 = VIA6 NOT IND_VIA6
  CORE_VIA6 AND INDDMY
  IND_M6 = M6 INTERACT IND_VIA6
  CORE_M6 = M6 NOT IND_M6
  CORE_M6 AND INDDMY
  IND_VIA5 = VIA5 AND IND_M6
  CORE_VIA5 = VIA5 NOT IND_VIA5
  CORE_VIA5 AND INDDMY
  IND_M5 = M5 INTERACT IND_VIA5
  CORE_M5 = M5 NOT IND_M5
  CORE_M5 AND INDDMY
  IND_VIA4 = VIA4 AND IND_M5
  CORE_VIA4 = VIA4 NOT IND_VIA4
  CORE_VIA4 AND INDDMY
  IND_M4 = M4 INTERACT IND_VIA4
  CORE_M4 = M4 NOT IND_M4
  CORE_M4 AND INDDMY
  IND_VIA3 = VIA3 AND IND_M4
  CORE_VIA3 = VIA3 NOT IND_VIA3
  CORE_VIA3 AND INDDMY
  IND_M3 = M3 INTERACT IND_VIA3
  CORE_M3 = M3 NOT IND_M3
  CORE_M3 AND INDDMY

  IND_VIA2 = VIA2 AND IND_M3
  CORE_VIA2 = VIA2 NOT IND_VIA2
  CORE_VIA2 AND INDDMYI
  IND_M2 = M2 INTERACT IND_VIA2
  CORE_M2 = M2 NOT IND_M2
  CORE_M2 AND INDDMYI
  IND_VIA1 = VIA1 AND IND_M2
  CORE_VIA1 = VIA1 NOT IND_VIA1
  CORE_VIA1 AND INDDMYI
  IND_M1 = M1 INTERACT IND_VIA1
  CORE_M1 = M1 NOT IND_M1
  CORE_M1 AND INDDMYI
}


//UTM.R.6 can not be checked.

  
UTM.R.8 { @ At leaset 4 VIAn are required inside INDDMY to connect the (Mn OR Mx) and inductor. 
    (IND_UTM AND M8 ) INTERACT VIA8 < 4 
}




// UTM.DN.1 is checked by UTM.DN.1:L
// UTM.DN.1a is checked by UTM.DN.1:L
UTM.DN.1:L { @ UTM area coverage must be > 20% range over 100umx100um area by step 50um 
  ERR_WIN = DENSITY M9_NOT_EXC_L CHIP_NOT_M9_EXC_L < 0.2 WINDOW 100 STEP 50 BACKUP PRINT UTM.DN.1L.density 
                [ AREA(M9_NOT_EXC_L)/AREA(CHIP_NOT_M9_EXC_L) ]
  SIZE (ERR_WIN NOT M9_EXC_L2) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
}
M9_EXC_IND_H = ((METAL_DEN_EXC_H OR MTOP_EXC) OR LMARK ) OR INDDMY_EXCL
CHIP_NOT_M9_EXC_IND_H = CHIP NOT M9_EXC_IND_H  // For high density limit
M9_NOT_EXC_IND_H = M9x NOT M9_EXC_IND_H
// UTM.DN.1 is checked by UTM.DN.1:H
// UTM.DN.1b is checked by UTM.DN.1:H
UTM.DN.1:H { @ UTM area coverage must be <= 80% range over any 100umx100um area by step 50um
  ERR_WIN = DENSITY M9_NOT_EXC_IND_H CHIP_NOT_M9_EXC_IND_H > 0.8 WINDOW 100 STEP 50 BACKUP PRINT UTM.DN.1H.density
    [ AREA(M9_NOT_EXC_IND_H)/AREA(CHIP_NOT_M9_EXC_IND_H) ] 
  SIZE (ERR_WIN NOT M9_EXC_IND_H) BY (25-0.002)/2 UNDEROVER TRUNCATE (25-0.002)/2
}
  
#IFDEF FULL_CHIP
// UTM.DN.2 is checked by UTM.DN.2:L
// UTM.DN.2a is checked by UTM.DN.2:L
UTM.DN.2:L { @ Min. UTM metal density over the whole chip 20% 
  DENSITY M9x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.2L.density
}
// UTM.DN.2 is checked by UTM.DN.2:H
// UTM.DN.2b is checked by UTM.DN.2:H
UTM.DN.2:H { @ Max. UTM metal density over the whole chip 70%  
  DENSITY M9x > 0.7 INSIDE OF LAYER CHIP PRINT UTM.DN.2H.density
}
UTM.DN.3 { @ Min. metal density over the whole chip 20% 
  DENSITY M1x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M1.density
  DENSITY M2x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M2.density
  DENSITY M3x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M3.density
  DENSITY M4x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M4.density
  DENSITY M5x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M5.density
  DENSITY M6x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M6.density
  DENSITY M7x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M7.density
  DENSITY M8x < 0.2 INSIDE OF LAYER CHIP PRINT UTM.DN.3.M8.density
}
#ENDIF

// UTM.DN.4 is checked by Mn.DN.5:L and Mn.DN.5:H
// UTM.DN.4a is checked by Mn.DN.5:L and Mn.DN.5:H
// UTM.DN.4b is checked by Mn.DN.5:L and Mn.DN.5:H

#ENDIF



#IFDEF UTM
VARIABLE  DUTM_W_1   3.0 
VARIABLE  DUTM_S_1   3.0 
VARIABLE  DUTM_S_2   3.0 
VARIABLE  DUTM_A_1   9.0 
VARIABLE  DUTM_A_2   600.0 
VARIABLE  DUTM_W_2   DM9_W_2
VARIABLE  DUTM_S_3   DM9_S_3
VARIABLE  DUTM_S_3_L DM9_S_3_L
VARIABLE  DUTM_S_4   DM9_S_4
VARIABLE  DUTM_S_5   DM9_S_5
VARIABLE  DUTM_S_5_1 DM9_S_5_1
VARIABLE  DUTM_S_8   DM9_S_8
VARIABLE  DUTM_EN_1  DM9_EN_1
UTMi  = COPY M9i
DUUTM = COPY DUM9
DUUTM_O = COPY DUM9_O
UTM_real = COPY M9_real
UTMWide_4.5 = COPY M9Wide_4.5


//DUMMY UTM CHECKS
//==================
DUTM.W.1 { @ Width >= ^DUTM_W_1 um
  INT DUUTM < DUTM_W_1 ABUT < 90 SINGULAR REGION
}
DUTM.W.2 { @ Width (maximum) (checked by sizing down 1.5 um) <= ^DUTM_W_2 um
  SIZE DUUTM BY DUTM_W_2 /2 UNDEROVER
}
DUTM.S.1 { @ Space >= ^DUTM_S_1 um
  EXT DUUTM < DUTM_S_1 ABUT < 90 SINGULAR REGION
}
DUTM.S.2 { @ Space to Mx >= ^DUTM_S_2 um
  EXT UTMi DUUTM < DUTM_S_2 ABUT < 90 SINGULAR REGION
  UTMi AND DUUTM
}
DUTM.S.3 { @ Space to Mx (Overlap is not allowed) [Mx width > 4.5 um and the parallel metal run length > 4.5 um] >= ^DUTM_S_3 um.
  X = EXT UTMWide_4.5 DUUTM < DUTM_S_3 OPPOSITE REGION MEASURE ALL
  ENCLOSE RECTANGLE X DUTM_S_2 DUTM_S_3_L+0.005
}
DUTM.S.4 { @ Space to FW (Overlap is not allowed) >= ^DUTM_S_4 um
  EXT FWi DUUTM < DUTM_S_4 ABUT < 90 SINGULAR REGION 
  FWi AND DUUTM
}
// for sloid L-mark (old)
DUTM.S.5 { @ Space to LMARK (Overlap is not allowed) >= 5 um
  EXT LMARK_SOLID DUUTM < DUTM_S_5 ABUT < 90 SINGULAR REGION 
  DUUTM AND LMARK_SOLID  
}
// for hollow L-mark (new)
DUTM.S.5.1 { @ Space to L-slot (Overlap is not allowed) >= 5 um
  EXT LSLOT DUUTM < DUTM_S_5_1 ABUT < 90 SINGULAR REGION 
  DUUTM AND LSLOT  
}
DUTM.S.7 { @ Space to LOGO (Overlap is not allowed) >= 0 um
  LOGO AND DUUTM
}
DUTM.S.8 { @ Space to INDDMY (Overlap is not allowed) >= ^DUTM_S_8 um
  EXT INDDMY DUUTM < DUTM_S_8 ABUT < 90 SINGULAR REGION 
  INDDMY AND DUUTM
}
#IFDEF FULL_CHIP
DUTM.EN.1 { @ Enclosure by chip edge >= ^DUTM_EN_1 um
  DUUTM NOT (SIZE CHIP_CHAMFERED BY -DUTM_EN_1)
}
#ENDIF
DUTM.A.1 { @ Min. area >= ^DUTM_A_1 um2
  AREA DUUTM < DUTM_A_1 
}
DUTM.A.2 { @ Max. area <= ^DUTM_A_2 um2
  AREA DUUTM > DUTM_A_2 
}
#IFDEF FULL_CHIP
DUTM.R.1 { @ DUTM is must. The DUTM CAD layer must be different from the UTM CAD layer.
  CHIP_CHAMFERED NOT INTERACT DUUTM
}
#ENDIF
DUTM.R.3 { @ Only square (or rectangular) and solid shapes are allowed.
  NOT RECTANGLE DUUTM
  HOLES DUUTM
}
// DMx_O.R.1 is checked by DUTM_O.R.1
DUTM_O.R.1 { @ DUTM_O interact M11 is not allowed.
  DUUTM_O INTERACT UTM_real
}

#ENDIF


//SBD checks
//================
#IFDEF LP
SBDOD       = ( OD AND SBDDMY ) AND NWEL
NW_SBD      = NWEL INTERACT SBDOD
DNW_SBD     = DNW INTERACT SBDOD
PP_SBD      = PP INTERACT SBDOD 
PP_SBD_HOLE = HOLES PP_SBD INNER
PP_SBD_ALL  = PP_SBD OR PP_SBD_HOLE
PP_NSBD     = PP NOT PP_SBD
PPOD_SBD    = SBDOD INTERACT PP
NPOD_SBD    = SBDOD AND NP

PPOD_SBD_GAP = EXPAND EDGE PPOD_SBD OUTSIDE BY SBD_S_1
PPOD_SBD_G   = PPOD_SBD_GAP TOUCH NPOD_SBD
NPOD_SBD_GAP = EXPAND EDGE NPOD_SBD OUTSIDE BY SBD_S_1
NPOD_SBD_G   = NPOD_SBD_GAP TOUCH PPOD_SBD

SBDOD_ALL = ( PPOD_SBD OR NPOD_SBD ) OR PPOD_SBD_G 

PPOD_SBD_W = PPOD_SBD TOUCH OUTSIDE EDGE NPOD_SBD_G
PPOD_SBD_L = PPOD_SBD NOT TOUCH OUTSIDE EDGE NPOD_SBD_G
NPOD_SBD_W = NPOD_SBD TOUCH OUTSIDE EDGE PPOD_SBD_G

PPOD_SBD_H = (HOLES (((PPOD AND PWEL) AND RFDMY) NOT DNW) INNER) ENCLOSE SBDOD

SBD.W.1__SBD.W.1.1 { @ Minimum width of an OD region to define the width of the
                     @ P+ACTIVE OD region of the SBD >= ^SBD_W_1 um <= ^SBD_W_1_1 um
  LENGTH PPOD_SBD_W > 0 < SBD_W_1
  PATH LENGTH PPOD_SBD_W > SBD_W_1_1 < 999
}
SBD.W.2__SBD.W.2.1 { @ Minimum length of an OD region to define the length of the
                     @ P+ACTIVE OD region of the SBD >= ^SBD_W_2 um <= ^SBD_W_2_1 um
  LENGTH PPOD_SBD_L > 0 < SBD_W_2
  PATH LENGTH PPOD_SBD_L > SBD_W_2_1 < 999 
}
SBD.W.3 { @ Minimum and Maximum length of an OD region to define
          @ the length of the NP OD region of the SBD == ^SBD_W_3 um
  NOT RECTANGLE NPOD_SBD	      
  INT NPOD_SBD < SBD_W_3 ABUT < 90 SINGULAR REGION
  SIZE NPOD_SBD BY SBD_W_3 / 2 UNDEROVER
}
SBD.W.4 { @ The width of NP OD region of the SBD must be equal to
          @ P+ACTIVE OD region of the SBD
  NPOD_SBD_W NOT COIN OUTSIDE EDGE PPOD_SBD_G	      
  PPOD_SBD_W NOT COIN OUTSIDE EDGE NPOD_SBD_G        
}
SBD.S.1 { @ Space between P+ACTIVE OD region and NP OD region of the SBD == ^SBD_S_1 um
  EXT PPOD_SBD NPOD_SBD < SBD_S_1 ABUT < 90 SINGULAR REGION
  PPOD_SBD INTERACT NPOD
  PPOD_SBD NOT TOUCH PPOD_SBD_G == 2
  A = PPOD_SBD TOUCH PPOD_SBD_G == 2
  B = A TOUCH OUTSIDE EDGE PPOD_SBD_G 
  C = INT B < SBD_S_1 ABUT == 90 INTERSECTING ONLY REGION 
  PPOD_SBD INTERACT C 
}
SBD.E.1 { @ Minimum and maximum extension from NW edge to an OD
          @ region used for the SBD == ^SBD_E_1 um
  X = PPOD_SBD OR NPOD_SBD
  Y = SIZE X BY SBD_E_1
  Y XOR NW_SBD
}
SBD.E.1.1 { @ Minimum extension of DNW beyond NW for a better noise isolation >= ^SBD_E_1_1 um
  ENC NW_SBD DNW_SBD < SBD_E_1_1 ABUT < 90 SINGULAR REGION
  NW_SBD CUT DNW_SBD
}
SBD.E.2 { @ Minimum and maximum extension of a PP region beyond
          @ an enclosed P+ACTIVE OD region of the SBD == ^SBD_E_2 um
  X = SIZE PPOD_SBD BY SBD_E_2
  X XOR PP_SBD_ALL
}
SBD.E.3 { @ Maximum and Minimum extension of SBDDMY beyond NW == ^SBD_E_3 um
  SBDDMY XOR NW_SBD
}
SBD.O.1 { @ Minimum and maximum overlap from a PP edge to a P+ACTIVE OD
          @ region of the SBD == ^SBD_O_1 um
  X = SIZE PPOD_SBD BY -SBD_O_1
  X XOR PP_SBD_HOLE
}
//SBD.R.1 is checked by SBD.S.1
SBD.R.2 { @ Maximum Finger Number of the P+ active OD region of the SBD should be <= ^SBD_R_2 um
  X = SBDDMY INTERACT PPOD_SBD < SBD_R_2 + 1
  Y = SBDDMY NOT X 
  PPOD_SBD INTERACT Y
}
SBD.R.3 { @ Each NW of SBD should be surrounded by the P+ Guard Ring (P+ pickup ring)
  NW_SBD NOT PPOD_SBD_H 
  PPOD_SBD_H INTERACT SBDOD_ALL > 1
  PPOD_SBD_H INTERACT NW_SBD > 1
}
SBD.R.4 { @ Use RFDMY to fully cover SBD and P+ Guard Ring for LVS to recognize RF Device
  SBDDMY NOT RFDMY
  NW_SBD NOT RFDMY
}
SBD.R.5 { @ PP for SBD must be a rectangle ring
          @ PP rectangle ring must surround OD, other shape is not allowed
  NOT RECTANGLE PP_SBD_HOLE	
  NOT RECTANGLE PP_SBD_ALL
}
//SBD.R.7RU can not be check by DRC.
#ENDIF






// RV/AP Rules
//==============================================

VARIABLE RV_W_1     3
VARIABLE RV_S_1     3
VARIABLE RV_EN_1    1.5
VARIABLE AP_W_1     3
VARIABLE AP_W_2     35.0
VARIABLE AP_W_3     3

VARIABLE AP_S_1     2
VARIABLE AP_S_1_FC     2
VARIABLE AP_S_1_1   2.5

VARIABLE AP_EN_1    1.5
VARIABLE AP_DN_1_L  0.1
VARIABLE AP_DN_1_H  0.7

RV_CHECK = RV NOT INSIDE SRCSR

RV.W.1 { @ Width (maximum = minimum) (Not inside seal ring) == ^RV_W_1 um
  NOT RECTANGLE RV_CHECK == RV_W_1 BY == RV_W_1 ORTHOGONAL ONLY
}

RV.S.1 { @ Space >= ^RV_S_1 um
  EXT RV < RV_S_1 ABUT < 90 SINGULAR REGION
}

RV.EN.1 { @ Enclosure by Mtop (Not inside seal ring) >= ^RV_EN_1 um
  ENC RV_CHECK M9 < RV_EN_1 ABUT < 90 SINGULAR REGION
  RV_CHECK NOT M9
}

RV.R.1 { @ A 45-degree rotated RV is not allowed (Not inside seal ring)
  ANGLE RV_CHECK >0 <90
}

AP_CHECK = AP NOT INSIDE SRCSR

AP.W.1 { @ Width [interconnect only] [ not inside FW_AP or sealring] >= ^AP_W_1 um
  A = AP_CHECK NOT FW_AP
  INT A < AP_W_1 ABUT < 90 SINGULAR REGION
}

AP.W.2 { @ Maximum width [interconnect only] [ not inside UBM, CB or CB2] <= ^AP_W_2 um
  A = ((AP NOT UBM) NOT CB) NOT CB2
  WITH WIDTH A > AP_W_2
}

#IFDEF 28K_AP
AP_HOLE = HOLES AP INNER
AP_HOLE_SHOURT_EDGE = LENGTH AP_HOLE < 3
GRID_VERTEX = INT AP_HOLE <= 0.01 ABUT == 90 REGION
AP_HOLE_SHOURT_EDGE_region = EXPAND EDGE AP_HOLE_SHOURT_EDGE INSIDE BY 0.005
GRID_VERTEX_check = GRID_VERTEX INTERACT AP_HOLE_SHOURT_EDGE_region
GRID_EXTENT = EXTENTS GRID_VERTEX_check CENTERS 0.01

AP.W.3 { @ AP hole width for 28KA AP should >= 3, except < 100 inner 90-degrees vertex of AP holes [width < 3 um] within window 100 um x 100 um, stepping 50 um
  DENSITY GRID_EXTENT >= 100 WINDOW 100 STEP 50 INSIDE OF LAYER CHIP_EDGE BACKUP PRINT AP.W.3.density RDB AP.W.3.rdb
          [ 1E4 * AREA(GRID_EXTENT) ]
}
#ENDIF // AP_28K_THICKNESS

AP.S.1 { @ Space (Except space in the same polygon and in {CB2 SIZING 5um} region) >= ^AP_S_1 um
  A = SIZE CB2 BY 5
  (EXT AP < AP_S_1 SPACE SINGULAR REGION) NOT A
}

AP.S.1.FC { @ Space (Except space in the same polygon and in {UBM SIZING 5um} region) >= ^AP_S_1_FC um
  A = SIZE UBM BY 5
  (EXT AP < AP_S_1 SPACE SINGULAR REGION) NOT A
}

AP.EN.1 { @ Enclosured of RV (Not inside seal ring) >= ^AP_EN_1 um
  ENC RV_CHECK AP_CHECK < AP_EN_1 ABUT < 90 SINGULAR REGION
  RV_CHECK NOT AP_CHECK
}

#IFDEF FULL_CHIP
// AP.DN.1a is checked by AP.DN.1:L
AP.DN.1:L { @ AP density across full chip >= ^AP_DN_1_L
  DENSITY AP < AP_DN_1_L INSIDE OF LAYER CHIP_EDGE PRINT AP.DN.1L.density
}

// AP.DN.1b is checked by AP.DN.1:H
AP.DN.1:H { @ AP density across full chip <= ^AP_DN_1_H
  DENSITY AP > AP_DN_1_H INSIDE OF LAYER CHIP_EDGE PRINT AP.DN.1H.density
}
#ENDIF

#ELSE // DFM_ONLY
#IFNDEF DFM
DFM_OPTION:WARNING1 { @ If DFM_ONLY option is enabled, DFM option should be enabled, too.
  COPY CHIP
}
#ENDIF
#ENDIF
#IFDEF DFM

#IFDEF Systematic
  #DEFINE SP   
  #DEFINE FSP
  #DEFINE SD
#ELSE
  #IFDEF Defect
     #DEFINE SD
  #ELSE
     #IFDEF SPICE
       #DEFINE SP
       #DEFINE FSP
    #ELSE
       #IFDEF First_priority
         #DEFINE FSP
       #ENDIF
    #ENDIF
  #ENDIF
#ENDIF


#IFDEF SD
#IFDEF _COS3_
#IFDEF N80
RR:NS:SD:CO.S.3 { @ {CO inside OD} space to GATE (Overlap of GATE is not allowed) [space can be >= 0.058 um inside SRAM word line decoder covered by layer 186;4] >= ^CO_S_3R um
    A = EXT COOD GATE < CO_S_3R ABUT < 90 SINGULAR REGION
    A NOT INSIDE SRAMDMY_PERI
    B = COOD INTERACT SRAMDMY_PERI
    EXT B GATE < CO_S_3_S ABUT < 90 SINGULAR REGION
    CO AND GATE
}
#ENDIF
#ENDIF
#ENDIF


#IFDEF Required
#IFDEF SP
#IFDEF _POS2_
POS2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS2_ODCell =  POS2_ODCellIn AND POS2_ODCellOut
POS2_ODMarker = ODi AND RRuleRequired
POS2_OD = ((( POS2_ODCell OR POS2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

POS2_GATE_W = POLY INSIDE EDGE POS2_OD
POS2_GATE  = POLY AND POS2_OD
RR:AR:SP:PO.S.2 { @ Recommended gate space in the same OD >= 0.2
    EXT POS2_GATE_W < 0.2 ABUT < 90 REGION 
    (EXT POS2_GATE < 0.2 ABUT < 90 REGION CORNER TO CORNER) INTERACT ODi == 1
}
#ENDIF // _POS2_

#IFDEF _POEX2_
POEX2_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POEX2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POEX2_ODCell =  POEX2_ODCellIn AND POEX2_ODCellOut
POEX2_ODMarker = ODi AND RRuleRequired
POEX2_OD = ((( POEX2_ODCell OR POEX2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

RR:AR:SP:PO.EX.2 { @ Recommended OD extension on PO >= 0.23 um
    (ENC POLY POEX2_OD < 0.23 ABUT < 89.5 SINGULAR OPPOSITE REGION) NOT INSIDE LOGO
}
#ENDIF // _POEX2_

POMergeOD = POLY OR OD
UShape = CONVEX EDGE POMergeOD ANGLE1==270 ANGLE2==270
ODCorner = EXT OD < 0.01 ABUT == 90 INTERSECTING ONLY REGION
POCorner = EXT POLY < 0.01 ABUT == 90 INTERSECTING ONLY REGION
GateW2Check = LENGTH GATE_W >= 0.20 < 0.5 
GATE2Check = GATE WITH EDGE GateW2Check
POS5_GATE_W = GATE_W COIN INSIDE EDGE GATE2Check    
POS6_GATE_L = GATE_L COIN INSIDE EDGE GATE2Check    

#IFDEF _POS5_
POS5_ODCellIn = INSIDE CELL ODi CellsForRRuleRequired  
POS5_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRequired 
POS5_ODCell =  POS5_ODCellIn AND POS5_ODCellOut
POS5_ODMarker = ODi AND RRuleRequired
POS5_OD = ((( POS5_ODCell OR POS5_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

LOD = ( UShape COIN INSIDE EDGE POS5_OD ) TOUCH EDGE ODCorner
ValidLODExp = ( EXPAND EDGE LOD INSIDE BY 0.01 ) WITH EDGE POS5_GATE_W
RR:AR:POS5 = LOD COIN EDGE ValidLODExp
RR:AR:SP:PO.S.5 { @ Space to L-shape OD when PO and OD are in the same MOS [channel width (W) >= 0.20 um and < 0.5um ] >= 0.10 
    LENGTH RR:AR:POS5 < 0.1
}
#ENDIF // _POS5_

#IFDEF _POS6_
POS6_POCellIn = INSIDE CELL POi CellsForRRuleRequired  
POS6_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRequired 
POS6_POCell =  POS6_POCellIn AND POS6_POCellOut
POS6_POMarker = POi AND RRuleRequired
POS6_PO = ((( POS6_POCell OR POS6_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRequired

LPO = ( UShape COIN INSIDE EDGE POS6_PO ) TOUCH EDGE POCorner
ValidLPOExp = ( EXPAND EDGE LPO INSIDE BY 0.01 ) WITH EDGE POS6_GATE_L
RR:AR:POS6 = LPO COIN EDGE ValidLPOExp
RR:AR:SP:PO.S.6 { @ L-shape PO space to OD when PO and OD are in the same MOS [channel width (W) >= 0.20 um and < 0.5um ]. >= 0.10 
    LENGTH RR:AR:POS6 < 0.1
}
#ENDIF // _POS6_

#ENDIF // SP 
#ENDIF // Required


#IFDEF Recommended_DFM
#IFDEF Systematic

#IFDEF _OPCR1_
OPCR1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
OPCR1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
OPCR1_ODCell =  OPCR1_ODCellIn AND OPCR1_ODCellOut
OPCR1_ODMarker = ODi AND RRuleRecommended
OPCR1_OD = ((( OPCR1_ODCell OR OPCR1_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_OD_ShortExp = EXPAND EDGE ( LENGTH OPCR1_OD < OD_W_1 ) BY 0.01
OPCR1_OD_SmallJog = (VERTEX OPCR1_OD_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:OD
RR:RE:S:OPC.R.1:OD { @ Consecutive small OD jogs are not recommended.
    ODi INSIDE EDGE OPCR1_OD_SmallJog
}
OPCR1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
OPCR1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
OPCR1_POCell =  OPCR1_POCellIn AND OPCR1_POCellOut
OPCR1_POMarker = POi AND RRuleRecommended
OPCR1_PO = ((( OPCR1_POCell OR OPCR1_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_PO_ShortExp = EXPAND EDGE ( LENGTH OPCR1_PO < PO_W_1 ) BY 0.01
OPCR1_PO_SmallJog = (VERTEX OPCR1_PO_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:PO
RR:RE:S:OPC.R.1:PO { @ Consecutive small PO jogs are not recommended.
    POi INSIDE EDGE OPCR1_PO_SmallJog
}
OPCR1_NPCellIn = INSIDE CELL NPi CellsForRRuleRecommended  
OPCR1_NPCellOut = NOT INSIDE CELL NPi ExclCellsForRRuleRecommended 
OPCR1_NPCell =  OPCR1_NPCellIn AND OPCR1_NPCellOut
OPCR1_NPMarker = NPi AND RRuleRecommended
OPCR1_NP = ((( OPCR1_NPCell OR OPCR1_NPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_NP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_NP < NP_W_1 ) BY 0.01
OPCR1_NP_SmallJog = (VERTEX OPCR1_NP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:NP
RR:RE:S:OPC.R.1:NP { @ Consecutive small NP jogs are not recommended.
    NPi INSIDE EDGE OPCR1_NP_SmallJog
}
OPCR1_PPCellIn = INSIDE CELL PPi CellsForRRuleRecommended  
OPCR1_PPCellOut = NOT INSIDE CELL PPi ExclCellsForRRuleRecommended 
OPCR1_PPCell =  OPCR1_PPCellIn AND OPCR1_PPCellOut
OPCR1_PPMarker = PPi AND RRuleRecommended
OPCR1_PP = ((( OPCR1_PPCell OR OPCR1_PPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_PP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_PP < PP_W_1 ) BY 0.01
OPCR1_PP_SmallJog = (VERTEX OPCR1_PP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:PP
RR:RE:S:OPC.R.1:PP { @ Consecutive small PP jogs are not recommended.
    PPi INSIDE EDGE OPCR1_PP_SmallJog
}
OPCR1_VTHNCellIn = INSIDE CELL VTH_Ni CellsForRRuleRecommended  
OPCR1_VTHNCellOut = NOT INSIDE CELL VTH_Ni ExclCellsForRRuleRecommended 
OPCR1_VTHNCell =  OPCR1_VTHNCellIn AND OPCR1_VTHNCellOut
OPCR1_VTHNMarker = VTH_Ni AND RRuleRecommended
OPCR1_VTHN = ((( OPCR1_VTHNCell OR OPCR1_VTHNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTHN_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTHN < VTH_N_W_1 ) BY 0.01
OPCR1_VTHN_SmallJog = (VERTEX OPCR1_VTHN_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTHN
RR:RE:S:OPC.R.1:VTHN { @ Consecutive small VTH_N jogs are not recommended.
    VTH_Ni INSIDE EDGE OPCR1_VTHN_SmallJog
}
OPCR1_VTHPCellIn = INSIDE CELL VTH_Pi CellsForRRuleRecommended  
OPCR1_VTHPCellOut = NOT INSIDE CELL VTH_Pi ExclCellsForRRuleRecommended 
OPCR1_VTHPCell =  OPCR1_VTHPCellIn AND OPCR1_VTHPCellOut
OPCR1_VTHPMarker = VTH_Pi AND RRuleRecommended
OPCR1_VTHP = ((( OPCR1_VTHPCell OR OPCR1_VTHPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTHP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTHP < VTH_P_W_1 ) BY 0.01
OPCR1_VTHP_SmallJog = (VERTEX OPCR1_VTHP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTHP
RR:RE:S:OPC.R.1:VTHP { @ Consecutive small VTH_P jogs are not recommended.
    VTH_Pi INSIDE EDGE OPCR1_VTHP_SmallJog
}
OPCR1_VTLNCellIn = INSIDE CELL VTL_Ni CellsForRRuleRecommended  
OPCR1_VTLNCellOut = NOT INSIDE CELL VTL_Ni ExclCellsForRRuleRecommended 
OPCR1_VTLNCell =  OPCR1_VTLNCellIn AND OPCR1_VTLNCellOut
OPCR1_VTLNMarker = VTL_Ni AND RRuleRecommended
OPCR1_VTLN = ((( OPCR1_VTLNCell OR OPCR1_VTLNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTLN_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTLN < VTL_N_W_1 ) BY 0.01
OPCR1_VTLN_SmallJog = (VERTEX OPCR1_VTLN_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTLN
RR:RE:S:OPC.R.1:VTLN { @ Consecutive small VTL_N jogs are not recommended.
    VTL_Ni INSIDE EDGE OPCR1_VTLN_SmallJog
}
OPCR1_VTLPCellIn = INSIDE CELL VTL_Pi CellsForRRuleRecommended  
OPCR1_VTLPCellOut = NOT INSIDE CELL VTL_Pi ExclCellsForRRuleRecommended 
OPCR1_VTLPCell =  OPCR1_VTLPCellIn AND OPCR1_VTLPCellOut
OPCR1_VTLPMarker = VTL_Pi AND RRuleRecommended
OPCR1_VTLP = ((( OPCR1_VTLPCell OR OPCR1_VTLPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VTLP_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VTLP < VTL_P_W_1 ) BY 0.01
OPCR1_VTLP_SmallJog = (VERTEX OPCR1_VTLP_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VTLP
RR:RE:S:OPC.R.1:VTLP { @ Consecutive small VTL_P jogs are not recommended.
    VTL_Pi INSIDE EDGE OPCR1_VTLP_SmallJog
}
OPCR1_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
OPCR1_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
OPCR1_M1Cell =  OPCR1_M1CellIn AND OPCR1_M1CellOut
OPCR1_M1Marker = M1i AND RRuleRecommended
OPCR1_M1 = ((( OPCR1_M1Cell OR OPCR1_M1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_M1_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M1 < M1_W_1 ) BY 0.01
OPCR1_M1_SmallJog = (VERTEX OPCR1_M1_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M1
RR:RE:S:OPC.R.1:M1 { @ Consecutive small M1 jogs are not recommended.
    M1i INSIDE EDGE OPCR1_M1_SmallJog
}
OPCR1_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
OPCR1_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
OPCR1_M2Cell =  OPCR1_M2CellIn AND OPCR1_M2CellOut
OPCR1_M2Marker = M2i AND RRuleRecommended
OPCR1_M2 = ((OPCR1_M2Cell OR OPCR1_M2Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M2_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M2 < M2_W_1 ) BY 0.01
OPCR1_M2_SmallJog = VERTEX OPCR1_M2_ShortExp > 4
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M2
RR:RE:S:OPC.R.1:M2 { @ Consecutive small M2 jogs are not recommended.
    M2i INSIDE EDGE OPCR1_M2_SmallJog
}
OPCR1_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
OPCR1_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
OPCR1_M3Cell =  OPCR1_M3CellIn AND OPCR1_M3CellOut
OPCR1_M3Marker = M3i AND RRuleRecommended
OPCR1_M3 = ((OPCR1_M3Cell OR OPCR1_M3Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M3_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M3 < M3_W_1 ) BY 0.01
OPCR1_M3_SmallJog = VERTEX OPCR1_M3_ShortExp > 4
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M3
RR:RE:S:OPC.R.1:M3 { @ Consecutive small M3 jogs are not recommended.
    M3i INSIDE EDGE OPCR1_M3_SmallJog
}
OPCR1_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
OPCR1_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
OPCR1_M4Cell =  OPCR1_M4CellIn AND OPCR1_M4CellOut
OPCR1_M4Marker = M4i AND RRuleRecommended
OPCR1_M4 = ((OPCR1_M4Cell OR OPCR1_M4Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M4_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M4 < M4_W_1 ) BY 0.01
OPCR1_M4_SmallJog = VERTEX OPCR1_M4_ShortExp > 4
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M4
RR:RE:S:OPC.R.1:M4 { @ Consecutive small M4 jogs are not recommended.
    M4i INSIDE EDGE OPCR1_M4_SmallJog
}
OPCR1_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
OPCR1_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
OPCR1_M5Cell =  OPCR1_M5CellIn AND OPCR1_M5CellOut
OPCR1_M5Marker = M5i AND RRuleRecommended
OPCR1_M5 = ((OPCR1_M5Cell OR OPCR1_M5Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M5_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M5 < M5_W_1 ) BY 0.01
OPCR1_M5_SmallJog = VERTEX OPCR1_M5_ShortExp > 4
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M5
RR:RE:S:OPC.R.1:M5 { @ Consecutive small M5 jogs are not recommended.
    M5i INSIDE EDGE OPCR1_M5_SmallJog
}
OPCR1_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
OPCR1_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
OPCR1_M6Cell =  OPCR1_M6CellIn AND OPCR1_M6CellOut
OPCR1_M6Marker = M6i AND RRuleRecommended
OPCR1_M6 = ((OPCR1_M6Cell OR OPCR1_M6Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M6_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M6 < M6_W_1 ) BY 0.01
OPCR1_M6_SmallJog = VERTEX OPCR1_M6_ShortExp > 4
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M6
RR:RE:S:OPC.R.1:M6 { @ Consecutive small M6 jogs are not recommended.
    M6i INSIDE EDGE OPCR1_M6_SmallJog
}
OPCR1_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
OPCR1_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
OPCR1_M7Cell =  OPCR1_M7CellIn AND OPCR1_M7CellOut
OPCR1_M7Marker = M7i AND RRuleRecommended
OPCR1_M7 = ((OPCR1_M7Cell OR OPCR1_M7Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_M7_ShortExp = EXPAND EDGE ( LENGTH OPCR1_M7 < M7_W_1 ) BY 0.01
OPCR1_M7_SmallJog = VERTEX OPCR1_M7_ShortExp > 4
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:M7
RR:RE:S:OPC.R.1:M7 { @ Consecutive small M7 jogs are not recommended.
    M7i INSIDE EDGE OPCR1_M7_SmallJog
}

OPCR1_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
OPCR1_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
OPCR1_COCell =  OPCR1_COCellIn AND OPCR1_COCellOut
OPCR1_COMarker = COi AND RRuleRecommended
OPCR1_CO = ((( OPCR1_COCell OR OPCR1_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_CO_ShortExp = EXPAND EDGE ( LENGTH OPCR1_CO < CO_W_1 ) BY 0.01
OPCR1_CO_SmallJog = (VERTEX OPCR1_CO_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:CO
RR:RE:S:OPC.R.1:CO { @ Consecutive small CO jogs are not recommended.
    COi INSIDE EDGE OPCR1_CO_SmallJog
}
OPCR1_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
OPCR1_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
OPCR1_VIA1Cell =  OPCR1_VIA1CellIn AND OPCR1_VIA1CellOut
OPCR1_VIA1Marker = VIA1i AND RRuleRecommended
OPCR1_VIA1 = ((( OPCR1_VIA1Cell OR OPCR1_VIA1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR1_VIA1_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VIA1 < VIA1_W_1 ) BY 0.01
OPCR1_VIA1_SmallJog = (VERTEX OPCR1_VIA1_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VIA1
RR:RE:S:OPC.R.1:VIA1 { @ Consecutive small VIA1 jogs are not recommended.
    VIA1i INSIDE EDGE OPCR1_VIA1_SmallJog
}
OPCR1_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
OPCR1_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
OPCR1_VIA2Cell =  OPCR1_VIA2CellIn AND OPCR1_VIA2CellOut
OPCR1_VIA2Marker = VIA2i AND RRuleRecommended
OPCR1_VIA2 = ((OPCR1_VIA2Cell OR OPCR1_VIA2Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_VIA2_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VIA2 < VIA2_W_1 ) BY 0.01
OPCR1_VIA2_SmallJog = (VERTEX OPCR1_VIA2_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VIA2
RR:RE:S:OPC.R.1:VIA2 { @ Consecutive small VIA2 jogs are not recommended.
    VIA2i INSIDE EDGE OPCR1_VIA2_SmallJog
}
OPCR1_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
OPCR1_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
OPCR1_VIA3Cell =  OPCR1_VIA3CellIn AND OPCR1_VIA3CellOut
OPCR1_VIA3Marker = VIA3i AND RRuleRecommended
OPCR1_VIA3 = ((OPCR1_VIA3Cell OR OPCR1_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_VIA3_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VIA3 < VIA3_W_1 ) BY 0.01
OPCR1_VIA3_SmallJog = (VERTEX OPCR1_VIA3_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VIA3
RR:RE:S:OPC.R.1:VIA3 { @ Consecutive small VIA3 jogs are not recommended.
    VIA3i INSIDE EDGE OPCR1_VIA3_SmallJog
}
OPCR1_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
OPCR1_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
OPCR1_VIA4Cell =  OPCR1_VIA4CellIn AND OPCR1_VIA4CellOut
OPCR1_VIA4Marker = VIA4i AND RRuleRecommended
OPCR1_VIA4 = ((OPCR1_VIA4Cell OR OPCR1_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_VIA4_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VIA4 < VIA4_W_1 ) BY 0.01
OPCR1_VIA4_SmallJog = (VERTEX OPCR1_VIA4_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VIA4
RR:RE:S:OPC.R.1:VIA4 { @ Consecutive small VIA4 jogs are not recommended.
    VIA4i INSIDE EDGE OPCR1_VIA4_SmallJog
}
OPCR1_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleRecommended  
OPCR1_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleRecommended 
OPCR1_VIA5Cell =  OPCR1_VIA5CellIn AND OPCR1_VIA5CellOut
OPCR1_VIA5Marker = VIA5i AND RRuleRecommended
OPCR1_VIA5 = ((OPCR1_VIA5Cell OR OPCR1_VIA5Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_VIA5_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VIA5 < VIA5_W_1 ) BY 0.01
OPCR1_VIA5_SmallJog = (VERTEX OPCR1_VIA5_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VIA5
RR:RE:S:OPC.R.1:VIA5 { @ Consecutive small VIA5 jogs are not recommended.
    VIA5i INSIDE EDGE OPCR1_VIA5_SmallJog
}
OPCR1_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleRecommended  
OPCR1_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleRecommended 
OPCR1_VIA6Cell =  OPCR1_VIA6CellIn AND OPCR1_VIA6CellOut
OPCR1_VIA6Marker = VIA6i AND RRuleRecommended
OPCR1_VIA6 = ((OPCR1_VIA6Cell OR OPCR1_VIA6Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR1_VIA6_ShortExp = EXPAND EDGE ( LENGTH OPCR1_VIA6 < VIA6_W_1 ) BY 0.01
OPCR1_VIA6_SmallJog = (VERTEX OPCR1_VIA6_ShortExp > 4) NOT INSIDE SRAM_EXCLUDE
// OPC.R.1.R is checked by RR:RE:S:OPC.R.1:VIA6
RR:RE:S:OPC.R.1:VIA6 { @ Consecutive small VIA6 jogs are not recommended.
    VIA6i INSIDE EDGE OPCR1_VIA6_SmallJog
}


#ENDIF // _OPCR1_

#IFDEF _OPCR3_
OPCR3_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
OPCR3_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
OPCR3_ODCell =  OPCR3_ODCellIn AND OPCR3_ODCellOut
OPCR3_ODMarker = ODi AND RRuleRecommended
OPCR3_OD = ((( OPCR3_ODCell OR OPCR3_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_OD_45ANGLE = OPCR3_OD ANGLE == 45 
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:OD
RR:RE:S:OPC.R.3:OD { @ Recommended 45-degree edge length >= 0.5um 
    (LENGTH OPCR3_OD_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
OPCR3_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
OPCR3_POCell =  OPCR3_POCellIn AND OPCR3_POCellOut
OPCR3_POMarker = POi AND RRuleRecommended
OPCR3_PO = ((( OPCR3_POCell OR OPCR3_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_PO_45ANGLE = OPCR3_PO ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:PO
RR:RE:S:OPC.R.3:PO { @ Recommended 45-degree edge length >= 0.5um
    (LENGTH OPCR3_PO_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_NPCellIn = INSIDE CELL NPi CellsForRRuleRecommended  
OPCR3_NPCellOut = NOT INSIDE CELL NPi ExclCellsForRRuleRecommended 
OPCR3_NPCell =  OPCR3_NPCellIn AND OPCR3_NPCellOut
OPCR3_NPMarker = NPi AND RRuleRecommended
OPCR3_NP = ((( OPCR3_NPCell OR OPCR3_NPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_NP_45ANGLE = OPCR3_NP ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:NP
RR:RE:S:OPC.R.3:NP { @ Recommended 45-degree edge length >= 0.5um
    (LENGTH OPCR3_NP_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_PPCellIn = INSIDE CELL PPi CellsForRRuleRecommended  
OPCR3_PPCellOut = NOT INSIDE CELL PPi ExclCellsForRRuleRecommended 
OPCR3_PPCell =  OPCR3_PPCellIn AND OPCR3_PPCellOut
OPCR3_PPMarker = PPi AND RRuleRecommended
OPCR3_PP = ((( OPCR3_PPCell OR OPCR3_PPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_PP_45ANGLE = OPCR3_PP ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:PP
RR:RE:S:OPC.R.3:PP { @ Recommended 45-deg3ee edge length >= 0.5um
    (LENGTH OPCR3_PP_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_VTHNCellIn = INSIDE CELL VTH_Ni CellsForRRuleRecommended  
OPCR3_VTHNCellOut = NOT INSIDE CELL VTH_Ni ExclCellsForRRuleRecommended 
OPCR3_VTHNCell =  OPCR3_VTHNCellIn AND OPCR3_VTHNCellOut
OPCR3_VTHNMarker = VTH_Ni AND RRuleRecommended
OPCR3_VTHN = ((( OPCR3_VTHNCell OR OPCR3_VTHNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_VTHN_45ANGLE = OPCR3_VTHN ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:VTHN
RR:RE:S:OPC.R.3:VTHN { @ Recommended 45-degree edge length >= 0.5um
    (LENGTH OPCR3_VTHN_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_VTHPCellIn = INSIDE CELL VTH_Pi CellsForRRuleRecommended  
OPCR3_VTHPCellOut = NOT INSIDE CELL VTH_Pi ExclCellsForRRuleRecommended 
OPCR3_VTHPCell =  OPCR3_VTHPCellIn AND OPCR3_VTHPCellOut
OPCR3_VTHPMarker = VTH_Pi AND RRuleRecommended
OPCR3_VTHP = ((( OPCR3_VTHPCell OR OPCR3_VTHPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_VTHP_45ANGLE = OPCR3_VTHP ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:VTHP
RR:RE:S:OPC.R.3:VTHP { @ Recommended 45-degree edge length >= 0.5um
    (LENGTH OPCR3_VTHP_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_VTLNCellIn = INSIDE CELL VTL_Ni CellsForRRuleRecommended  
OPCR3_VTLNCellOut = NOT INSIDE CELL VTL_Ni ExclCellsForRRuleRecommended 
OPCR3_VTLNCell =  OPCR3_VTLNCellIn AND OPCR3_VTLNCellOut
OPCR3_VTLNMarker = VTL_Ni AND RRuleRecommended
OPCR3_VTLN = ((( OPCR3_VTLNCell OR OPCR3_VTLNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_VTLN_45ANGLE = OPCR3_VTLN ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:VTLN
RR:RE:S:OPC.R.3:VTLN { @ Recommended 45-degree edge length >= 0.5um
    (LENGTH OPCR3_VTLN_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_VTLPCellIn = INSIDE CELL VTL_Pi CellsForRRuleRecommended  
OPCR3_VTLPCellOut = NOT INSIDE CELL VTL_Pi ExclCellsForRRuleRecommended 
OPCR3_VTLPCell =  OPCR3_VTLPCellIn AND OPCR3_VTLPCellOut
OPCR3_VTLPMarker = VTL_Pi AND RRuleRecommended
OPCR3_VTLP = ((( OPCR3_VTLPCell OR OPCR3_VTLPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_VTLP_45ANGLE = OPCR3_VTLP ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:VTLP
RR:RE:S:OPC.R.3:VTLP { @ Recommended 45-degree edge length >= 0.5um
    (LENGTH OPCR3_VTLP_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
OPCR3_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
OPCR3_M1Cell =  OPCR3_M1CellIn AND OPCR3_M1CellOut
OPCR3_M1Marker = M1i AND RRuleRecommended
OPCR3_M1 = ((( OPCR3_M1Cell OR OPCR3_M1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OPCR3_M1_45ANGLE = OPCR3_M1 ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:M1
RR:RE:S:OPC.R.3:M1 { @ Recommended 45-degree edge length >= 0.5um
    (LENGTH OPCR3_M1_45ANGLE < 0.5) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR3_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
OPCR3_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
OPCR3_M2Cell =  OPCR3_M2CellIn AND OPCR3_M2CellOut
OPCR3_M2Marker = M2i AND RRuleRecommended
OPCR3_M2 = ((OPCR3_M2Cell OR OPCR3_M2Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR3_M2_45ANGLE = OPCR3_M2 ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:M2
RR:RE:S:OPC.R.3:M2 { @ Recommended 45-degree edge length >= 0.5um
    LENGTH OPCR3_M2_45ANGLE < 0.5
}
OPCR3_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
OPCR3_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
OPCR3_M3Cell =  OPCR3_M3CellIn AND OPCR3_M3CellOut
OPCR3_M3Marker = M3i AND RRuleRecommended
OPCR3_M3 = ((OPCR3_M3Cell OR OPCR3_M3Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR3_M3_45ANGLE = OPCR3_M3 ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:M3
RR:RE:S:OPC.R.3:M3 { @ Recommended 45-degree edge length >= 0.5um
    LENGTH OPCR3_M3_45ANGLE < 0.5
}
OPCR3_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
OPCR3_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
OPCR3_M4Cell =  OPCR3_M4CellIn AND OPCR3_M4CellOut
OPCR3_M4Marker = M4i AND RRuleRecommended
OPCR3_M4 = ((OPCR3_M4Cell OR OPCR3_M4Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR3_M4_45ANGLE = OPCR3_M4 ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:M4
RR:RE:S:OPC.R.3:M4 { @ Recommended 45-degree edge length >= 0.5um
    LENGTH OPCR3_M4_45ANGLE < 0.5
}
OPCR3_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
OPCR3_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
OPCR3_M5Cell =  OPCR3_M5CellIn AND OPCR3_M5CellOut
OPCR3_M5Marker = M5i AND RRuleRecommended
OPCR3_M5 = ((OPCR3_M5Cell OR OPCR3_M5Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR3_M5_45ANGLE = OPCR3_M5 ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:M5
RR:RE:S:OPC.R.3:M5 { @ Recommended 45-degree edge length >= 0.5um
    LENGTH OPCR3_M5_45ANGLE < 0.5
}
OPCR3_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
OPCR3_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
OPCR3_M6Cell =  OPCR3_M6CellIn AND OPCR3_M6CellOut
OPCR3_M6Marker = M6i AND RRuleRecommended
OPCR3_M6 = ((OPCR3_M6Cell OR OPCR3_M6Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR3_M6_45ANGLE = OPCR3_M6 ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:M6
RR:RE:S:OPC.R.3:M6 { @ Recommended 45-degree edge length >= 0.5um
    LENGTH OPCR3_M6_45ANGLE < 0.5
}
OPCR3_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
OPCR3_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
OPCR3_M7Cell =  OPCR3_M7CellIn AND OPCR3_M7CellOut
OPCR3_M7Marker = M7i AND RRuleRecommended
OPCR3_M7 = ((OPCR3_M7Cell OR OPCR3_M7Marker) NOT Block ) NOT excludeRRuleRecommended

OPCR3_M7_45ANGLE = OPCR3_M7 ANGLE == 45
// OPC.R.3.R is checked by RR:RE:S:OPC.R.3:M7
RR:RE:S:OPC.R.3:M7 { @ Recommended 45-degree edge length >= 0.5um
    LENGTH OPCR3_M7_45ANGLE < 0.5
}


#ENDIF // _OPCR3_


#IFDEF _DNWEN1_
DNWEN1_DNWCellIn = INSIDE CELL DNWi CellsForRRuleRecommended  
DNWEN1_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleRecommended 
DNWEN1_DNWCell =  DNWEN1_DNWCellIn AND DNWEN1_DNWCellOut
DNWEN1_DNWMarker = DNWi AND RRuleRecommended
DNWEN1_DNW = ((( DNWEN1_DNWCell OR DNWEN1_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

DNWEN1_SBDDMYCellIn = INSIDE CELL SBDDMY CellsForRRuleRecommended  
DNWEN1_SBDDMYCellOut = NOT INSIDE CELL SBDDMY ExclCellsForRRuleRecommended 
DNWEN1_SBDDMYCell =  DNWEN1_SBDDMYCellIn AND DNWEN1_SBDDMYCellOut
DNWEN1_SBDDMYMarker = SBDDMY AND RRuleRecommended
DNWEN1_SBDDMY = ((DNWEN1_SBDDMYCell OR DNWEN1_SBDDMYMarker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:S:DNW.EN.1 { @ Enclosure by NW ( Except SBDDMY region )>= 1.5um 
    (ENC DNWEN1_DNW NWEL < 1.5 ABUT < 90 SINGULAR REGION) NOT INSIDE DNWEN1_SBDDMY
    (DNWEN1_DNW NOT INSIDE DNWEN1_SBDDMY) OUTSIDE EDGE NWEL
}
#ENDIF // _DNWEN1_

#IFDEF _ESDIMPEN1_
RR:RE:S:ESDIMP.EN.1 { @ (OD NOT PO) enclosure of ESDIMP = 0.4 
  OD_NPO = OD NOT POLY
  ENC ESDIMP OD_NPO < ESDIMP_EN_1_R OUTSIDE ALSO ABUT < 90 SINGULAR REGION
  X = (OD_NPO ENCLOSE ESDIMP) NOT ESDIMP
  ENCLOSE RECTANGLE X 0.405 0.405
}
#ENDIF // _ESDIMPEN1_

#IFDEF UTM
#IFDEF _UTMDN5_
RR:RE:S:UTM.DN.5 { @ Recommended max density of INDDMY over the whole chip 5%
   DENSITY INDDMY > 0.05 PRINT UTM.DN.5.density
}
#ENDIF // _UTMDN5_
#ENDIF // UTM


#ENDIF // Systematic 



#IFDEF SPICE
#IFDEF _ODW2_
ODW2_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODW2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODW2_ODCell =  ODW2_ODCellIn AND ODW2_ODCellOut
ODW2_ODMarker = ODi AND RRuleRecommended
ODW2_OD = ((( ODW2_ODCell OR ODW2_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

ODW2_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
ODW2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
ODW2_POCell =  ODW2_POCellIn AND ODW2_POCellOut
ODW2_POMarker = POi AND RRuleRecommended
ODW2_PO = ((( ODW2_POCell OR ODW2_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:ODW2 = ( ODW2_PO INSIDE EDGE ODW2_OD ) NOT INSIDE EDGE OD2
RR:RE:P:OD.W.2 { @ Recommended Width of MOS (<= 1.2V) [for core device] >= 0.20 um, for stable Isat(avoid corner rounding effect)
    LENGTH RR:RE:ODW2 < 0.20
}
#ENDIF // _ODW2_
#IFDEF _CTMW1_
RR:RE:P:CTM.W.1 { @ Recommended width for SPICE simulation accuracy >= 4.0 um
  INT CTM < 4 ABUT <90 SINGULAR REGION
}
#ENDIF // _CTMW1_
#IFDEF UTM
#IFDEF _UTMEN3_
#IFDEF DFM_ONLY
UTM_MAX_WIDTH = M9_MAX_WIDTH NOT (SIZE INDDMY BY 18) 
IND_UTM = M9 AND INDDMY // UTM inside INDDMY 
UTM_Wide = (SIZE IND_UTM BY 12/2 UNDEROVER TRUNCATE 12/2) AND IND_UTM
IND_UTM_A = ENC IND_UTM INDDMY < 0.01 ABUT>0<135 INTERSECTING ONLY REGION 
IND_UTM_B = M9 TOUCH OUTSIDE EDGE IND_UTM_A
IND_UTM_C = INT IND_UTM_B < 30.005 OPPOSITE REGION
IND_UTM_core = IND_UTM NOT IND_UTM_C // core inductor metal
#ENDIF // DFM_ONLY
RR:RE:P:UTM.EN.3 { @ Recommended Min. INDDMY enclosure of UTM (inductor) 50 um.
    INDDMY45 = INDDMY ANGLE == 45
    INDDMY090 = INDDMY NOT COIN EDGE INDDMY45
    IND_HOLE = HOLES (SIZE IND_UTM_core BY 3 OVERUNDER)
    INDDMY_0.5 = INDDMY OUTSIDE IND_HOLE
    IND_UTM_0.5 = INT (IND_UTM AND INDDMY_0.5) >=6 <=15 ANGLED == 0 OPPOSITE ABUT < 90 REGION
    IND_UTM_core_0.5 = IND_UTM_core ENCLOSE IND_UTM_0.5 // 0.5 turns inductor
    X = ENC IND_UTM_core_0.5 INDDMY45 < 49.995 > 47 ABUT < 90 REGION
    (ENC IND_UTM_core INDDMY45 < 49.995 ABUT < 90 REGION) NOT X
    ENC IND_UTM_core INDDMY090 < 50 ABUT < 90 REGION
}
#ENDIF // _UTMEN3_
#ENDIF // UTM

#ENDIF // SPICE 

#IFDEF Defect 
#IFDEF _ODS1_
ODS1_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS1_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS1_ODCell =  ODS1_ODCellIn AND ODS1_ODCellOut
ODS1_ODMarker = ODi AND RRuleRecommended
ODS1_OD = ((( ODS1_ODCell OR ODS1_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:D:OD.S.1 { @ Recommended OD space >= 0.18 um, to reduce short possibility
    EXT ODS1_OD < 0.18 ABUT < 90 REGION SINGULAR 
}
#ENDIF // _ODS1_
#ENDIF // Defect 


#IFDEF Systematic 
#IFDEF _ODS6_
ODS6_ODCellIn = INSIDE CELL ODi CellsForRRuleRecommended  
ODS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleRecommended 
ODS6_ODCell =  ODS6_ODCellIn AND ODS6_ODCellOut
ODS6_ODMarker = ODi AND RRuleRecommended
ODS6_OD = ((( ODS6_ODCell OR ODS6_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

ODS6Area = AREA ( ODi NOT INTERACT SEALRING ) > BIG_AREA
RR:RE:S:OD.S.6 { @ Recommended OD space >= 0.35um [OD area > ^BIG_AREA]
    (EXT ODS6Area ODi < 0.35 SPACE ABUT < 90 SINGULAR REGION) INTERACT ODS6_OD
}
#ENDIF // _ODS6_
#ENDIF // Systematic 


#IFDEF  SPICE
#IFDEF _NWRODR1_
NWRODR1_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRODR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRODR1_NWCell =  NWRODR1_NWCellIn AND NWRODR1_NWCellOut
NWRODR1_NWMarker = NWi AND RRuleRecommended
NWRODR1_NW = ((( NWRODR1_NWCell OR NWRODR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

NWRODR1_NWRES = ( NWRODR1_NW AND NWRES ) AND NWDMY
RR:RE:P:NWROD.R.1 { @ Recommended length >= 20um for NW resistor with OD, for SPICE model accuracy
  RES_L = NWRODR1_NWRES COIN INSIDE EDGE NWRODR1_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRODR1_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRODR1_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
#ENDIF // _NWRODR1_

#IFDEF _NWRSTIR1_
NWRSTIR1_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
NWRSTIR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
NWRSTIR1_NWCell =  NWRSTIR1_NWCellIn AND NWRSTIR1_NWCellOut
NWRSTIR1_NWMarker = NWi AND RRuleRecommended
NWRSTIR1_NW = ((( NWRSTIR1_NWCell OR NWRSTIR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

NWRSTIR1_NWRES = ( NWRSTIR1_NW AND NWRES_STI ) AND NWDMY
RR:RE:P:NWRSTI.R.1 { @ Recommended length >= 20um for NW resistor under STI, for SPICE model accuracy
  RES_L = NWRSTIR1_NWRES COIN INSIDE EDGE NWRSTIR1_NW
  X = PATH LENGTH RES_L < 20.0
  CHECK_RES = NWRSTIR1_NWRES WITH EDGE X
  RES_E = CHECK_RES COIN INSIDE EDGE NWDMY
  A = EXPAND EDGE RES_E INSIDE BY GRID
  B = SIZE A BY ( 10 - GRID*2 ) INSIDE OF NWRSTIR1_NWRES STEP NW_S_1*0.7  
  C = CHECK_RES NOT B 
  CHECK_RES NOT INTERACT C
  D = INT C < GRID*2 ABUT < 90 REGION
  CHECK_RES INTERACT D
}
#ENDIF // _NWRSTIR1_
#IFDEF _RESR17_
//RES.R.17.R is checked by RR:RE:P:RES.R.17
RESR17_RHCellIn = INSIDE CELL RH CellsForRRuleRecommended  
RESR17_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleRecommended 
RESR17_RHCell =  RESR17_RHCellIn AND RESR17_RHCellOut
RESR17_RHMarker = RH AND RRuleRecommended
RESR17_RH = ((( RESR17_RHCell OR RESR17_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:RES.R.17 { @ {RPDMY AND {{OD INTERACT CO} AND RPO}} is recommended being identical to {RH AND {{OD INTERACT CO} AND RPO}}, except BJTDMY/BJT4TDMY
  A = ((RPDMY INTERACT RESR17_RH) AND ((OD INTERACT CO) AND RPO)) XOR ((RH INTERACT RESR17_RH) AND ((OD INTERACT CO) AND RPO))
  A NOT BJTDMY
}
#ENDIF // _RESR17_

#IFDEF _RESR18_
//RES.R.18.R is checked by RR:RE:P:RES.R.18
RESR18_RHCellIn = INSIDE CELL RH CellsForRRuleRecommended  
RESR18_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleRecommended 
RESR18_RHCell =  RESR18_RHCellIn AND RESR18_RHCellOut
RESR18_RHMarker = RH AND RRuleRecommended
RESR18_RH = ((( RESR18_RHCell OR RESR18_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:RES.R.18 { @ {RPDMY AND {{PO INTERACT CO} AND RPO}} is recommended being identical to {RH AND {{PO INTERACT CO} AND RPO}}
  ((RPDMY INTERACT RESR18_RH) AND ((POLY INTERACT CO) AND RPO)) XOR ((RH INTERACT RESR18_RH) AND ((POLY INTERACT CO) AND RPO))
}
#ENDIF // _RESR18_

#IFDEF _RESR19_
//RES.R.19.R is checked by RR:RE:P:RES.R.19
RESR19_RHCellIn = INSIDE CELL RH CellsForRRuleRecommended  
RESR19_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleRecommended 
RESR19_RHCell =  RESR19_RHCellIn AND RESR19_RHCellOut
RESR19_RHMarker = RH AND RRuleRecommended
RESR19_RH = ((( RESR19_RHCell OR RESR19_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:RES.R.19 { @ Recommended: RPDMY intersecting {(OD AND RH) NOT INTERACT RPO} forms two or more ODs.
  A = (OD AND RH) NOT INTERACT RPO
  B = (A INTERACT RPDMY) NOT RPDMY
  ((RPDMY INTERACT RESR19_RH) INTERACT A) NOT INTERACT B >= 2
}
#ENDIF // _RESR19_

#IFDEF _RESR20_
//RES.R.20.R is checked by RR:RE:P:RES.R.20
RESR20_RHCellIn = INSIDE CELL RH CellsForRRuleRecommended  
RESR20_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleRecommended 
RESR20_RHCell =  RESR20_RHCellIn AND RESR20_RHCellOut
RESR20_RHMarker = RH AND RRuleRecommended
RESR20_RH = ((( RESR20_RHCell OR RESR20_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:RES.R.20 { @ Recommended: RPDMY intersecting {(PO AND RH) NOT INTERACT RPO} forms two or more POs.
  A = (POLY AND RH) NOT INTERACT RPO
  B = (A INTERACT RPDMY) NOT RPDMY
  ((RPDMY INTERACT RESR20_RH) INTERACT A) NOT INTERACT B >= 2
}
#ENDIF // _RESR20_

#IFDEF _RESR21_
//RES.R.21.R is checked by RR:RE:P:RES.R.21
RESR21_RHCellIn = INSIDE CELL RH CellsForRRuleRecommended  
RESR21_RHCellOut = NOT INSIDE CELL RH ExclCellsForRRuleRecommended 
RESR21_RHCell =  RESR21_RHCellIn AND RESR21_RHCellOut
RESR21_RHMarker = RH AND RRuleRecommended
RESR21_RH = ((( RESR21_RHCell OR RESR21_RHMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:P:RES.R.21 { @ {CO BUTTED ((RPDMY AND RH) NOT INTERACT RPO)} is recommended.
  A = (RPDMY AND RESR21_RH) NOT INTERACT RPO
  B = A INSIDE EDGE OD
  C = A INSIDE EDGE POLY
  B NOT TOUCH OUTSIDE EDGE CO
  C NOT TOUCH OUTSIDE EDGE CO
}
#ENDIF // _RESR21_

#ENDIF // SPICE 


#IFDEF Systematic
#IFDEF _OD2W2_
OD2W2_OD18CellIn = INSIDE CELL OD_18i CellsForRRuleRecommended  
OD2W2_OD18CellOut = NOT INSIDE CELL OD_18i ExclCellsForRRuleRecommended 
OD2W2_OD18Cell =  OD2W2_OD18CellIn AND OD2W2_OD18CellOut
OD2W2_OD18Marker = OD_18i AND RRuleRecommended
OD2W2_OD18 = ((( OD2W2_OD18Cell OR OD2W2_OD18Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W2_OD25CellIn = INSIDE CELL OD_25i CellsForRRuleRecommended  
OD2W2_OD25CellOut = NOT INSIDE CELL OD_25i ExclCellsForRRuleRecommended 
OD2W2_OD25Cell =  OD2W2_OD25CellIn AND OD2W2_OD25CellOut
OD2W2_OD25Marker = OD_25i AND RRuleRecommended
OD2W2_OD25 = ((( OD2W2_OD25Cell OR OD2W2_OD25Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W2_OD33CellIn = INSIDE CELL OD_33i CellsForRRuleRecommended  
OD2W2_OD33CellOut = NOT INSIDE CELL OD_33i ExclCellsForRRuleRecommended 
OD2W2_OD33Cell =  OD2W2_OD33CellIn AND OD2W2_OD33CellOut
OD2W2_OD33Marker = OD_33i AND RRuleRecommended
OD2W2_OD33 = ((( OD2W2_OD33Cell OR OD2W2_OD33Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W2_NT_NCellIn = INSIDE CELL NT_Ni CellsForRRuleRecommended  
OD2W2_NT_NCellOut = NOT INSIDE CELL NT_Ni ExclCellsForRRuleRecommended 
OD2W2_NT_NCell =  OD2W2_NT_NCellIn AND OD2W2_NT_NCellOut
OD2W2_NT_NMarker = NT_Ni AND RRuleRecommended
OD2W2_NT_N = ((( OD2W2_NT_NCell OR OD2W2_NT_NMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W2_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
OD2W2_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
OD2W2_NWCell =  OD2W2_NWCellIn AND OD2W2_NWCellOut
OD2W2_NWMarker = NWi AND RRuleRecommended
OD2W2_NW = ((( OD2W2_NWCell OR OD2W2_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:OD2.W.2 { @ Width of (OD2 OR (NW OR NT_N)) >= 0.62
@ DRC filter out the errors only on NW.
  OD2W2_OD2 = (OD2W2_OD18 OR OD2W2_OD25) OR OD2W2_OD33   
 Y =  OD2W2_OD2 OR OD2W2_NT_N
  X =  OD2W2_NW OR Y
  A = (INT X < 0.62 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
  (A OUTSIDE SRAM_EXCLUDE) INTERACT Y 
  B = A CUT SRAM_EXCLUDE
  C = (X INTERACT B) NOT SRAM_EXCLUDE
  D = INT C < 0.62 ABUT < 90 SINGULAR REGION 
  (B INTERACT D) INTERACT Y 
}
#ENDIF // _OD2W2_

#IFDEF _OD2W3_
OD2W3_OD18CellIn = INSIDE CELL OD_18i CellsForRRuleRecommended  
OD2W3_OD18CellOut = NOT INSIDE CELL OD_18i ExclCellsForRRuleRecommended 
OD2W3_OD18Cell =  OD2W3_OD18CellIn AND OD2W3_OD18CellOut
OD2W3_OD18Marker = OD_18i AND RRuleRecommended
OD2W3_OD18 = ((( OD2W3_OD18Cell OR OD2W3_OD18Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W3_OD25CellIn = INSIDE CELL OD_25i CellsForRRuleRecommended  
OD2W3_OD25CellOut = NOT INSIDE CELL OD_25i ExclCellsForRRuleRecommended 
OD2W3_OD25Cell =  OD2W3_OD25CellIn AND OD2W3_OD25CellOut
OD2W3_OD25Marker = OD_25i AND RRuleRecommended
OD2W3_OD25 = ((( OD2W3_OD25Cell OR OD2W3_OD25Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W3_OD33CellIn = INSIDE CELL OD_33i CellsForRRuleRecommended  
OD2W3_OD33CellOut = NOT INSIDE CELL OD_33i ExclCellsForRRuleRecommended 
OD2W3_OD33Cell =  OD2W3_OD33CellIn AND OD2W3_OD33CellOut
OD2W3_OD33Marker = OD_33i AND RRuleRecommended
OD2W3_OD33 = ((( OD2W3_OD33Cell OR OD2W3_OD33Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W3_NT_NCellIn = INSIDE CELL NT_Ni CellsForRRuleRecommended  
OD2W3_NT_NCellOut = NOT INSIDE CELL NT_Ni ExclCellsForRRuleRecommended 
OD2W3_NT_NCell =  OD2W3_NT_NCellIn AND OD2W3_NT_NCellOut
OD2W3_NT_NMarker = NT_Ni AND RRuleRecommended
OD2W3_NT_N = ((( OD2W3_NT_NCell OR OD2W3_NT_NMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2W3_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
OD2W3_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
OD2W3_NWCell =  OD2W3_NWCellIn AND OD2W3_NWCellOut
OD2W3_NWMarker = NWi AND RRuleRecommended
OD2W3_NW = ((( OD2W3_NWCell OR OD2W3_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended


RR:RE:S:OD2.W.3 { @ Width of {OD2 NOT {NW OR NT_N}}, except {{OD2 NOT {NW OR NT_N}} [width < ^OD2_W_3R um] NOT INTERACT OD} and LOGO regions >=	^OD2_W_3R
  OD2W3_OD2 = (OD2W3_OD18 OR OD2W3_OD25) OR OD2W3_OD33   
  A = OD2W3_OD2 NOT (OD2W3_NT_N OR OD2W3_NW)
  B = INT A < OD2_W_3R ABUT < 90 SINGULAR REGION
  C = B INTERACT ODi
  C NOT LOGO
}
#ENDIF // _OD2W3_
#IFDEF _OD2S5_
OD2S5_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
OD2S5_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
OD2S5_NWCell =  OD2S5_NWCellIn AND OD2S5_NWCellOut
OD2S5_NWMarker = NWi AND RRuleRecommended
OD2S5_NW = ((( OD2S5_NWCell OR OD2S5_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:OD2.S.5 { @ Recommended Space of (NW NOT OD2) >= 0.62 
  X = OD2S5_NW NOT OD2	
  (EXT X < 0.62 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
#ENDIF // _OD2S5_
#IFDEF _OD2S6_
OD2S6_OD18CellIn = INSIDE CELL OD_18i CellsForRRuleRecommended  
OD2S6_OD18CellOut = NOT INSIDE CELL OD_18i ExclCellsForRRuleRecommended 
OD2S6_OD18Cell =  OD2S6_OD18CellIn AND OD2S6_OD18CellOut
OD2S6_OD18Marker = OD_18i AND RRuleRecommended
OD2S6_OD18 = ((( OD2S6_OD18Cell OR OD2S6_OD18Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S6_OD25CellIn = INSIDE CELL OD_25i CellsForRRuleRecommended  
OD2S6_OD25CellOut = NOT INSIDE CELL OD_25i ExclCellsForRRuleRecommended 
OD2S6_OD25Cell =  OD2S6_OD25CellIn AND OD2S6_OD25CellOut
OD2S6_OD25Marker = OD_25i AND RRuleRecommended
OD2S6_OD25 = ((( OD2S6_OD25Cell OR OD2S6_OD25Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S6_OD33CellIn = INSIDE CELL OD_33i CellsForRRuleRecommended  
OD2S6_OD33CellOut = NOT INSIDE CELL OD_33i ExclCellsForRRuleRecommended 
OD2S6_OD33Cell =  OD2S6_OD33CellIn AND OD2S6_OD33CellOut
OD2S6_OD33Marker = OD_33i AND RRuleRecommended
OD2S6_OD33 = ((( OD2S6_OD33Cell OR OD2S6_OD33Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:OD2.S.6 { @ Recommended Space of (NW AND OD2) >= 0.62 
  OD2S6_OD2 = (OD2S6_OD18 OR OD2S6_OD25) OR OD2S6_OD33     
  X = NWi AND OD2S6_OD2	
  (EXT X <  0.62 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
#ENDIF // _OD2S6_


#IFDEF _OD2S7_
OD2S7_OD18CellIn = INSIDE CELL OD_18i CellsForRRuleRecommended  
OD2S7_OD18CellOut = NOT INSIDE CELL OD_18i ExclCellsForRRuleRecommended 
OD2S7_OD18Cell =  OD2S7_OD18CellIn AND OD2S7_OD18CellOut
OD2S7_OD18Marker = OD_18i AND RRuleRecommended
OD2S7_OD18 = ((( OD2S7_OD18Cell OR OD2S7_OD18Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S7_OD25CellIn = INSIDE CELL OD_25i CellsForRRuleRecommended  
OD2S7_OD25CellOut = NOT INSIDE CELL OD_25i ExclCellsForRRuleRecommended 
OD2S7_OD25Cell =  OD2S7_OD25CellIn AND OD2S7_OD25CellOut
OD2S7_OD25Marker = OD_25i AND RRuleRecommended
OD2S7_OD25 = ((( OD2S7_OD25Cell OR OD2S7_OD25Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S7_OD33CellIn = INSIDE CELL OD_33i CellsForRRuleRecommended  
OD2S7_OD33CellOut = NOT INSIDE CELL OD_33i ExclCellsForRRuleRecommended 
OD2S7_OD33Cell =  OD2S7_OD33CellIn AND OD2S7_OD33CellOut
OD2S7_OD33Marker = OD_33i AND RRuleRecommended
OD2S7_OD33 = ((( OD2S7_OD33Cell OR OD2S7_OD33Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

RR:RE:S:OD2.S.7 { @ Recommended Space of (NW AND OD2) >= 0.62 
   OD2S7_OD2 = (OD2S7_OD18 OR OD2S7_OD25) OR OD2S7_OD33     
   X = OD2S7_OD2 NOT (NWi OR NT_Ni)	
  (EXT X < 0.62 ABUT < 90 SINGULAR REGION) NOT INSIDE SRAM_EXCLUDE
}
#ENDIF // _OD2S7_

#IFDEF _OD2S8_
OD2S8_OD18CellIn = INSIDE CELL OD_18i CellsForRRuleRecommended  
OD2S8_OD18CellOut = NOT INSIDE CELL OD_18i ExclCellsForRRuleRecommended 
OD2S8_OD18Cell =  OD2S8_OD18CellIn AND OD2S8_OD18CellOut
OD2S8_OD18Marker = OD_18i AND RRuleRecommended
OD2S8_OD18 = ((( OD2S8_OD18Cell OR OD2S8_OD18Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S8_OD25CellIn = INSIDE CELL OD_25i CellsForRRuleRecommended  
OD2S8_OD25CellOut = NOT INSIDE CELL OD_25i ExclCellsForRRuleRecommended 
OD2S8_OD25Cell =  OD2S8_OD25CellIn AND OD2S8_OD25CellOut
OD2S8_OD25Marker = OD_25i AND RRuleRecommended
OD2S8_OD25 = ((( OD2S8_OD25Cell OR OD2S8_OD25Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S8_OD33CellIn = INSIDE CELL OD_33i CellsForRRuleRecommended  
OD2S8_OD33CellOut = NOT INSIDE CELL OD_33i ExclCellsForRRuleRecommended 
OD2S8_OD33Cell =  OD2S8_OD33CellIn AND OD2S8_OD33CellOut
OD2S8_OD33Marker = OD_33i AND RRuleRecommended
OD2S8_OD33 = ((( OD2S8_OD33Cell OR OD2S8_OD33Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S8_NT_NCellIn = INSIDE CELL NT_Ni CellsForRRuleRecommended  
OD2S8_NT_NCellOut = NOT INSIDE CELL NT_Ni ExclCellsForRRuleRecommended 
OD2S8_NT_NCell =  OD2S8_NT_NCellIn AND OD2S8_NT_NCellOut
OD2S8_NT_NMarker = NT_Ni AND RRuleRecommended
OD2S8_NT_N = ((( OD2S8_NT_NCell OR OD2S8_NT_NMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

OD2S8_NWCellIn = INSIDE CELL NWi CellsForRRuleRecommended  
OD2S8_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleRecommended 
OD2S8_NWCell =  OD2S8_NWCellIn AND OD2S8_NWCellOut
OD2S8_NWMarker = NWi AND RRuleRecommended
OD2S8_NW = ((( OD2S8_NWCell OR OD2S8_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended


RR:RE:S:OD2.S.8 { @ Space of {OD2 OR {NW OR NT_N}}, except {{OD2 OR {NW OR NT_N}} [space < 0.62 um] NOT INTERACT OD} and LOGO regions >= 0.62
   OD2S8_OD2 = (OD2S8_OD18 OR OD2S8_OD25) OR OD2S8_OD33
   A = OD2S8_OD2 OR (OD2S8_NT_N OR OD2S8_NW)
   B = EXT A < OD2_S_8R ABUT < 90 SINGULAR REGION
   C = B INTERACT ODi
   C NOT LOGO
}
#ENDIF // _OD2S8_
#ENDIF // Systematic 


#IFDEF Defect
#IFDEF _POS1_
POS1_POCellIn = INSIDE CELL POi CellsForRRuleRecommended  
POS1_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleRecommended 
POS1_POCell =  POS1_POCellIn AND POS1_POCellOut
POS1_POMarker = POi AND RRuleRecommended
POS1_PO = ((( POS1_POCell OR POS1_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

POS1Err = EXT [POS1_PO] < 0.18 ABUT < 90
POS1ErrLong = POS1Err NOT TOUCH EDGE GATE // exclude gate space checking
RR:RE:D:PO.S.1 { @ Recommended PO space >= 0.18um, to reduce short possibility
    EXT POS1ErrLong < 0.18 ABUT < 90 REGION
}
#ENDIF // _POS1_
#ENDIF // Defect




#IFDEF SPICE
#IFDEF _VARA1_
VARA1_VARCellIn = INSIDE CELL VARi CellsForRRuleRecommended  
VARA1_VARCellOut = NOT INSIDE CELL VARi ExclCellsForRRuleRecommended 
VARA1_VARCell =  VARA1_VARCellIn AND VARA1_VARCellOut
VARA1_VARMarker = VARi AND RRuleRecommended
VARA1_VAR = ((VARA1_VARCell OR VARA1_VARMarker) NOT Block ) NOT excludeRRuleRecommended

VARA1_GATE = GATE AND VARA1_VAR
RR:RE:P:VAR.A.1 { @ Recommended VAR gate area >= 0.64um2, for  SPICE accuracy
    AREA VARA1_GATE < 0.64
}
#ENDIF // _VARA1_
#ENDIF // SPICE

#IFDEF SP
#IFDEF _COEN1_
COEN1_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN1_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN1_COCell =  COEN1_COCellIn AND COEN1_COCellOut
COEN1_COMarker = COi AND RRuleRecommended
COEN1_CO = ((( COEN1_COCell OR COEN1_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:CO.EN.1 { @ Enclosure by OD >= 0.07
  ENC COEN1_CO OD < 0.07 ABUT < 90 REGION
}
#ENDIF // _COEN1_

#IFDEF _COEN3_
COEN3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
COEN3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
COEN3_COCell =  COEN3_COCellIn AND COEN3_COCellOut
COEN3_COMarker = COi AND RRuleRecommended
COEN3_CO = ((( COEN3_COCell OR COEN3_COMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

RR:RE:SP:CO.EN.3 { @ Enclosure by PO [at least two opposite sides] >= 0.07 
  X = RECTANGLE ENCLOSURE COEN3_CO POLY ABUT < 90 SINGULAR GOOD CO_EN_2 0.07 OPPOSITE CO_EN_2 0.07 OPPOSITE
  Y = ENC [X] POLY < 0.07 ABUT < 90 OPPOSITE
  Z = X TOUCH EDGE Y
  INT Z < CO_W_1 ABUT == 90 INTERSECTING ONLY   // adjacent narrow sides
}
#ENDIF // _COEN3_
#ENDIF // SP


#IFDEF Systematic
#IFDEF _M1S6_
M1S6_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1S6_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1S6_M1Cell =  M1S6_M1CellIn AND M1S6_M1CellOut
M1S6_M1Marker = M1i AND RRuleRecommended
M1S6_M1 = ((M1S6_M1Cell OR M1S6_M1Marker) NOT Block ) NOT excludeRRuleRecommended

M1S6_DM1CellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
M1S6_DM1CellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
M1S6_DM1Cell =  M1S6_DM1CellIn AND M1S6_DM1CellOut
M1S6_DM1Marker = DUM1 AND RRuleRecommended
M1S6_DM1 = ((M1S6_DM1Cell OR M1S6_DM1Marker) NOT Block ) NOT excludeRRuleRecommended

M1S6_M1x = M1S6_M1 OR M1S6_DM1
M1S6_NOT_M1x = CHIP NOT M1x
M1S6_BIGAREA = AREA M1S6_NOT_M1x > BIG_AREA
M1S6_ERROR = (EXT M1S6_BIGAREA M1S6_NOT_M1x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M1S6_M1x 

RR:RE:S:M1.S.6 { @ Recommended space between two non-M1 regions >= 0.35 [ one area > ^BIG_AREA ]
    COPY M1S6_ERROR
}
#ENDIF // _M1S6_
#ENDIF // Systematic 

#IFDEF FSP 
#IFDEF _M1EN2_
M1EN2_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
M1EN2_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
M1EN2_COCell =  M1EN2_COCellIn AND M1EN2_COCellOut
M1EN2_COMarker = COi AND RRuleRecommended
M1EN2_CO = ((( M1EN2_COCell OR M1EN2_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

// Find short ( < 0.025 ) extension and get the perp side
M1EN2:ShortEnc = ENC [ M1EN2_CO ] M1s < 0.025 ABUT < 90 OPPOSITE PARA ONLY
M1EN2:ShortEdge = M1EN2_CO TOUCH EDGE M1EN2:ShortEnc
M1EN2:ShortEdgeExp = ( EXPAND EDGE M1EN2:ShortEdge INSIDE BY 0.02 ) NOT ( EXPAND EDGE M1EN2:ShortEdge INSIDE BY 0.01 )
M1EN2:PerpSide = M1EN2_CO TOUCH EDGE M1EN2:ShortEdgeExp
RR:RE:FSP:M1.EN.2 { @ Recommended M1 enclosure CO [at least two opposite sides] >= 0.07 um, to avoid high Rc
    ENC M1EN2:PerpSide M1s < 0.07 ABUT < 90 REGION OPPOSITE
}
#ENDIF // _M1EN2_

#IFDEF _M1EN3_
M1EN3_COCellIn = INSIDE CELL COi CellsForRRuleRecommended  
M1EN3_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleRecommended 
M1EN3_COCell =  M1EN3_COCellIn AND M1EN3_COCellOut
M1EN3_COMarker = COi AND RRuleRecommended
M1EN3_CO = ((( M1EN3_COCell OR M1EN3_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

M1EN3_M1_BIG = SIZE M1 BY 0.6 / 2 UNDEROVER
M1EN3_M1_BIG_CO = M1EN3_CO NOT OUTSIDE M1EN3_M1_BIG
RR:RE:FSP:M1.EN.3 { @ Recommended M1 [ width > 0.6um ] enclosure CO >= 0.07 um, to avoid high Rc
    ENC M1EN3_M1_BIG_CO M1 < 0.07 ABUT < 90 REGION
}
#ENDIF // _M1EN3_

VARIABLE MIN_ARRAY_3X3 3 * 0.13 + 2 * 0.15 - 0.07



VIA1S3_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
VIA1S3_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
VIA1S3_VIA1Cell =  VIA1S3_VIA1CellIn AND VIA1S3_VIA1CellOut
VIA1S3_VIA1Marker = VIA1i AND RRuleRecommended
VIA1S3_VIA1 = ((( VIA1S3_VIA1Cell OR VIA1S3_VIA1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended


V1Edge = EXT [VIA1i] < 0.17 ABUT < 90 OPPOSITE NOT CONNECTED
V1BigEdge = LENGTH V1Edge >= 0.065
V1Near = VIA1i WITH EDGE V1BigEdge


#IFDEF _VIA1EN1_VIA1EN2_
VIA1EN1_VIA1EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
VIA1EN1_VIA1EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
VIA1EN1_VIA1EN2_VIA1Cell =  VIA1EN1_VIA1EN2_VIA1CellIn AND VIA1EN1_VIA1EN2_VIA1CellOut
VIA1EN1_VIA1EN2_VIA1Marker = VIA1i AND RRuleRecommended
VIA1EN1_VIA1EN2_VIA1 = ((( VIA1EN1_VIA1EN2_VIA1Cell OR VIA1EN1_VIA1EN2_VIA1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleRecommended

// VIA1.EN.0.R is checked by either VIA1.EN.1.R or VIA1.EN.2.R
// VIA1.EN.1.R is checked by RR:RE:FSP:VIA1.EN.1__VIA1.EN.2
// VIA1.EN.2.R is checked by RR:RE:FSP:VIA1.EN.1__VIA1.EN.2
RR:RE:FSP:VIA1.EN.1__VIA1.EN.2 { @ Recommended enclosure of VIA1 at least two opposite sides >= 0.08 um or enclosure of VIA1 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA1EN1_VIA1EN2_VIA1 M1 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M1 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





VIA2S3_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
VIA2S3_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
VIA2S3_VIA2Cell =  VIA2S3_VIA2CellIn AND VIA2S3_VIA2CellOut
VIA2S3_VIA2Marker = VIA2i AND RRuleRecommended
VIA2S3_VIA2 = ((VIA2S3_VIA2Cell OR VIA2S3_VIA2Marker) NOT Block ) NOT excludeRRuleRecommended


V2Edge = EXT [VIA2i] < 0.17 ABUT < 90 OPPOSITE NOT CONNECTED
V2BigEdge = LENGTH V2Edge >= 0.065
V2Near = VIA2i WITH EDGE V2BigEdge


#IFDEF _VIA2EN1_VIA2EN2_
VIA2EN1_VIA2EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
VIA2EN1_VIA2EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
VIA2EN1_VIA2EN2_VIA2Cell =  VIA2EN1_VIA2EN2_VIA2CellIn AND VIA2EN1_VIA2EN2_VIA2CellOut
VIA2EN1_VIA2EN2_VIA2Marker = VIA2i AND RRuleRecommended
VIA2EN1_VIA2EN2_VIA2 = ((VIA2EN1_VIA2EN2_VIA2Cell OR VIA2EN1_VIA2EN2_VIA2Marker) NOT Block ) NOT excludeRRuleRecommended

// VIA2.EN.0.R is checked by either VIA2.EN.1.R or VIA2.EN.2.R
// VIA2.EN.1.R is checked by RR:RE:FSP:VIA2.EN.1__VIA2.EN.2
// VIA2.EN.2.R is checked by RR:RE:FSP:VIA2.EN.1__VIA2.EN.2
RR:RE:FSP:VIA2.EN.1__VIA2.EN.2 { @ Recommended enclosure of VIA2 at least two opposite sides >= 0.08 um or enclosure of VIA2 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA2EN1_VIA2EN2_VIA2 M2 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M2 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





VIA3S3_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
VIA3S3_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
VIA3S3_VIA3Cell =  VIA3S3_VIA3CellIn AND VIA3S3_VIA3CellOut
VIA3S3_VIA3Marker = VIA3i AND RRuleRecommended
VIA3S3_VIA3 = ((VIA3S3_VIA3Cell OR VIA3S3_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended


V3Edge = EXT [VIA3i] < 0.17 ABUT < 90 OPPOSITE NOT CONNECTED
V3BigEdge = LENGTH V3Edge >= 0.065
V3Near = VIA3i WITH EDGE V3BigEdge


#IFDEF _VIA3EN1_VIA3EN2_
VIA3EN1_VIA3EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
VIA3EN1_VIA3EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
VIA3EN1_VIA3EN2_VIA3Cell =  VIA3EN1_VIA3EN2_VIA3CellIn AND VIA3EN1_VIA3EN2_VIA3CellOut
VIA3EN1_VIA3EN2_VIA3Marker = VIA3i AND RRuleRecommended
VIA3EN1_VIA3EN2_VIA3 = ((VIA3EN1_VIA3EN2_VIA3Cell OR VIA3EN1_VIA3EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

// VIA3.EN.0.R is checked by either VIA3.EN.1.R or VIA3.EN.2.R
// VIA3.EN.1.R is checked by RR:RE:FSP:VIA3.EN.1__VIA3.EN.2
// VIA3.EN.2.R is checked by RR:RE:FSP:VIA3.EN.1__VIA3.EN.2
RR:RE:FSP:VIA3.EN.1__VIA3.EN.2 { @ Recommended enclosure of VIA3 at least two opposite sides >= 0.08 um or enclosure of VIA3 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA3EN1_VIA3EN2_VIA3 M3 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M3 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





VIA4S3_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
VIA4S3_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
VIA4S3_VIA4Cell =  VIA4S3_VIA4CellIn AND VIA4S3_VIA4CellOut
VIA4S3_VIA4Marker = VIA4i AND RRuleRecommended
VIA4S3_VIA4 = ((VIA4S3_VIA4Cell OR VIA4S3_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended


V4Edge = EXT [VIA4i] < 0.17 ABUT < 90 OPPOSITE NOT CONNECTED
V4BigEdge = LENGTH V4Edge >= 0.065
V4Near = VIA4i WITH EDGE V4BigEdge


#IFDEF _VIA4EN1_VIA4EN2_
VIA4EN1_VIA4EN2_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
VIA4EN1_VIA4EN2_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
VIA4EN1_VIA4EN2_VIA4Cell =  VIA4EN1_VIA4EN2_VIA4CellIn AND VIA4EN1_VIA4EN2_VIA4CellOut
VIA4EN1_VIA4EN2_VIA4Marker = VIA4i AND RRuleRecommended
VIA4EN1_VIA4EN2_VIA4 = ((VIA4EN1_VIA4EN2_VIA4Cell OR VIA4EN1_VIA4EN2_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended

// VIA4.EN.0.R is checked by either VIA4.EN.1.R or VIA4.EN.2.R
// VIA4.EN.1.R is checked by RR:RE:FSP:VIA4.EN.1__VIA4.EN.2
// VIA4.EN.2.R is checked by RR:RE:FSP:VIA4.EN.1__VIA4.EN.2
RR:RE:FSP:VIA4.EN.1__VIA4.EN.2 { @ Recommended enclosure of VIA4 at least two opposite sides >= 0.08 um or enclosure of VIA4 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA4EN1_VIA4EN2_VIA4 M4 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M4 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





VIA5S3_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleRecommended  
VIA5S3_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleRecommended 
VIA5S3_VIA5Cell =  VIA5S3_VIA5CellIn AND VIA5S3_VIA5CellOut
VIA5S3_VIA5Marker = VIA5i AND RRuleRecommended
VIA5S3_VIA5 = ((VIA5S3_VIA5Cell OR VIA5S3_VIA5Marker) NOT Block ) NOT excludeRRuleRecommended


V5Edge = EXT [VIA5i] < 0.17 ABUT < 90 OPPOSITE NOT CONNECTED
V5BigEdge = LENGTH V5Edge >= 0.065
V5Near = VIA5i WITH EDGE V5BigEdge


#IFDEF _VIA5EN1_VIA5EN2_
VIA5EN1_VIA5EN2_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleRecommended  
VIA5EN1_VIA5EN2_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleRecommended 
VIA5EN1_VIA5EN2_VIA5Cell =  VIA5EN1_VIA5EN2_VIA5CellIn AND VIA5EN1_VIA5EN2_VIA5CellOut
VIA5EN1_VIA5EN2_VIA5Marker = VIA5i AND RRuleRecommended
VIA5EN1_VIA5EN2_VIA5 = ((VIA5EN1_VIA5EN2_VIA5Cell OR VIA5EN1_VIA5EN2_VIA5Marker) NOT Block ) NOT excludeRRuleRecommended

// VIA5.EN.0.R is checked by either VIA5.EN.1.R or VIA5.EN.2.R
// VIA5.EN.1.R is checked by RR:RE:FSP:VIA5.EN.1__VIA5.EN.2
// VIA5.EN.2.R is checked by RR:RE:FSP:VIA5.EN.1__VIA5.EN.2
RR:RE:FSP:VIA5.EN.1__VIA5.EN.2 { @ Recommended enclosure of VIA5 at least two opposite sides >= 0.08 um or enclosure of VIA5 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA5EN1_VIA5EN2_VIA5 M5 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M5 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF





VIA6S3_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleRecommended  
VIA6S3_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleRecommended 
VIA6S3_VIA6Cell =  VIA6S3_VIA6CellIn AND VIA6S3_VIA6CellOut
VIA6S3_VIA6Marker = VIA6i AND RRuleRecommended
VIA6S3_VIA6 = ((VIA6S3_VIA6Cell OR VIA6S3_VIA6Marker) NOT Block ) NOT excludeRRuleRecommended


V6Edge = EXT [VIA6i] < 0.17 ABUT < 90 OPPOSITE NOT CONNECTED
V6BigEdge = LENGTH V6Edge >= 0.065
V6Near = VIA6i WITH EDGE V6BigEdge


#IFDEF _VIA6EN1_VIA6EN2_
VIA6EN1_VIA6EN2_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleRecommended  
VIA6EN1_VIA6EN2_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleRecommended 
VIA6EN1_VIA6EN2_VIA6Cell =  VIA6EN1_VIA6EN2_VIA6CellIn AND VIA6EN1_VIA6EN2_VIA6CellOut
VIA6EN1_VIA6EN2_VIA6Marker = VIA6i AND RRuleRecommended
VIA6EN1_VIA6EN2_VIA6 = ((VIA6EN1_VIA6EN2_VIA6Cell OR VIA6EN1_VIA6EN2_VIA6Marker) NOT Block ) NOT excludeRRuleRecommended

// VIA6.EN.0.R is checked by either VIA6.EN.1.R or VIA6.EN.2.R
// VIA6.EN.1.R is checked by RR:RE:FSP:VIA6.EN.1__VIA6.EN.2
// VIA6.EN.2.R is checked by RR:RE:FSP:VIA6.EN.1__VIA6.EN.2
RR:RE:FSP:VIA6.EN.1__VIA6.EN.2 { @ Recommended enclosure of VIA6 at least two opposite sides >= 0.08 um or enclosure of VIA6 >= 0.05 um, to avoid high Rc 
 A = RECTANGLE ENCLOSURE VIA6EN1_VIA6EN2_VIA6 M6 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M6 < 0.05 ABUT < 90 SINGULAR REGION
}
#ENDIF









#ENDIF  //FSP


#IFDEF Systematic
#IFDEF _M2S6_
M2S6_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2S6_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2S6_M2Cell =  M2S6_M2CellIn AND M2S6_M2CellOut
M2S6_M2Marker = M2i AND RRuleRecommended
M2S6_M2 = ((M2S6_M2Cell OR M2S6_M2Marker) NOT Block ) NOT excludeRRuleRecommended

M2S6_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
M2S6_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
M2S6_DM2Cell =  M2S6_DM2CellIn AND M2S6_DM2CellOut
M2S6_DM2Marker = DUM2 AND RRuleRecommended
M2S6_DM2 = ((M2S6_DM2Cell OR M2S6_DM2Marker) NOT Block ) NOT excludeRRuleRecommended

M2S6_M2x = M2S6_M2 OR M2S6_DM2
M2S6_NOT_M2x = CHIP NOT M2x
M2S6_BIGAREA = AREA M2S6_NOT_M2x > BIG_AREA
M2S6_ERROR = (EXT M2S6_BIGAREA M2S6_NOT_M2x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M2S6_M2x 

RR:RE:S:M2.S.6 { @ Recommended space between two non-M2 regions >= 0.35 [ one area > ^BIG_AREA ]
    COPY M2S6_ERROR
}
#ENDIF // _M2S6_
#ENDIF // Systematic 

#IFDEF FSP
#IFDEF _M2EN1_M2EN2_
M2EN1_M2EN2_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
M2EN1_M2EN2_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
M2EN1_M2EN2_VIA1Cell =  M2EN1_M2EN2_VIA1CellIn AND M2EN1_M2EN2_VIA1CellOut
M2EN1_M2EN2_VIA1Marker = VIA1i AND RRuleRecommended
M2EN1_M2EN2_VIA1 = ((M2EN1_M2EN2_VIA1Cell OR M2EN1_M2EN2_VIA1Marker) NOT Block ) NOT excludeRRuleRecommended

// M2.EN.1.R is checked by RR:RE:FSP:M2.EN.1__M2.EN.2
// M2.EN.2.R is checked by RR:RE:FSP:M2.EN.1__M2.EN.2
RR:RE:FSP:M2.EN.1__M2.EN.2 { @ Recommended enclosure of VIA1 at least two opposite sides >= 0.08 um or enclosure of VIA1 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M2EN1_M2EN2_VIA1 M2 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M2 < 0.05 ABUT < 90 SINGULAR REGION
}
// M2.EN.0.R is checked by RR:RE:FSP:M2.EN.1__M2.EN.2
#ENDIF   
#ENDIF  //FSP
#IFDEF Systematic
#IFDEF _M2W4_
M2W4_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2W4_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2W4_M2Cell =  M2W4_M2CellIn AND M2W4_M2CellOut
M2W4_M2Marker = M2i AND RRuleRecommended
M2W4_M2 = ((M2W4_M2Cell OR M2W4_M2Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M2W4 = M1 OR DUM1
M2W4_EXT = CHIP NOT ( SIZE RR:RE:M2W4 BY 5/2 OVERUNDER )
M2W4_BIG = SIZE( SIZE M2W4_EXT BY 5/2 UNDEROVER ) BY 1.0
M2W4_CHECK = M2W4_M2 INSIDE EDGE M2W4_BIG
RR:RE:S:M2.W.4 { @ Recommended M2 width on (M1 OR DM1 with space>= 5x5 sizing 1) >= 0.16
    INT M2W4_CHECK < 0.16 ABUT < 90 REGION 
}
#ENDIF // _M2W4_
#ENDIF // Systematic




#IFDEF Systematic
#IFDEF _M3S6_
M3S6_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3S6_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3S6_M3Cell =  M3S6_M3CellIn AND M3S6_M3CellOut
M3S6_M3Marker = M3i AND RRuleRecommended
M3S6_M3 = ((M3S6_M3Cell OR M3S6_M3Marker) NOT Block ) NOT excludeRRuleRecommended

M3S6_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
M3S6_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
M3S6_DM3Cell =  M3S6_DM3CellIn AND M3S6_DM3CellOut
M3S6_DM3Marker = DUM3 AND RRuleRecommended
M3S6_DM3 = ((M3S6_DM3Cell OR M3S6_DM3Marker) NOT Block ) NOT excludeRRuleRecommended

M3S6_M3x = M3S6_M3 OR M3S6_DM3
M3S6_NOT_M3x = CHIP NOT M3x
M3S6_BIGAREA = AREA M3S6_NOT_M3x > BIG_AREA
M3S6_ERROR = (EXT M3S6_BIGAREA M3S6_NOT_M3x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M3S6_M3x 

RR:RE:S:M3.S.6 { @ Recommended space between two non-M3 regions >= 0.35 [ one area > ^BIG_AREA ]
    COPY M3S6_ERROR
}
#ENDIF // _M3S6_
#ENDIF // Systematic 

#IFDEF FSP
#IFDEF _M3EN1_M3EN2_
M3EN1_M3EN2_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleRecommended  
M3EN1_M3EN2_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleRecommended 
M3EN1_M3EN2_VIA2Cell =  M3EN1_M3EN2_VIA2CellIn AND M3EN1_M3EN2_VIA2CellOut
M3EN1_M3EN2_VIA2Marker = VIA2i AND RRuleRecommended
M3EN1_M3EN2_VIA2 = ((M3EN1_M3EN2_VIA2Cell OR M3EN1_M3EN2_VIA2Marker) NOT Block ) NOT excludeRRuleRecommended

// M3.EN.1.R is checked by RR:RE:FSP:M3.EN.1__M3.EN.2
// M3.EN.2.R is checked by RR:RE:FSP:M3.EN.1__M3.EN.2
RR:RE:FSP:M3.EN.1__M3.EN.2 { @ Recommended enclosure of VIA2 at least two opposite sides >= 0.08 um or enclosure of VIA2 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M3EN1_M3EN2_VIA2 M3 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M3 < 0.05 ABUT < 90 SINGULAR REGION
}
// M3.EN.0.R is checked by RR:RE:FSP:M3.EN.1__M3.EN.2
#ENDIF   
#ENDIF  //FSP
#IFDEF Systematic
#IFDEF _M3W4_
M3W4_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3W4_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3W4_M3Cell =  M3W4_M3CellIn AND M3W4_M3CellOut
M3W4_M3Marker = M3i AND RRuleRecommended
M3W4_M3 = ((M3W4_M3Cell OR M3W4_M3Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M3W4 = M2 OR DUM2
M3W4_EXT = CHIP NOT ( SIZE RR:RE:M3W4 BY 5/2 OVERUNDER )
M3W4_BIG = SIZE( SIZE M3W4_EXT BY 5/2 UNDEROVER ) BY 1.0
M3W4_CHECK = M3W4_M3 INSIDE EDGE M3W4_BIG
RR:RE:S:M3.W.4 { @ Recommended M3 width on (M2 OR DM2 with space>= 5x5 sizing 1) >= 0.16
    INT M3W4_CHECK < 0.16 ABUT < 90 REGION 
}
#ENDIF // _M3W4_
#ENDIF // Systematic




#IFDEF Systematic
#IFDEF _M4S6_
M4S6_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4S6_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4S6_M4Cell =  M4S6_M4CellIn AND M4S6_M4CellOut
M4S6_M4Marker = M4i AND RRuleRecommended
M4S6_M4 = ((M4S6_M4Cell OR M4S6_M4Marker) NOT Block ) NOT excludeRRuleRecommended

M4S6_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
M4S6_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
M4S6_DM4Cell =  M4S6_DM4CellIn AND M4S6_DM4CellOut
M4S6_DM4Marker = DUM4 AND RRuleRecommended
M4S6_DM4 = ((M4S6_DM4Cell OR M4S6_DM4Marker) NOT Block ) NOT excludeRRuleRecommended

M4S6_M4x = M4S6_M4 OR M4S6_DM4
M4S6_NOT_M4x = CHIP NOT M4x
M4S6_BIGAREA = AREA M4S6_NOT_M4x > BIG_AREA
M4S6_ERROR = (EXT M4S6_BIGAREA M4S6_NOT_M4x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M4S6_M4x 

RR:RE:S:M4.S.6 { @ Recommended space between two non-M4 regions >= 0.35 [ one area > ^BIG_AREA ]
    COPY M4S6_ERROR
}
#ENDIF // _M4S6_
#ENDIF // Systematic 

#IFDEF FSP
#IFDEF _M4EN1_M4EN2_
M4EN1_M4EN2_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleRecommended  
M4EN1_M4EN2_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleRecommended 
M4EN1_M4EN2_VIA3Cell =  M4EN1_M4EN2_VIA3CellIn AND M4EN1_M4EN2_VIA3CellOut
M4EN1_M4EN2_VIA3Marker = VIA3i AND RRuleRecommended
M4EN1_M4EN2_VIA3 = ((M4EN1_M4EN2_VIA3Cell OR M4EN1_M4EN2_VIA3Marker) NOT Block ) NOT excludeRRuleRecommended

// M4.EN.1.R is checked by RR:RE:FSP:M4.EN.1__M4.EN.2
// M4.EN.2.R is checked by RR:RE:FSP:M4.EN.1__M4.EN.2
RR:RE:FSP:M4.EN.1__M4.EN.2 { @ Recommended enclosure of VIA3 at least two opposite sides >= 0.08 um or enclosure of VIA3 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M4EN1_M4EN2_VIA3 M4 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M4 < 0.05 ABUT < 90 SINGULAR REGION
}
// M4.EN.0.R is checked by RR:RE:FSP:M4.EN.1__M4.EN.2
#ENDIF   
#ENDIF  //FSP
#IFDEF Systematic
#IFDEF _M4W4_
M4W4_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4W4_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4W4_M4Cell =  M4W4_M4CellIn AND M4W4_M4CellOut
M4W4_M4Marker = M4i AND RRuleRecommended
M4W4_M4 = ((M4W4_M4Cell OR M4W4_M4Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M4W4 = M3 OR DUM3
M4W4_EXT = CHIP NOT ( SIZE RR:RE:M4W4 BY 5/2 OVERUNDER )
M4W4_BIG = SIZE( SIZE M4W4_EXT BY 5/2 UNDEROVER ) BY 1.0
M4W4_CHECK = M4W4_M4 INSIDE EDGE M4W4_BIG
RR:RE:S:M4.W.4 { @ Recommended M4 width on (M3 OR DM3 with space>= 5x5 sizing 1) >= 0.16
    INT M4W4_CHECK < 0.16 ABUT < 90 REGION 
}
#ENDIF // _M4W4_
#ENDIF // Systematic




#IFDEF Systematic
#IFDEF _M5S6_
M5S6_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5S6_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5S6_M5Cell =  M5S6_M5CellIn AND M5S6_M5CellOut
M5S6_M5Marker = M5i AND RRuleRecommended
M5S6_M5 = ((M5S6_M5Cell OR M5S6_M5Marker) NOT Block ) NOT excludeRRuleRecommended

M5S6_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
M5S6_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
M5S6_DM5Cell =  M5S6_DM5CellIn AND M5S6_DM5CellOut
M5S6_DM5Marker = DUM5 AND RRuleRecommended
M5S6_DM5 = ((M5S6_DM5Cell OR M5S6_DM5Marker) NOT Block ) NOT excludeRRuleRecommended

M5S6_M5x = M5S6_M5 OR M5S6_DM5
M5S6_NOT_M5x = CHIP NOT M5x
M5S6_BIGAREA = AREA M5S6_NOT_M5x > BIG_AREA
M5S6_ERROR = (EXT M5S6_BIGAREA M5S6_NOT_M5x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M5S6_M5x 

RR:RE:S:M5.S.6 { @ Recommended space between two non-M5 regions >= 0.35 [ one area > ^BIG_AREA ]
    COPY M5S6_ERROR
}
#ENDIF // _M5S6_
#ENDIF // Systematic 

#IFDEF FSP
#IFDEF _M5EN1_M5EN2_
M5EN1_M5EN2_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleRecommended  
M5EN1_M5EN2_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleRecommended 
M5EN1_M5EN2_VIA4Cell =  M5EN1_M5EN2_VIA4CellIn AND M5EN1_M5EN2_VIA4CellOut
M5EN1_M5EN2_VIA4Marker = VIA4i AND RRuleRecommended
M5EN1_M5EN2_VIA4 = ((M5EN1_M5EN2_VIA4Cell OR M5EN1_M5EN2_VIA4Marker) NOT Block ) NOT excludeRRuleRecommended

// M5.EN.1.R is checked by RR:RE:FSP:M5.EN.1__M5.EN.2
// M5.EN.2.R is checked by RR:RE:FSP:M5.EN.1__M5.EN.2
RR:RE:FSP:M5.EN.1__M5.EN.2 { @ Recommended enclosure of VIA4 at least two opposite sides >= 0.08 um or enclosure of VIA4 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M5EN1_M5EN2_VIA4 M5 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M5 < 0.05 ABUT < 90 SINGULAR REGION
}
// M5.EN.0.R is checked by RR:RE:FSP:M5.EN.1__M5.EN.2
#ENDIF   
#ENDIF  //FSP
#IFDEF Systematic
#IFDEF _M5W4_
M5W4_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5W4_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5W4_M5Cell =  M5W4_M5CellIn AND M5W4_M5CellOut
M5W4_M5Marker = M5i AND RRuleRecommended
M5W4_M5 = ((M5W4_M5Cell OR M5W4_M5Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M5W4 = M4 OR DUM4
M5W4_EXT = CHIP NOT ( SIZE RR:RE:M5W4 BY 5/2 OVERUNDER )
M5W4_BIG = SIZE( SIZE M5W4_EXT BY 5/2 UNDEROVER ) BY 1.0
M5W4_CHECK = M5W4_M5 INSIDE EDGE M5W4_BIG
RR:RE:S:M5.W.4 { @ Recommended M5 width on (M4 OR DM4 with space>= 5x5 sizing 1) >= 0.16
    INT M5W4_CHECK < 0.16 ABUT < 90 REGION 
}
#ENDIF // _M5W4_
#ENDIF // Systematic




#IFDEF Systematic
#IFDEF _M6S6_
M6S6_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
M6S6_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
M6S6_M6Cell =  M6S6_M6CellIn AND M6S6_M6CellOut
M6S6_M6Marker = M6i AND RRuleRecommended
M6S6_M6 = ((M6S6_M6Cell OR M6S6_M6Marker) NOT Block ) NOT excludeRRuleRecommended

M6S6_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
M6S6_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
M6S6_DM6Cell =  M6S6_DM6CellIn AND M6S6_DM6CellOut
M6S6_DM6Marker = DUM6 AND RRuleRecommended
M6S6_DM6 = ((M6S6_DM6Cell OR M6S6_DM6Marker) NOT Block ) NOT excludeRRuleRecommended

M6S6_M6x = M6S6_M6 OR M6S6_DM6
M6S6_NOT_M6x = CHIP NOT M6x
M6S6_BIGAREA = AREA M6S6_NOT_M6x > BIG_AREA
M6S6_ERROR = (EXT M6S6_BIGAREA M6S6_NOT_M6x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M6S6_M6x 

RR:RE:S:M6.S.6 { @ Recommended space between two non-M6 regions >= 0.35 [ one area > ^BIG_AREA ]
    COPY M6S6_ERROR
}
#ENDIF // _M6S6_
#ENDIF // Systematic 

#IFDEF FSP
#IFDEF _M6EN1_M6EN2_
M6EN1_M6EN2_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleRecommended  
M6EN1_M6EN2_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleRecommended 
M6EN1_M6EN2_VIA5Cell =  M6EN1_M6EN2_VIA5CellIn AND M6EN1_M6EN2_VIA5CellOut
M6EN1_M6EN2_VIA5Marker = VIA5i AND RRuleRecommended
M6EN1_M6EN2_VIA5 = ((M6EN1_M6EN2_VIA5Cell OR M6EN1_M6EN2_VIA5Marker) NOT Block ) NOT excludeRRuleRecommended

// M6.EN.1.R is checked by RR:RE:FSP:M6.EN.1__M6.EN.2
// M6.EN.2.R is checked by RR:RE:FSP:M6.EN.1__M6.EN.2
RR:RE:FSP:M6.EN.1__M6.EN.2 { @ Recommended enclosure of VIA5 at least two opposite sides >= 0.08 um or enclosure of VIA5 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M6EN1_M6EN2_VIA5 M6 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M6 < 0.05 ABUT < 90 SINGULAR REGION
}
// M6.EN.0.R is checked by RR:RE:FSP:M6.EN.1__M6.EN.2
#ENDIF   
#ENDIF  //FSP
#IFDEF Systematic
#IFDEF _M6W4_
M6W4_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
M6W4_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
M6W4_M6Cell =  M6W4_M6CellIn AND M6W4_M6CellOut
M6W4_M6Marker = M6i AND RRuleRecommended
M6W4_M6 = ((M6W4_M6Cell OR M6W4_M6Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M6W4 = M5 OR DUM5
M6W4_EXT = CHIP NOT ( SIZE RR:RE:M6W4 BY 5/2 OVERUNDER )
M6W4_BIG = SIZE( SIZE M6W4_EXT BY 5/2 UNDEROVER ) BY 1.0
M6W4_CHECK = M6W4_M6 INSIDE EDGE M6W4_BIG
RR:RE:S:M6.W.4 { @ Recommended M6 width on (M5 OR DM5 with space>= 5x5 sizing 1) >= 0.16
    INT M6W4_CHECK < 0.16 ABUT < 90 REGION 
}
#ENDIF // _M6W4_
#ENDIF // Systematic




#IFDEF Systematic
#IFDEF _M7S6_
M7S6_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
M7S6_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
M7S6_M7Cell =  M7S6_M7CellIn AND M7S6_M7CellOut
M7S6_M7Marker = M7i AND RRuleRecommended
M7S6_M7 = ((M7S6_M7Cell OR M7S6_M7Marker) NOT Block ) NOT excludeRRuleRecommended

M7S6_DM7CellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
M7S6_DM7CellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
M7S6_DM7Cell =  M7S6_DM7CellIn AND M7S6_DM7CellOut
M7S6_DM7Marker = DUM7 AND RRuleRecommended
M7S6_DM7 = ((M7S6_DM7Cell OR M7S6_DM7Marker) NOT Block ) NOT excludeRRuleRecommended

M7S6_M7x = M7S6_M7 OR M7S6_DM7
M7S6_NOT_M7x = CHIP NOT M7x
M7S6_BIGAREA = AREA M7S6_NOT_M7x > BIG_AREA
M7S6_ERROR = (EXT M7S6_BIGAREA M7S6_NOT_M7x < 0.35 SPACE ABUT < 90 SINGULAR REGION) NOT OUTSIDE M7S6_M7x 

RR:RE:S:M7.S.6 { @ Recommended space between two non-M7 regions >= 0.35 [ one area > ^BIG_AREA ]
    COPY M7S6_ERROR
}
#ENDIF // _M7S6_
#ENDIF // Systematic 

#IFDEF FSP
#IFDEF _M7EN1_M7EN2_
M7EN1_M7EN2_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleRecommended  
M7EN1_M7EN2_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleRecommended 
M7EN1_M7EN2_VIA6Cell =  M7EN1_M7EN2_VIA6CellIn AND M7EN1_M7EN2_VIA6CellOut
M7EN1_M7EN2_VIA6Marker = VIA6i AND RRuleRecommended
M7EN1_M7EN2_VIA6 = ((M7EN1_M7EN2_VIA6Cell OR M7EN1_M7EN2_VIA6Marker) NOT Block ) NOT excludeRRuleRecommended

// M7.EN.1.R is checked by RR:RE:FSP:M7.EN.1__M7.EN.2
// M7.EN.2.R is checked by RR:RE:FSP:M7.EN.1__M7.EN.2
RR:RE:FSP:M7.EN.1__M7.EN.2 { @ Recommended enclosure of VIA6 at least two opposite sides >= 0.08 um or enclosure of VIA6 >= 0.05 um, to avoid high Rc
 A = RECTANGLE ENCLOSURE M7EN1_M7EN2_VIA6 M7 ABUT < 90 SINGULAR GOOD 0.005 0.08 OPPOSITE 0.005 0.08 OPPOSITE
 ENC A M7 < 0.05 ABUT < 90 SINGULAR REGION
}
// M7.EN.0.R is checked by RR:RE:FSP:M7.EN.1__M7.EN.2
#ENDIF   
#ENDIF  //FSP
#IFDEF Systematic
#IFDEF _M7W4_
M7W4_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
M7W4_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
M7W4_M7Cell =  M7W4_M7CellIn AND M7W4_M7CellOut
M7W4_M7Marker = M7i AND RRuleRecommended
M7W4_M7 = ((M7W4_M7Cell OR M7W4_M7Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M7W4 = M6 OR DUM6
M7W4_EXT = CHIP NOT ( SIZE RR:RE:M7W4 BY 5/2 OVERUNDER )
M7W4_BIG = SIZE( SIZE M7W4_EXT BY 5/2 UNDEROVER ) BY 1.0
M7W4_CHECK = M7W4_M7 INSIDE EDGE M7W4_BIG
RR:RE:S:M7.W.4 { @ Recommended M7 width on (M6 OR DM6 with space>= 5x5 sizing 1) >= 0.16
    INT M7W4_CHECK < 0.16 ABUT < 90 REGION 
}
#ENDIF // _M7W4_
#ENDIF // Systematic







#IFDEF Systematic

#IFDEF _M1DN3_
M1DN3_M1CellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1DN3_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1DN3_M1Cell =  M1DN3_M1CellIn AND M1DN3_M1CellOut
M1DN3_M1Marker = M1i AND RRuleRecommended
M1DN3_M1 = ((M1DN3_M1Cell OR M1DN3_M1Marker) NOT Block ) NOT excludeRRuleRecommended

M1DN3_DM1CellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
M1DN3_DM1CellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
M1DN3_DM1Cell =  M1DN3_DM1CellIn AND M1DN3_DM1CellOut
M1DN3_DM1Marker = DUM1 AND RRuleRecommended
M1DN3_DM1 = ((M1DN3_DM1Cell OR M1DN3_DM1Marker) NOT Block ) NOT excludeRRuleRecommended

M1DN3_DM1EXCLCellIn = INSIDE CELL DM1EXCL CellsForRRuleRecommended  
M1DN3_DM1EXCLCellOut = NOT INSIDE CELL DM1EXCL ExclCellsForRRuleRecommended 
M1DN3_DM1EXCLCell =  M1DN3_DM1EXCLCellIn AND M1DN3_DM1EXCLCellOut
M1DN3_DM1EXCLMarker = DM1EXCL AND RRuleRecommended
M1DN3_DM1EXCL = ((M1DN3_DM1EXCLCell OR M1DN3_DM1EXCLMarker) NOT Block ) NOT excludeRRuleRecommended

M1DN3_M1x = M1DN3_M1 OR M1DN3_DM1
M1DN3_M1_NOT_EXC = M1DN3_M1x NOT M1_EXC_L1
M1DN3_CHIP_NOT_M1_EXC_L = CHIP NOT M1_EXC_L1
M1DN3_M1_AND_DM1EXCL = M1DN3_M1_NOT_EXC AND M1DN3_DM1EXCL
M1DN3_CHIP_AND_DM1EXCL = M1DN3_CHIP_NOT_M1_EXC_L AND M1DN3_DM1EXCL
M1DN3_ERR_WIN = DENSITY M1DN3_M1_AND_DM1EXCL M1DN3_CHIP_AND_DM1EXCL < 0.20 WINDOW 10 STEP 5  
            	[ AREA(M1DN3_M1_AND_DM1EXCL)/AREA(M1DN3_CHIP_AND_DM1EXCL) ]
				
M1DN3_ERR_SIZE = SIZE ((M1DN3_ERR_WIN AND M1DN3_DM1EXCL) NOT M1_EXC_L2) BY (2.5-0.002)/2 UNDEROVER TRUNCATE (2.5-0.002)/2 
M1DN3_ERR = M1DN3_ERR_SIZE NOT M1DN3_M1x
RR:RE:S:M1.DN.3 { @ M1 density within DM1EXCL < 20% with 3x3 open region inside
    ENCLOSE RECTANGLE M1DN3_ERR 3 3
}
#ENDIF // _M1DN3_





#IFDEF _M2DN3_
M2DN3_M2CellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2DN3_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2DN3_M2Cell =  M2DN3_M2CellIn AND M2DN3_M2CellOut
M2DN3_M2Marker = M2i AND RRuleRecommended
M2DN3_M2 = ((M2DN3_M2Cell OR M2DN3_M2Marker) NOT Block ) NOT excludeRRuleRecommended

M2DN3_DM2CellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
M2DN3_DM2CellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
M2DN3_DM2Cell =  M2DN3_DM2CellIn AND M2DN3_DM2CellOut
M2DN3_DM2Marker = DUM2 AND RRuleRecommended
M2DN3_DM2 = ((M2DN3_DM2Cell OR M2DN3_DM2Marker) NOT Block ) NOT excludeRRuleRecommended

M2DN3_DM2EXCLCellIn = INSIDE CELL DM2EXCL CellsForRRuleRecommended  
M2DN3_DM2EXCLCellOut = NOT INSIDE CELL DM2EXCL ExclCellsForRRuleRecommended 
M2DN3_DM2EXCLCell =  M2DN3_DM2EXCLCellIn AND M2DN3_DM2EXCLCellOut
M2DN3_DM2EXCLMarker = DM2EXCL AND RRuleRecommended
M2DN3_DM2EXCL = ((M2DN3_DM2EXCLCell OR M2DN3_DM2EXCLMarker) NOT Block ) NOT excludeRRuleRecommended

M2DN3_M2x = M2DN3_M2 OR M2DN3_DM2
M2DN3_M2_NOT_EXC = M2DN3_M2x NOT M2_EXC_L1
M2DN3_CHIP_NOT_M2_EXC_L = CHIP NOT M2_EXC_L1
M2DN3_M2_AND_DM2EXCL = M2DN3_M2_NOT_EXC AND M2DN3_DM2EXCL
M2DN3_CHIP_AND_DM2EXCL = M2DN3_CHIP_NOT_M2_EXC_L AND M2DN3_DM2EXCL
M2DN3_ERR_WIN = DENSITY M2DN3_M2_AND_DM2EXCL M2DN3_CHIP_AND_DM2EXCL < 0.20 WINDOW 10 STEP 5  
            	[ AREA(M2DN3_M2_AND_DM2EXCL)/AREA(M2DN3_CHIP_AND_DM2EXCL) ]
				
M2DN3_ERR_SIZE = SIZE ((M2DN3_ERR_WIN AND M2DN3_DM2EXCL) NOT M2_EXC_L2) BY (2.5-0.002)/2 UNDEROVER TRUNCATE (2.5-0.002)/2 
M2DN3_ERR = M2DN3_ERR_SIZE NOT M2DN3_M2x
RR:RE:S:M2.DN.3 { @ M2 density within DM2EXCL < 20% with 3x3 open region inside
    ENCLOSE RECTANGLE M2DN3_ERR 3 3
}
#ENDIF // _M2DN3_





#IFDEF _M3DN3_
M3DN3_M3CellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3DN3_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3DN3_M3Cell =  M3DN3_M3CellIn AND M3DN3_M3CellOut
M3DN3_M3Marker = M3i AND RRuleRecommended
M3DN3_M3 = ((M3DN3_M3Cell OR M3DN3_M3Marker) NOT Block ) NOT excludeRRuleRecommended

M3DN3_DM3CellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
M3DN3_DM3CellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
M3DN3_DM3Cell =  M3DN3_DM3CellIn AND M3DN3_DM3CellOut
M3DN3_DM3Marker = DUM3 AND RRuleRecommended
M3DN3_DM3 = ((M3DN3_DM3Cell OR M3DN3_DM3Marker) NOT Block ) NOT excludeRRuleRecommended

M3DN3_DM3EXCLCellIn = INSIDE CELL DM3EXCL CellsForRRuleRecommended  
M3DN3_DM3EXCLCellOut = NOT INSIDE CELL DM3EXCL ExclCellsForRRuleRecommended 
M3DN3_DM3EXCLCell =  M3DN3_DM3EXCLCellIn AND M3DN3_DM3EXCLCellOut
M3DN3_DM3EXCLMarker = DM3EXCL AND RRuleRecommended
M3DN3_DM3EXCL = ((M3DN3_DM3EXCLCell OR M3DN3_DM3EXCLMarker) NOT Block ) NOT excludeRRuleRecommended

M3DN3_M3x = M3DN3_M3 OR M3DN3_DM3
M3DN3_M3_NOT_EXC = M3DN3_M3x NOT M3_EXC_L1
M3DN3_CHIP_NOT_M3_EXC_L = CHIP NOT M3_EXC_L1
M3DN3_M3_AND_DM3EXCL = M3DN3_M3_NOT_EXC AND M3DN3_DM3EXCL
M3DN3_CHIP_AND_DM3EXCL = M3DN3_CHIP_NOT_M3_EXC_L AND M3DN3_DM3EXCL
M3DN3_ERR_WIN = DENSITY M3DN3_M3_AND_DM3EXCL M3DN3_CHIP_AND_DM3EXCL < 0.20 WINDOW 10 STEP 5  
            	[ AREA(M3DN3_M3_AND_DM3EXCL)/AREA(M3DN3_CHIP_AND_DM3EXCL) ]
				
M3DN3_ERR_SIZE = SIZE ((M3DN3_ERR_WIN AND M3DN3_DM3EXCL) NOT M3_EXC_L2) BY (2.5-0.002)/2 UNDEROVER TRUNCATE (2.5-0.002)/2 
M3DN3_ERR = M3DN3_ERR_SIZE NOT M3DN3_M3x
RR:RE:S:M3.DN.3 { @ M3 density within DM3EXCL < 20% with 3x3 open region inside
    ENCLOSE RECTANGLE M3DN3_ERR 3 3
}
#ENDIF // _M3DN3_





#IFDEF _M4DN3_
M4DN3_M4CellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4DN3_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4DN3_M4Cell =  M4DN3_M4CellIn AND M4DN3_M4CellOut
M4DN3_M4Marker = M4i AND RRuleRecommended
M4DN3_M4 = ((M4DN3_M4Cell OR M4DN3_M4Marker) NOT Block ) NOT excludeRRuleRecommended

M4DN3_DM4CellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
M4DN3_DM4CellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
M4DN3_DM4Cell =  M4DN3_DM4CellIn AND M4DN3_DM4CellOut
M4DN3_DM4Marker = DUM4 AND RRuleRecommended
M4DN3_DM4 = ((M4DN3_DM4Cell OR M4DN3_DM4Marker) NOT Block ) NOT excludeRRuleRecommended

M4DN3_DM4EXCLCellIn = INSIDE CELL DM4EXCL CellsForRRuleRecommended  
M4DN3_DM4EXCLCellOut = NOT INSIDE CELL DM4EXCL ExclCellsForRRuleRecommended 
M4DN3_DM4EXCLCell =  M4DN3_DM4EXCLCellIn AND M4DN3_DM4EXCLCellOut
M4DN3_DM4EXCLMarker = DM4EXCL AND RRuleRecommended
M4DN3_DM4EXCL = ((M4DN3_DM4EXCLCell OR M4DN3_DM4EXCLMarker) NOT Block ) NOT excludeRRuleRecommended

M4DN3_M4x = M4DN3_M4 OR M4DN3_DM4
M4DN3_M4_NOT_EXC = M4DN3_M4x NOT M4_EXC_L1
M4DN3_CHIP_NOT_M4_EXC_L = CHIP NOT M4_EXC_L1
M4DN3_M4_AND_DM4EXCL = M4DN3_M4_NOT_EXC AND M4DN3_DM4EXCL
M4DN3_CHIP_AND_DM4EXCL = M4DN3_CHIP_NOT_M4_EXC_L AND M4DN3_DM4EXCL
M4DN3_ERR_WIN = DENSITY M4DN3_M4_AND_DM4EXCL M4DN3_CHIP_AND_DM4EXCL < 0.20 WINDOW 10 STEP 5  
            	[ AREA(M4DN3_M4_AND_DM4EXCL)/AREA(M4DN3_CHIP_AND_DM4EXCL) ]
				
M4DN3_ERR_SIZE = SIZE ((M4DN3_ERR_WIN AND M4DN3_DM4EXCL) NOT M4_EXC_L2) BY (2.5-0.002)/2 UNDEROVER TRUNCATE (2.5-0.002)/2 
M4DN3_ERR = M4DN3_ERR_SIZE NOT M4DN3_M4x
RR:RE:S:M4.DN.3 { @ M4 density within DM4EXCL < 20% with 3x3 open region inside
    ENCLOSE RECTANGLE M4DN3_ERR 3 3
}
#ENDIF // _M4DN3_





#IFDEF _M5DN3_
M5DN3_M5CellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5DN3_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5DN3_M5Cell =  M5DN3_M5CellIn AND M5DN3_M5CellOut
M5DN3_M5Marker = M5i AND RRuleRecommended
M5DN3_M5 = ((M5DN3_M5Cell OR M5DN3_M5Marker) NOT Block ) NOT excludeRRuleRecommended

M5DN3_DM5CellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
M5DN3_DM5CellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
M5DN3_DM5Cell =  M5DN3_DM5CellIn AND M5DN3_DM5CellOut
M5DN3_DM5Marker = DUM5 AND RRuleRecommended
M5DN3_DM5 = ((M5DN3_DM5Cell OR M5DN3_DM5Marker) NOT Block ) NOT excludeRRuleRecommended

M5DN3_DM5EXCLCellIn = INSIDE CELL DM5EXCL CellsForRRuleRecommended  
M5DN3_DM5EXCLCellOut = NOT INSIDE CELL DM5EXCL ExclCellsForRRuleRecommended 
M5DN3_DM5EXCLCell =  M5DN3_DM5EXCLCellIn AND M5DN3_DM5EXCLCellOut
M5DN3_DM5EXCLMarker = DM5EXCL AND RRuleRecommended
M5DN3_DM5EXCL = ((M5DN3_DM5EXCLCell OR M5DN3_DM5EXCLMarker) NOT Block ) NOT excludeRRuleRecommended

M5DN3_M5x = M5DN3_M5 OR M5DN3_DM5
M5DN3_M5_NOT_EXC = M5DN3_M5x NOT M5_EXC_L1
M5DN3_CHIP_NOT_M5_EXC_L = CHIP NOT M5_EXC_L1
M5DN3_M5_AND_DM5EXCL = M5DN3_M5_NOT_EXC AND M5DN3_DM5EXCL
M5DN3_CHIP_AND_DM5EXCL = M5DN3_CHIP_NOT_M5_EXC_L AND M5DN3_DM5EXCL
M5DN3_ERR_WIN = DENSITY M5DN3_M5_AND_DM5EXCL M5DN3_CHIP_AND_DM5EXCL < 0.20 WINDOW 10 STEP 5  
            	[ AREA(M5DN3_M5_AND_DM5EXCL)/AREA(M5DN3_CHIP_AND_DM5EXCL) ]
				
M5DN3_ERR_SIZE = SIZE ((M5DN3_ERR_WIN AND M5DN3_DM5EXCL) NOT M5_EXC_L2) BY (2.5-0.002)/2 UNDEROVER TRUNCATE (2.5-0.002)/2 
M5DN3_ERR = M5DN3_ERR_SIZE NOT M5DN3_M5x
RR:RE:S:M5.DN.3 { @ M5 density within DM5EXCL < 20% with 3x3 open region inside
    ENCLOSE RECTANGLE M5DN3_ERR 3 3
}
#ENDIF // _M5DN3_





#IFDEF _M6DN3_
M6DN3_M6CellIn = INSIDE CELL M6i CellsForRRuleRecommended  
M6DN3_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
M6DN3_M6Cell =  M6DN3_M6CellIn AND M6DN3_M6CellOut
M6DN3_M6Marker = M6i AND RRuleRecommended
M6DN3_M6 = ((M6DN3_M6Cell OR M6DN3_M6Marker) NOT Block ) NOT excludeRRuleRecommended

M6DN3_DM6CellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
M6DN3_DM6CellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
M6DN3_DM6Cell =  M6DN3_DM6CellIn AND M6DN3_DM6CellOut
M6DN3_DM6Marker = DUM6 AND RRuleRecommended
M6DN3_DM6 = ((M6DN3_DM6Cell OR M6DN3_DM6Marker) NOT Block ) NOT excludeRRuleRecommended

M6DN3_DM6EXCLCellIn = INSIDE CELL DM6EXCL CellsForRRuleRecommended  
M6DN3_DM6EXCLCellOut = NOT INSIDE CELL DM6EXCL ExclCellsForRRuleRecommended 
M6DN3_DM6EXCLCell =  M6DN3_DM6EXCLCellIn AND M6DN3_DM6EXCLCellOut
M6DN3_DM6EXCLMarker = DM6EXCL AND RRuleRecommended
M6DN3_DM6EXCL = ((M6DN3_DM6EXCLCell OR M6DN3_DM6EXCLMarker) NOT Block ) NOT excludeRRuleRecommended

M6DN3_M6x = M6DN3_M6 OR M6DN3_DM6
M6DN3_M6_NOT_EXC = M6DN3_M6x NOT M6_EXC_L1
M6DN3_CHIP_NOT_M6_EXC_L = CHIP NOT M6_EXC_L1
M6DN3_M6_AND_DM6EXCL = M6DN3_M6_NOT_EXC AND M6DN3_DM6EXCL
M6DN3_CHIP_AND_DM6EXCL = M6DN3_CHIP_NOT_M6_EXC_L AND M6DN3_DM6EXCL
M6DN3_ERR_WIN = DENSITY M6DN3_M6_AND_DM6EXCL M6DN3_CHIP_AND_DM6EXCL < 0.20 WINDOW 10 STEP 5  
            	[ AREA(M6DN3_M6_AND_DM6EXCL)/AREA(M6DN3_CHIP_AND_DM6EXCL) ]
				
M6DN3_ERR_SIZE = SIZE ((M6DN3_ERR_WIN AND M6DN3_DM6EXCL) NOT M6_EXC_L2) BY (2.5-0.002)/2 UNDEROVER TRUNCATE (2.5-0.002)/2 
M6DN3_ERR = M6DN3_ERR_SIZE NOT M6DN3_M6x
RR:RE:S:M6.DN.3 { @ M6 density within DM6EXCL < 20% with 3x3 open region inside
    ENCLOSE RECTANGLE M6DN3_ERR 3 3
}
#ENDIF // _M6DN3_





#IFDEF _M7DN3_
M7DN3_M7CellIn = INSIDE CELL M7i CellsForRRuleRecommended  
M7DN3_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
M7DN3_M7Cell =  M7DN3_M7CellIn AND M7DN3_M7CellOut
M7DN3_M7Marker = M7i AND RRuleRecommended
M7DN3_M7 = ((M7DN3_M7Cell OR M7DN3_M7Marker) NOT Block ) NOT excludeRRuleRecommended

M7DN3_DM7CellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
M7DN3_DM7CellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
M7DN3_DM7Cell =  M7DN3_DM7CellIn AND M7DN3_DM7CellOut
M7DN3_DM7Marker = DUM7 AND RRuleRecommended
M7DN3_DM7 = ((M7DN3_DM7Cell OR M7DN3_DM7Marker) NOT Block ) NOT excludeRRuleRecommended

M7DN3_DM7EXCLCellIn = INSIDE CELL DM7EXCL CellsForRRuleRecommended  
M7DN3_DM7EXCLCellOut = NOT INSIDE CELL DM7EXCL ExclCellsForRRuleRecommended 
M7DN3_DM7EXCLCell =  M7DN3_DM7EXCLCellIn AND M7DN3_DM7EXCLCellOut
M7DN3_DM7EXCLMarker = DM7EXCL AND RRuleRecommended
M7DN3_DM7EXCL = ((M7DN3_DM7EXCLCell OR M7DN3_DM7EXCLMarker) NOT Block ) NOT excludeRRuleRecommended

M7DN3_M7x = M7DN3_M7 OR M7DN3_DM7
M7DN3_M7_NOT_EXC = M7DN3_M7x NOT M7_EXC_L1
M7DN3_CHIP_NOT_M7_EXC_L = CHIP NOT M7_EXC_L1
M7DN3_M7_AND_DM7EXCL = M7DN3_M7_NOT_EXC AND M7DN3_DM7EXCL
M7DN3_CHIP_AND_DM7EXCL = M7DN3_CHIP_NOT_M7_EXC_L AND M7DN3_DM7EXCL
M7DN3_ERR_WIN = DENSITY M7DN3_M7_AND_DM7EXCL M7DN3_CHIP_AND_DM7EXCL < 0.20 WINDOW 10 STEP 5  
            	[ AREA(M7DN3_M7_AND_DM7EXCL)/AREA(M7DN3_CHIP_AND_DM7EXCL) ]
				
M7DN3_ERR_SIZE = SIZE ((M7DN3_ERR_WIN AND M7DN3_DM7EXCL) NOT M7_EXC_L2) BY (2.5-0.002)/2 UNDEROVER TRUNCATE (2.5-0.002)/2 
M7DN3_ERR = M7DN3_ERR_SIZE NOT M7DN3_M7x
RR:RE:S:M7.DN.3 { @ M7 density within DM7EXCL < 20% with 3x3 open region inside
    ENCLOSE RECTANGLE M7DN3_ERR 3 3
}
#ENDIF // _M7DN3_









#IFDEF _VIAxR8_
VIA_EXD_STACK = COPY SEALRINGi
SINGLE_VIA1 = VIA1 NOT (VIA1 INTERACT ( (M1i AND M2i) INTERACT VIA1>1 )) 
SINGLE_VIA2 = VIA2 NOT (VIA2 INTERACT ( (M2i AND M3i) INTERACT VIA2>1 )) 
SINGLE_VIA3 = VIA3 NOT (VIA3 INTERACT ( (M3i AND M4i) INTERACT VIA3>1 )) 
SINGLE_VIA4 = VIA4 NOT (VIA4 INTERACT ( (M4i AND M5i) INTERACT VIA4>1 )) 
SINGLE_VIA5 = VIA5 NOT (VIA5 INTERACT ( (M5i AND M6i) INTERACT VIA5>1 )) 
VIAxR8_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleRecommended  
VIAxR8_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleRecommended 
VIAxR8_VIA1Cell =  VIAxR8_VIA1CellIn AND VIAxR8_VIA1CellOut
VIAxR8_VIA1Marker = VIA1i AND RRuleRecommended
VIAxR8_VIA1 = ((( VIAxR8_VIA1Cell OR VIAxR8_VIA1Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

SINGLE_VIAxR8_VIA1 = VIAxR8_VIA1 AND SINGLE_VIA1
STACK_V2V5 = ((SINGLE_VIA5 AND SINGLE_VIA4) AND SINGLE_VIA3) AND SINGLE_VIA2

// VIA1.R.8.R is checked by RR:RE:S:VIAx.R.8:V1V5
// VIA2.R.8.R is checked by RR:RE:S:VIAx.R.8:V1V5
// VIA3.R.8.R is checked by RR:RE:S:VIAx.R.8:V1V5
// VIA4.R.8.R is checked by RR:RE:S:VIAx.R.8:V1V5
// VIA5.R.8.R is checked by RR:RE:S:VIAx.R.8:V1V5
RR:RE:S:VIAx.R.8:V1V5 { @ Max. consecutive stacked stack Viax <= 4 when only one via for each VIA layer
 (SINGLE_VIAxR8_VIA1 AND STACK_V2V5) NOT VIA_EXD_STACK
}


SINGLE_VIA6 = VIA6 NOT (VIA6 INTERACT ( (M6i AND M7i) INTERACT VIA6>1 )) 
VIAxR8_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleRecommended  
VIAxR8_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleRecommended 
VIAxR8_VIA6Cell =  VIAxR8_VIA6CellIn AND VIAxR8_VIA6CellOut
VIAxR8_VIA6Marker = VIA6i AND RRuleRecommended
VIAxR8_VIA6 = ((( VIAxR8_VIA6Cell OR VIAxR8_VIA6Marker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleRecommended

SINGLE_VIAxR8_VIA6 = VIAxR8_VIA6 AND SINGLE_VIA6
// VIA6.R.8.R is checked by RR:RE:S:VIAx.R.8:V2V6
RR:RE:S:VIAx.R.8:V2V6 { @ Max. 4 stacked Vias are allowed when only one via for each VIA layer.
  (SINGLE_VIAxR8_VIA6 AND STACK_V2V5) NOT VIA_EXD_STACK
} 

#ENDIF // _VIAxR8_

#ENDIF // Systematic
#IFDEF Systematic
#IFDEF _M8W3_
M8W3_M8CellIn = INSIDE CELL M8i CellsForRRuleRecommended  
M8W3_M8CellOut = NOT INSIDE CELL M8i ExclCellsForRRuleRecommended 
M8W3_M8Cell =  M8W3_M8CellIn AND M8W3_M8CellOut
M8W3_M8Marker = M8i AND RRuleRecommended
M8W3_M8 = ((M8W3_M8Cell OR M8W3_M8Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M8W3 = M7 OR DUM7
M8W3_EXT = CHIP NOT ( SIZE RR:RE:M8W3 BY 5/2 OVERUNDER )
M8W3_BIG = SIZE( SIZE M8W3_EXT BY 5/2 UNDEROVER ) BY 1.0
M8W3_CHECK = M8W3_M8 INSIDE EDGE M8W3_BIG
// Mn.W.3.R is checked by RR:RE:S:M8.W.3
RR:RE:S:M8.W.3 { @ Recommended M8 width on (M7 OR DM7 with space>= 5x5 sizing 1) >= 0.44
    INT M8W3_CHECK < 0.44 ABUT < 90 REGION 
}
#ENDIF // _M8W3_
#ENDIF // Systematic



#IFDEF Systematic
#IFDEF _M9W3_
M9W3_M9CellIn = INSIDE CELL M9i CellsForRRuleRecommended  
M9W3_M9CellOut = NOT INSIDE CELL M9i ExclCellsForRRuleRecommended 
M9W3_M9Cell =  M9W3_M9CellIn AND M9W3_M9CellOut
M9W3_M9Marker = M9i AND RRuleRecommended
M9W3_M9 = ((M9W3_M9Cell OR M9W3_M9Marker) NOT Block ) NOT excludeRRuleRecommended

RR:RE:M9W3 = M8 OR DUM8
M9W3_EXT = CHIP NOT ( SIZE RR:RE:M9W3 BY 5/2 OVERUNDER )
M9W3_BIG = SIZE( SIZE M9W3_EXT BY 5/2 UNDEROVER ) BY 1.0
M9W3_CHECK = M9W3_M9 INSIDE EDGE M9W3_BIG
RR:RE:S:M9.W.3 { @ Recommended M9 width on (M8 OR DM8 with space>= 5x5 sizing 1) >= 0.44
    INT M9W3_CHECK < 0.44 ABUT < 90 REGION 
}
#ENDIF // _M9W3_
#ENDIF // Systematic


CHIPU1 = SIZE CHIP BY 12.5
CHIPU2 = SIZE CHIP BY 25

M1DN4_M1_orgCellIn = INSIDE CELL M1i CellsForRRuleRecommended  
M1DN4_M1_orgCellOut = NOT INSIDE CELL M1i ExclCellsForRRuleRecommended 
M1DN4_M1_orgCell =  M1DN4_M1_orgCellIn AND M1DN4_M1_orgCellOut
M1DN4_M1_orgMarker = M1i AND RRuleRecommended
M1DN4_M1_org = ((M1DN4_M1_orgCell OR M1DN4_M1_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M1DN4_M1_dumCellIn = INSIDE CELL DUM1 CellsForRRuleRecommended  
M1DN4_M1_dumCellOut = NOT INSIDE CELL DUM1 ExclCellsForRRuleRecommended 
M1DN4_M1_dumCell =  M1DN4_M1_dumCellIn AND M1DN4_M1_dumCellOut
M1DN4_M1_dumMarker = DUM1 AND RRuleRecommended
M1DN4_M1_dum = ((M1DN4_M1_dumCell OR M1DN4_M1_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M1DN4_M1 =  M1DN4_M1_org OR  M1DN4_M1_dum
ERR_70_50_M1_D0 = DENSITY M1DN4_M1 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M1.density 
	            [ AREA(M1DN4_M1)/AREA(CHIP) ]
ERR_70_50_M1_D = RECTANGLE ERR_70_50_M1_D0 == 50
ERR_70_50_M1_1 = ERR_70_50_M1_D0 NOT ERR_70_50_M1_D
ERR_70_50_M1_D1 = DENSITY M1DN4_M1 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M1DN4_M1)/AREA(CHIP) ] 
ERR_70_50_M1_D2 = DENSITY M1DN4_M1 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M1DN4_M1)/AREA(CHIP) ] 
ERR_70_50_M1_2 = ERR_70_50_M1_D INTERACT ((ERR_70_50_M1_D AND ERR_70_50_M1_D1) AND ERR_70_50_M1_D2) 
ERR_70_50_M1 = ERR_70_50_M1_1 OR ERR_70_50_M1_2  

M2DN4_M2_orgCellIn = INSIDE CELL M2i CellsForRRuleRecommended  
M2DN4_M2_orgCellOut = NOT INSIDE CELL M2i ExclCellsForRRuleRecommended 
M2DN4_M2_orgCell =  M2DN4_M2_orgCellIn AND M2DN4_M2_orgCellOut
M2DN4_M2_orgMarker = M2i AND RRuleRecommended
M2DN4_M2_org = ((M2DN4_M2_orgCell OR M2DN4_M2_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M2DN4_M2_dumCellIn = INSIDE CELL DUM2 CellsForRRuleRecommended  
M2DN4_M2_dumCellOut = NOT INSIDE CELL DUM2 ExclCellsForRRuleRecommended 
M2DN4_M2_dumCell =  M2DN4_M2_dumCellIn AND M2DN4_M2_dumCellOut
M2DN4_M2_dumMarker = DUM2 AND RRuleRecommended
M2DN4_M2_dum = ((M2DN4_M2_dumCell OR M2DN4_M2_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M2DN4_M2 =  M2DN4_M2_org OR  M2DN4_M2_dum
ERR_70_50_M2_D0 = DENSITY M2DN4_M2 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M2.density 
	            [ AREA(M2DN4_M2)/AREA(CHIP) ]
ERR_70_50_M2_D = RECTANGLE ERR_70_50_M2_D0 == 50
ERR_70_50_M2_1 = ERR_70_50_M2_D0 NOT ERR_70_50_M2_D
ERR_70_50_M2_D1 = DENSITY M2DN4_M2 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M2DN4_M2)/AREA(CHIP) ] 
ERR_70_50_M2_D2 = DENSITY M2DN4_M2 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M2DN4_M2)/AREA(CHIP) ] 
ERR_70_50_M2_2 = ERR_70_50_M2_D INTERACT ((ERR_70_50_M2_D AND ERR_70_50_M2_D1) AND ERR_70_50_M2_D2) 
ERR_70_50_M2 = ERR_70_50_M2_1 OR ERR_70_50_M2_2  

M3DN4_M3_orgCellIn = INSIDE CELL M3i CellsForRRuleRecommended  
M3DN4_M3_orgCellOut = NOT INSIDE CELL M3i ExclCellsForRRuleRecommended 
M3DN4_M3_orgCell =  M3DN4_M3_orgCellIn AND M3DN4_M3_orgCellOut
M3DN4_M3_orgMarker = M3i AND RRuleRecommended
M3DN4_M3_org = ((M3DN4_M3_orgCell OR M3DN4_M3_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M3DN4_M3_dumCellIn = INSIDE CELL DUM3 CellsForRRuleRecommended  
M3DN4_M3_dumCellOut = NOT INSIDE CELL DUM3 ExclCellsForRRuleRecommended 
M3DN4_M3_dumCell =  M3DN4_M3_dumCellIn AND M3DN4_M3_dumCellOut
M3DN4_M3_dumMarker = DUM3 AND RRuleRecommended
M3DN4_M3_dum = ((M3DN4_M3_dumCell OR M3DN4_M3_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M3DN4_M3 =  M3DN4_M3_org OR  M3DN4_M3_dum
ERR_70_50_M3_D0 = DENSITY M3DN4_M3 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M3.density 
	            [ AREA(M3DN4_M3)/AREA(CHIP) ]
ERR_70_50_M3_D = RECTANGLE ERR_70_50_M3_D0 == 50
ERR_70_50_M3_1 = ERR_70_50_M3_D0 NOT ERR_70_50_M3_D
ERR_70_50_M3_D1 = DENSITY M3DN4_M3 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M3DN4_M3)/AREA(CHIP) ] 
ERR_70_50_M3_D2 = DENSITY M3DN4_M3 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M3DN4_M3)/AREA(CHIP) ] 
ERR_70_50_M3_2 = ERR_70_50_M3_D INTERACT ((ERR_70_50_M3_D AND ERR_70_50_M3_D1) AND ERR_70_50_M3_D2) 
ERR_70_50_M3 = ERR_70_50_M3_1 OR ERR_70_50_M3_2  

M4DN4_M4_orgCellIn = INSIDE CELL M4i CellsForRRuleRecommended  
M4DN4_M4_orgCellOut = NOT INSIDE CELL M4i ExclCellsForRRuleRecommended 
M4DN4_M4_orgCell =  M4DN4_M4_orgCellIn AND M4DN4_M4_orgCellOut
M4DN4_M4_orgMarker = M4i AND RRuleRecommended
M4DN4_M4_org = ((M4DN4_M4_orgCell OR M4DN4_M4_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M4DN4_M4_dumCellIn = INSIDE CELL DUM4 CellsForRRuleRecommended  
M4DN4_M4_dumCellOut = NOT INSIDE CELL DUM4 ExclCellsForRRuleRecommended 
M4DN4_M4_dumCell =  M4DN4_M4_dumCellIn AND M4DN4_M4_dumCellOut
M4DN4_M4_dumMarker = DUM4 AND RRuleRecommended
M4DN4_M4_dum = ((M4DN4_M4_dumCell OR M4DN4_M4_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M4DN4_M4 =  M4DN4_M4_org OR  M4DN4_M4_dum
ERR_70_50_M4_D0 = DENSITY M4DN4_M4 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M4.density 
	            [ AREA(M4DN4_M4)/AREA(CHIP) ]
ERR_70_50_M4_D = RECTANGLE ERR_70_50_M4_D0 == 50
ERR_70_50_M4_1 = ERR_70_50_M4_D0 NOT ERR_70_50_M4_D
ERR_70_50_M4_D1 = DENSITY M4DN4_M4 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M4DN4_M4)/AREA(CHIP) ] 
ERR_70_50_M4_D2 = DENSITY M4DN4_M4 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M4DN4_M4)/AREA(CHIP) ] 
ERR_70_50_M4_2 = ERR_70_50_M4_D INTERACT ((ERR_70_50_M4_D AND ERR_70_50_M4_D1) AND ERR_70_50_M4_D2) 
ERR_70_50_M4 = ERR_70_50_M4_1 OR ERR_70_50_M4_2  

M5DN4_M5_orgCellIn = INSIDE CELL M5i CellsForRRuleRecommended  
M5DN4_M5_orgCellOut = NOT INSIDE CELL M5i ExclCellsForRRuleRecommended 
M5DN4_M5_orgCell =  M5DN4_M5_orgCellIn AND M5DN4_M5_orgCellOut
M5DN4_M5_orgMarker = M5i AND RRuleRecommended
M5DN4_M5_org = ((M5DN4_M5_orgCell OR M5DN4_M5_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M5DN4_M5_dumCellIn = INSIDE CELL DUM5 CellsForRRuleRecommended  
M5DN4_M5_dumCellOut = NOT INSIDE CELL DUM5 ExclCellsForRRuleRecommended 
M5DN4_M5_dumCell =  M5DN4_M5_dumCellIn AND M5DN4_M5_dumCellOut
M5DN4_M5_dumMarker = DUM5 AND RRuleRecommended
M5DN4_M5_dum = ((M5DN4_M5_dumCell OR M5DN4_M5_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M5DN4_M5 =  M5DN4_M5_org OR  M5DN4_M5_dum
ERR_70_50_M5_D0 = DENSITY M5DN4_M5 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M5.density 
	            [ AREA(M5DN4_M5)/AREA(CHIP) ]
ERR_70_50_M5_D = RECTANGLE ERR_70_50_M5_D0 == 50
ERR_70_50_M5_1 = ERR_70_50_M5_D0 NOT ERR_70_50_M5_D
ERR_70_50_M5_D1 = DENSITY M5DN4_M5 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M5DN4_M5)/AREA(CHIP) ] 
ERR_70_50_M5_D2 = DENSITY M5DN4_M5 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M5DN4_M5)/AREA(CHIP) ] 
ERR_70_50_M5_2 = ERR_70_50_M5_D INTERACT ((ERR_70_50_M5_D AND ERR_70_50_M5_D1) AND ERR_70_50_M5_D2) 
ERR_70_50_M5 = ERR_70_50_M5_1 OR ERR_70_50_M5_2  

M6DN4_M6_orgCellIn = INSIDE CELL M6i CellsForRRuleRecommended  
M6DN4_M6_orgCellOut = NOT INSIDE CELL M6i ExclCellsForRRuleRecommended 
M6DN4_M6_orgCell =  M6DN4_M6_orgCellIn AND M6DN4_M6_orgCellOut
M6DN4_M6_orgMarker = M6i AND RRuleRecommended
M6DN4_M6_org = ((M6DN4_M6_orgCell OR M6DN4_M6_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M6DN4_M6_dumCellIn = INSIDE CELL DUM6 CellsForRRuleRecommended  
M6DN4_M6_dumCellOut = NOT INSIDE CELL DUM6 ExclCellsForRRuleRecommended 
M6DN4_M6_dumCell =  M6DN4_M6_dumCellIn AND M6DN4_M6_dumCellOut
M6DN4_M6_dumMarker = DUM6 AND RRuleRecommended
M6DN4_M6_dum = ((M6DN4_M6_dumCell OR M6DN4_M6_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M6DN4_M6 =  M6DN4_M6_org OR  M6DN4_M6_dum
ERR_70_50_M6_D0 = DENSITY M6DN4_M6 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M6.density 
	            [ AREA(M6DN4_M6)/AREA(CHIP) ]
ERR_70_50_M6_D = RECTANGLE ERR_70_50_M6_D0 == 50
ERR_70_50_M6_1 = ERR_70_50_M6_D0 NOT ERR_70_50_M6_D
ERR_70_50_M6_D1 = DENSITY M6DN4_M6 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M6DN4_M6)/AREA(CHIP) ] 
ERR_70_50_M6_D2 = DENSITY M6DN4_M6 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M6DN4_M6)/AREA(CHIP) ] 
ERR_70_50_M6_2 = ERR_70_50_M6_D INTERACT ((ERR_70_50_M6_D AND ERR_70_50_M6_D1) AND ERR_70_50_M6_D2) 
ERR_70_50_M6 = ERR_70_50_M6_1 OR ERR_70_50_M6_2  

M7DN4_M7_orgCellIn = INSIDE CELL M7i CellsForRRuleRecommended  
M7DN4_M7_orgCellOut = NOT INSIDE CELL M7i ExclCellsForRRuleRecommended 
M7DN4_M7_orgCell =  M7DN4_M7_orgCellIn AND M7DN4_M7_orgCellOut
M7DN4_M7_orgMarker = M7i AND RRuleRecommended
M7DN4_M7_org = ((M7DN4_M7_orgCell OR M7DN4_M7_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M7DN4_M7_dumCellIn = INSIDE CELL DUM7 CellsForRRuleRecommended  
M7DN4_M7_dumCellOut = NOT INSIDE CELL DUM7 ExclCellsForRRuleRecommended 
M7DN4_M7_dumCell =  M7DN4_M7_dumCellIn AND M7DN4_M7_dumCellOut
M7DN4_M7_dumMarker = DUM7 AND RRuleRecommended
M7DN4_M7_dum = ((M7DN4_M7_dumCell OR M7DN4_M7_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M7DN4_M7 =  M7DN4_M7_org OR  M7DN4_M7_dum
ERR_70_50_M7_D0 = DENSITY M7DN4_M7 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M7.density 
	            [ AREA(M7DN4_M7)/AREA(CHIP) ]
ERR_70_50_M7_D = RECTANGLE ERR_70_50_M7_D0 == 50
ERR_70_50_M7_1 = ERR_70_50_M7_D0 NOT ERR_70_50_M7_D
ERR_70_50_M7_D1 = DENSITY M7DN4_M7 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M7DN4_M7)/AREA(CHIP) ] 
ERR_70_50_M7_D2 = DENSITY M7DN4_M7 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M7DN4_M7)/AREA(CHIP) ] 
ERR_70_50_M7_2 = ERR_70_50_M7_D INTERACT ((ERR_70_50_M7_D AND ERR_70_50_M7_D1) AND ERR_70_50_M7_D2) 
ERR_70_50_M7 = ERR_70_50_M7_1 OR ERR_70_50_M7_2  

M8DN4_M8_orgCellIn = INSIDE CELL M8i CellsForRRuleRecommended  
M8DN4_M8_orgCellOut = NOT INSIDE CELL M8i ExclCellsForRRuleRecommended 
M8DN4_M8_orgCell =  M8DN4_M8_orgCellIn AND M8DN4_M8_orgCellOut
M8DN4_M8_orgMarker = M8i AND RRuleRecommended
M8DN4_M8_org = ((M8DN4_M8_orgCell OR M8DN4_M8_orgMarker) NOT Block ) NOT excludeRRuleRecommended

M8DN4_M8_dumCellIn = INSIDE CELL DUM8 CellsForRRuleRecommended  
M8DN4_M8_dumCellOut = NOT INSIDE CELL DUM8 ExclCellsForRRuleRecommended 
M8DN4_M8_dumCell =  M8DN4_M8_dumCellIn AND M8DN4_M8_dumCellOut
M8DN4_M8_dumMarker = DUM8 AND RRuleRecommended
M8DN4_M8_dum = ((M8DN4_M8_dumCell OR M8DN4_M8_dumMarker) NOT Block ) NOT excludeRRuleRecommended

M8DN4_M8 =  M8DN4_M8_org OR  M8DN4_M8_dum
ERR_70_50_M8_D0 = DENSITY M8DN4_M8 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP PRINT ERR_70_50_M8.density 
	            [ AREA(M8DN4_M8)/AREA(CHIP) ]
ERR_70_50_M8_D = RECTANGLE ERR_70_50_M8_D0 == 50
ERR_70_50_M8_1 = ERR_70_50_M8_D0 NOT ERR_70_50_M8_D
ERR_70_50_M8_D1 = DENSITY M8DN4_M8 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU1 
	             [ AREA(M8DN4_M8)/AREA(CHIP) ] 
ERR_70_50_M8_D2 = DENSITY M8DN4_M8 CHIP > 0.7 WINDOW 50 STEP 25 BACKUP INSIDE OF LAYER CHIPU2 
	             [ AREA(M8DN4_M8)/AREA(CHIP) ] 
ERR_70_50_M8_2 = ERR_70_50_M8_D INTERACT ((ERR_70_50_M8_D AND ERR_70_50_M8_D1) AND ERR_70_50_M8_D2) 
ERR_70_50_M8 = ERR_70_50_M8_1 OR ERR_70_50_M8_2  


//3 consecutive		    
#IFDEF Systematic
#IFDEF _M1DN4_
RR:RE:S:M1.DN.4 { @ 3 consecutive metal layer(M1,M2,M3) over any 50umx50um window step 25um must <= 70%

    (ERR_70_50_M1 AND ERR_70_50_M2) AND ERR_70_50_M3
}
#ENDIF // _M1DN4_

#IFDEF _M2DN4_
RR:RE:S:M2.DN.4 { @ 3 consecutive metal layer(M2,M3,M4) over any 50umx50um window step 25um must <= 70%

    (ERR_70_50_M2 AND ERR_70_50_M3) AND ERR_70_50_M4
}
#ENDIF // _M2DN4_

#IFDEF _M3DN4_
RR:RE:S:M3.DN.4 { @ 3 consecutive metal layer(M3,M4,M5) over any 50umx50um window step 25um must <= 70%

    (ERR_70_50_M3 AND ERR_70_50_M4) AND ERR_70_50_M5
}
#ENDIF // _M3DN4_

#IFDEF _M4DN4_
RR:RE:S:M4.DN.4 { @ 3 consecutive metal layer(M4,M5,M6) over any 50umx50um window step 25um must <= 70%

    (ERR_70_50_M4 AND ERR_70_50_M5) AND ERR_70_50_M6
}
#ENDIF // _M4DN4_

#IFDEF _M5DN4_
RR:RE:S:M5.DN.4 { @ 3 consecutive metal layer(M5,M6,M7) over any 50umx50um window step 25um must <= 70%

    (ERR_70_50_M5 AND ERR_70_50_M6) AND ERR_70_50_M7
}
#ENDIF // _M5DN4_

#ENDIF // Systematic

//CB.W.2 is checked by RR:RE:D:CB.W.2
#IFDEF Defect
#IFDEF FULL_CHIP
RR:RE:D:CB.W.2 { @ Width of CB/CBD bar in sealring REGION == 2 um
	SR_CB = CB INTERACT SEALRINGi
	INT SR_CB < 2 - GRID ABUT < 90 OPPOSITE PARALLEL ONLY REGION
	WITH WIDTH SR_CB > 2 + GRID
	SR_CBD = CBD INTERACT SEALRINGi
	INT SR_CBD < 2 - GRID ABUT < 90 OPPOSITE PARALLEL ONLY REGION
	WITH WIDTH SR_CBD > 2 + GRID
}
#ENDIF // FULL_CHIP
#ENDIF // Defect
#ENDIF // Recommended_DFM


#IFDEF Analog


#IFDEF _POEX1m_
POEX1m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POEX1m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POEX1m_POCell =  POEX1m_POCellIn AND POEX1m_POCellOut
POEX1m_POMarker = POi AND RRuleAnalog
POEX1m_PO = ((( POEX1m_POCell OR POEX1m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RR:AN:PO.EX.1m { @ Recommended PO extension on OD >= 0.18
    ENC OD POEX1m_PO < 0.18 ABUT < 90 REGION OPPOSITE
}
#ENDIF // _POEX1m_

LongGateW = LENGTH GATE_W >= PO_S_5_W

#IFDEF _POS6m_
POS6m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS6m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS6m_POCell =  POS6m_POCellIn AND POS6m_POCellOut
POS6m_POMarker = POi AND RRuleAnalog
POS6m_PO = ((( POS6m_POCell OR POS6m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS6m_GATE = POS6m_PO AND ODi
LongGateL = GATE_L COIN INSIDE EDGE ( POS6m_GATE WITH EDGE LongGateW )
LongGateLExp = EXPAND EDGE LongGateL INSIDE BY Grid EXTEND BY 0.14
LongGateLExe = ODi COIN INSIDE EDGE LongGateLExp
RR:AN:PO.S.6m { @ L-PO space to OD >= 0.1um
    EXT LongGateLExe POS6m_PO < 0.1 ABUT < 90 OPPOSITE REGION
}
#ENDIF // _POS6m_

#IFDEF _POS5m_
POS5m_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
POS5m_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
POS5m_POCell =  POS5m_POCellIn AND POS5m_POCellOut
POS5m_POMarker = POi AND RRuleAnalog
POS5m_PO = ((( POS5m_POCell OR POS5m_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

POS5m_LongGateW = LongGateW COIN INSIDE EDGE POS5m_PO
LongGateWExp = EXPAND EDGE POS5m_LongGateW INSIDE BY Grid EXTEND BY 0.14
LongGateWExe = POS5m_PO COIN INSIDE EDGE LongGateWExp
RR:AN:PO.S.5m { @ L-OD space to PO >= 0.1um
    EXT LongGateWExe ODi < 0.1 ABUT < 90 OPPOSITE REGION
}
#ENDIF // _POS5m_

// Rule changed to PO.EX.2mgU, uncheckable rule.


#IFDEF _RES5m_
RES5_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
RES5_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
RES5_POCell =  RES5_POCellIn AND RES5_POCellOut
RES5_POMarker = POi AND RRuleAnalog
RES5_PO = ((( RES5_POCell OR RES5_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

RES5_ODCellIn = INSIDE CELL ODi CellsForRRuleAnalog  
RES5_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleAnalog 
RES5_ODCell =  RES5_ODCellIn AND RES5_ODCellOut
RES5_ODMarker = ODi AND RRuleAnalog
RES5_OD = ((( RES5_ODCell OR RES5_ODMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

// RES.5m.R is checked by RR:AN:RES.5m:OD
RR:AN:RES.5m:OD { @ CO space to unsilicided OD resistor should be equal to 0.22um
  ODR_GATE = (RES5_OD INTERACT GATE) AND ODRES  
  ODR_TRM  = SIZE ODR_GATE BY RPO_S_3 INSIDE OF OD STEP OD_S_1*0.7
  ODR_TRM NOT INTERACT CO
  ODR_NOT_GATE = (RES5_OD NOT INTERACT GATE) AND ODRES 
  ODR_TER = RPOs COIN INSIDE EDGE ODR_NOT_GATE 
  ODR_TER_EX = EXPAND EDGE ODR_TER OUTSIDE BY RPO_S_3
  ODR_TER_EX NOT INTERACT CO
}
// RES.5m.R is checked by RR:AN:RES.5m:PO
RR:AN:RES.5m:PO { @ CO space to unsilicided PO resistor should be equal to 0.22um
  POR_GATE = (RES5_PO INTERACT GATE) AND PORESg 
  POR_TRM = SIZE POR_GATE BY RPO_S_3 INSIDE OF POLY STEP PO_S_1*0.7
  POR_TRM NOT INTERACT CO
  POR_NOT_GATE = (RES5_PO NOT INTERACT GATE) AND PORESg 
  POR_TER = RPO COIN INSIDE EDGE POR_NOT_GATE 
  POR_TER_EX = EXPAND EDGE POR_TER OUTSIDE BY RPO_S_3
  POR_TER_EX NOT INTERACT CO
}
#ENDIF
BJTR_PP_EMOD = PACT AND BJTDMY
BJTR_NP_EMOD = NACT AND BJTDMY
BJTR_EMOD = BJTR_PP_EMOD OR BJTR_NP_EMOD
#IFDEF _BJTR2R_
// BJT.R.2.R is checked by RR:AN:BJT.R.2
RR:AN:BJT.R.2 { @ OD( Emitter size ) is 2x2, 5x5, 10x10 
    X = NOT RECTANGLE BJTR_EMOD == 2.0 BY == 2.0
    Y = NOT RECTANGLE X == 5.0 BY == 5.0
    NOT RECTANGLE Y == 10.0 BY == 10.0
}
#ENDIF // _BJTR2R_

#IFDEF _BJTR3R_
// BJT.R.3.R is checked by RR:AN:BJT.R.3
RR:AN:BJT.R.3 { @ NW enclosure of P+OD ( Emitter OD ) for PNP == 3.0um
    X = SIZE BJTR_PP_EMOD BY 3.0
    Y = NWEL INTERACT BJTR_PP_EMOD
    X XOR Y
}
#ENDIF // _BJTR3R_

BJT_NW = NWEL AND BJTDMY
BJT_DNW = DNW AND BJTDMY
BJT_RW = BJT_DNW NOT BJT_NW 

#IFDEF _BJTR4R_
// BJT.R.4.R is checked by RR:AN:BJT.R.4
RR:AN:BJT.R.4 { @ NW space to N+OD ( Emitter OD ) for NPN == 3.0um
    X = SIZE BJTR_NP_EMOD BY 3.0
    Y = BJT_RW INTERACT BJTR_NP_EMOD
    X XOR Y
}
#ENDIF // _BJTR4R_

#IFDEF _BJTR5R_
// BJT.R.5.R is checked by RR:AN:BJT.R.5
RR:AN:BJT.R.5 { @ NW enclosure of DNW for NPN >= 1.5um
    ENC BJT_DNW BJT_NW < 1.5 ABUT < 90 SINGULAR REGION
}
#ENDIF // _BJTR5R_

#IFDEF _BJTR6R_
// BJT.R.6.R is checked by RR:AN:BJT.R.6
RR:AN:BJT.R.6 { @ DNW enclosure of PW for NPN = 5.5um
   X = SIZE BJT_RW BY 5.5
   X XOR BJT_DNW    
}
#ENDIF // _BJTR6R_
#IFDEF _BJTR7R_
// BJT.R.7.R is checked by RR:AN:BJT.R.7
RR:AN:BJT.R.7 { @ BJTDMY overlap of NT_N, PO, VTH_N, VTH_P, VTL_N, VTL_P, RH, VAR and SRM is not recommended
    BJTDMY AND NTN
    BJTDMY AND POLY
    BJTDMY AND VTHN
    BJTDMY AND VTHP
    BJTDMY AND VTLN
    BJTDMY AND VTLP
    BJTDMY AND RH
    BJTDMY AND VAR
    BJTDMY AND SRM
}
#ENDIF // _BJTR7R

#IFDEF _ANR17mg_
ANR17mg_POCellIn = INSIDE CELL POi CellsForRRuleAnalog  
ANR17mg_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
ANR17mg_POCell =  ANR17mg_POCellIn AND ANR17mg_POCellOut
ANR17mg_POMarker = POi AND RRuleAnalog
ANR17mg_PO = ((( ANR17mg_POCell OR ANR17mg_POMarker ) NOT SRAM_EXCLUDE ) OUTSIDE Block ) NOT excludeRRuleAnalog

ANR17mg_PORES = ANR17mg_PO AND PORES
// AN.R.17mg is checked by RR:AN:AN.R.17mg
RR:AN:AN.R.17mg { @ PO resistor on NW for better noise immunity; P+ PO resistor is recommended
    ANR17mg_PORES NOT NWEL
    ANR17mg_PORES NOT INTERACT PP
}
#ENDIF // _ANR17mg_
#IFDEF _ANR19mg_
ANR19mg_VARCellIn = INSIDE CELL VARi CellsForRRuleAnalog  
ANR19mg_VARCellOut = NOT INSIDE CELL VARi ExclCellsForRRuleAnalog 
ANR19mg_VARCell =  ANR19mg_VARCellIn AND ANR19mg_VARCellOut
ANR19mg_VARMarker = VARi AND RRuleAnalog
ANR19mg_VAR = ((ANR19mg_VARCell OR ANR19mg_VARMarker) NOT Block ) NOT excludeRRuleAnalog

ANR19mg_VAROD = ANR19mg_VAR AND OD
// AN.R.19mg is checked by RR:AN:AN.R.19mg
RR:AN:AN.R.19mg { @ Use OD2 MOS varactor is recommended.
   ANR19mg_VAROD NOT OD2
}
#ENDIF // _ANR19mg_

ANRmg_POiCellIn = INSIDE CELL POi CellsForRRuleAnalog  
ANRmg_POiCellOut = NOT INSIDE CELL POi ExclCellsForRRuleAnalog 
ANRmg_POiCell =  ANRmg_POiCellIn AND ANRmg_POiCellOut
ANRmg_POiMarker = POi AND RRuleAnalog
ANRmg_POi = ((ANRmg_POiCell OR ANRmg_POiMarker) NOT Block ) NOT excludeRRuleAnalog

ANRmg_GATE = ANRmg_POi AND OD 
ANRmg_G_M1 = ANRmg_GATE INSIDE M1i
ANRmg_B_M1 = ANRmg_GATE CUT M1i
ANRmg_O_M1 = ANRmg_GATE OUTSIDE M1i
ANRmg_G_M2 = ANRmg_GATE INSIDE M2i
ANRmg_B_M2 = ANRmg_GATE CUT M2i
ANRmg_O_M2 = ANRmg_GATE OUTSIDE M2i
ANRmg_G_M3 = ANRmg_GATE INSIDE M3i
ANRmg_B_M3 = ANRmg_GATE CUT M3i
ANRmg_O_M3 = ANRmg_GATE OUTSIDE M3i
ANRmg_G_M4 = ANRmg_GATE INSIDE M4i
ANRmg_B_M4 = ANRmg_GATE CUT M4i
ANRmg_O_M4 = ANRmg_GATE OUTSIDE M4i
ANRmg_G_M5 = ANRmg_GATE INSIDE M5i
ANRmg_B_M5 = ANRmg_GATE CUT M5i
ANRmg_O_M5 = ANRmg_GATE OUTSIDE M5i
ANRmg_G_M6 = ANRmg_GATE INSIDE M6i
ANRmg_B_M6 = ANRmg_GATE CUT M6i
ANRmg_O_M6 = ANRmg_GATE OUTSIDE M6i
ANRmg_G_M7 = ANRmg_GATE INSIDE M7i
ANRmg_B_M7 = ANRmg_GATE CUT M7i
ANRmg_O_M7 = ANRmg_GATE OUTSIDE M7i
ANRmg_G_M8 = ANRmg_GATE INSIDE M8i
ANRmg_B_M8 = ANRmg_GATE CUT M8i
ANRmg_O_M8 = ANRmg_GATE OUTSIDE M8i
ANRmg_G_M9 = ANRmg_GATE INSIDE M9i
ANRmg_B_M9 = ANRmg_GATE CUT M9i
ANRmg_O_M9 = ANRmg_GATE OUTSIDE M9i

#IFDEF _ANR46mg_
// AN.R.46 is checked by RR:AN:AN.R.46:M1
RR:AN:AN.R.46:M1 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M1
  A INTERACT ANRmg_B_M1
  A INTERACT ANRmg_O_M1
}
// AN.R.46 is checked by RR:AN:AN.R.46:M2
RR:AN:AN.R.46:M2 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M2
  A INTERACT ANRmg_B_M2
  A INTERACT ANRmg_O_M2
}
// AN.R.46 is checked by RR:AN:AN.R.46:M3
RR:AN:AN.R.46:M3 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M3
  A INTERACT ANRmg_B_M3
  A INTERACT ANRmg_O_M3
}
// AN.R.46 is checked by RR:AN:AN.R.46:M4
RR:AN:AN.R.46:M4 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M4
  A INTERACT ANRmg_B_M4
  A INTERACT ANRmg_O_M4
}
// AN.R.46 is checked by RR:AN:AN.R.46:M5
RR:AN:AN.R.46:M5 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M5
  A INTERACT ANRmg_B_M5
  A INTERACT ANRmg_O_M5
}
// AN.R.46 is checked by RR:AN:AN.R.46:M6
RR:AN:AN.R.46:M6 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M6
  A INTERACT ANRmg_B_M6
  A INTERACT ANRmg_O_M6
}
// AN.R.46 is checked by RR:AN:AN.R.46:M7
RR:AN:AN.R.46:M7 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M7
  A INTERACT ANRmg_B_M7
  A INTERACT ANRmg_O_M7
}
// AN.R.46 is checked by RR:AN:AN.R.46:M8
RR:AN:AN.R.46:M8 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M8
  A INTERACT ANRmg_B_M8
  A INTERACT ANRmg_O_M8
}
// AN.R.46 is checked by RR:AN:AN.R.46:M9
RR:AN:AN.R.46:M9 { @ differential pair fully covered by metal layer and the other is not fully covered is not allowed
  A = MATCHING INTERACT ANRmg_G_M9
  A INTERACT ANRmg_B_M9
  A INTERACT ANRmg_O_M9
}
#ENDIF // _ANR46mg_


#IFDEF _ANR47mg_
// AN.R.47 is checked by RR:AN:AN.R.47:M1
RR:AN:AN.R.47:M1 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M1
  A INTERACT ANRmg_O_M1
  A INTERACT ANRmg_B_M1 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M2
RR:AN:AN.R.47:M2 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M2
  A INTERACT ANRmg_O_M2
  A INTERACT ANRmg_B_M2 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M3
RR:AN:AN.R.47:M3 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M3
  A INTERACT ANRmg_O_M3
  A INTERACT ANRmg_B_M3 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M4
RR:AN:AN.R.47:M4 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M4
  A INTERACT ANRmg_O_M4
  A INTERACT ANRmg_B_M4 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M5
RR:AN:AN.R.47:M5 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M5
  A INTERACT ANRmg_O_M5
  A INTERACT ANRmg_B_M5 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M6
RR:AN:AN.R.47:M6 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M6
  A INTERACT ANRmg_O_M6
  A INTERACT ANRmg_B_M6 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M7
RR:AN:AN.R.47:M7 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M7
  A INTERACT ANRmg_O_M7
  A INTERACT ANRmg_B_M7 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M8
RR:AN:AN.R.47:M8 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M8
  A INTERACT ANRmg_O_M8
  A INTERACT ANRmg_B_M8 > 1
}
// AN.R.47 is checked by RR:AN:AN.R.47:M9
RR:AN:AN.R.47:M9 { @ For the critical differential pair inside MATCHING layer, unbalance metal shielding is not allowed
  A = MATCHING INTERACT ANRmg_B_M9
  A INTERACT ANRmg_O_M9
  A INTERACT ANRmg_B_M9 > 1
}
#ENDIF // _ANR47mg_

#ENDIF // Analog


#IFDEF Guideline
#IFDEF _OPCR2_
OPCR2_PPCellIn = INSIDE CELL PPi CellsForRRuleGuideline  
OPCR2_PPCellOut = NOT INSIDE CELL PPi ExclCellsForRRuleGuideline 
OPCR2_PPCell =  OPCR2_PPCellIn AND OPCR2_PPCellOut
OPCR2_PPMarker = PPi AND RRuleGuideline
OPCR2_PP = ((( OPCR2_PPCell OR OPCR2_PPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:PP
RR:GL:S:OPC.R.2:PP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH PP < PP_W_1/2) TOUCH INSIDE EDGE OPCR2_PP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_NPCellIn = INSIDE CELL NPi CellsForRRuleGuideline  
OPCR2_NPCellOut = NOT INSIDE CELL NPi ExclCellsForRRuleGuideline 
OPCR2_NPCell =  OPCR2_NPCellIn AND OPCR2_NPCellOut
OPCR2_NPMarker = NPi AND RRuleGuideline
OPCR2_NP = ((( OPCR2_NPCell OR OPCR2_NPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:NP
RR:GL:S:OPC.R.2:NP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH NP < NP_W_1/2) TOUCH INSIDE EDGE OPCR2_NP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTHNCellIn = INSIDE CELL VTH_Ni CellsForRRuleGuideline  
OPCR2_VTHNCellOut = NOT INSIDE CELL VTH_Ni ExclCellsForRRuleGuideline 
OPCR2_VTHNCell =  OPCR2_VTHNCellIn AND OPCR2_VTHNCellOut
OPCR2_VTHNMarker = VTH_Ni AND RRuleGuideline
OPCR2_VTHN = ((( OPCR2_VTHNCell OR OPCR2_VTHNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTHN
RR:GL:S:OPC.R.2:VTHN { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH VTHNs < VTH_N_W_1/2) TOUCH INSIDE EDGE OPCR2_VTHN) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTHPCellIn = INSIDE CELL VTH_Pi CellsForRRuleGuideline  
OPCR2_VTHPCellOut = NOT INSIDE CELL VTH_Pi ExclCellsForRRuleGuideline 
OPCR2_VTHPCell =  OPCR2_VTHPCellIn AND OPCR2_VTHPCellOut
OPCR2_VTHPMarker = VTH_Pi AND RRuleGuideline
OPCR2_VTHP = ((( OPCR2_VTHPCell OR OPCR2_VTHPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTHP
RR:GL:S:OPC.R.2:VTHP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH VTHPs < VTH_P_W_1/2) TOUCH INSIDE EDGE OPCR2_VTHP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTLNCellIn = INSIDE CELL VTL_Ni CellsForRRuleGuideline  
OPCR2_VTLNCellOut = NOT INSIDE CELL VTL_Ni ExclCellsForRRuleGuideline 
OPCR2_VTLNCell =  OPCR2_VTLNCellIn AND OPCR2_VTLNCellOut
OPCR2_VTLNMarker = VTL_Ni AND RRuleGuideline
OPCR2_VTLN = ((( OPCR2_VTLNCell OR OPCR2_VTLNMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTLN
RR:GL:S:OPC.R.2:VTLN { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH VTLNs < VTL_N_W_1/2) TOUCH INSIDE EDGE OPCR2_VTLN) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_VTLPCellIn = INSIDE CELL VTL_Pi CellsForRRuleGuideline  
OPCR2_VTLPCellOut = NOT INSIDE CELL VTL_Pi ExclCellsForRRuleGuideline 
OPCR2_VTLPCell =  OPCR2_VTLPCellIn AND OPCR2_VTLPCellOut
OPCR2_VTLPMarker = VTL_Pi AND RRuleGuideline
OPCR2_VTLP = ((( OPCR2_VTLPCell OR OPCR2_VTLPMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:VTLP
RR:GL:S:OPC.R.2:VTLP { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH VTLPs < VTL_P_W_1/2) TOUCH INSIDE EDGE OPCR2_VTLP) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_ODCellIn = INSIDE CELL ODi CellsForRRuleGuideline  
OPCR2_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleGuideline 
OPCR2_ODCell =  OPCR2_ODCellIn AND OPCR2_ODCellOut
OPCR2_ODMarker = ODi AND RRuleGuideline
OPCR2_OD = ((( OPCR2_ODCell OR OPCR2_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:OD
RR:GL:S:OPC.R.2:OD { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH ODs < OD_W_1/2) TOUCH INSIDE EDGE OPCR2_OD) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_POCellIn = INSIDE CELL POi CellsForRRuleGuideline  
OPCR2_POCellOut = NOT INSIDE CELL POi ExclCellsForRRuleGuideline 
OPCR2_POCell =  OPCR2_POCellIn AND OPCR2_POCellOut
OPCR2_POMarker = POi AND RRuleGuideline
OPCR2_PO = ((( OPCR2_POCell OR OPCR2_POMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:PO
RR:GL:S:OPC.R.2:PO { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH POLYs < PO_W_1/2) TOUCH INSIDE EDGE OPCR2_PO) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_M1CellIn = INSIDE CELL M1i CellsForRRuleGuideline  
OPCR2_M1CellOut = NOT INSIDE CELL M1i ExclCellsForRRuleGuideline 
OPCR2_M1Cell =  OPCR2_M1CellIn AND OPCR2_M1CellOut
OPCR2_M1Marker = M1i AND RRuleGuideline
OPCR2_M1 = ((( OPCR2_M1Cell OR OPCR2_M1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M1 
RR:GL:S:OPC.R.2:M1 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  ((LENGTH M1s < M1_W_1/2) TOUCH INSIDE EDGE OPCR2_M1) NOT INSIDE EDGE SRAM_EXCLUDE
}
OPCR2_M2CellIn = INSIDE CELL M2i CellsForRRuleGuideline  
OPCR2_M2CellOut = NOT INSIDE CELL M2i ExclCellsForRRuleGuideline 
OPCR2_M2Cell =  OPCR2_M2CellIn AND OPCR2_M2CellOut
OPCR2_M2Marker = M2i AND RRuleGuideline
OPCR2_M2 = ((OPCR2_M2Cell OR OPCR2_M2Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M2
RR:GL:S:OPC.R.2:M2 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M2 < M2_W_1/2) TOUCH INSIDE EDGE OPCR2_M2
}
OPCR2_M3CellIn = INSIDE CELL M3i CellsForRRuleGuideline  
OPCR2_M3CellOut = NOT INSIDE CELL M3i ExclCellsForRRuleGuideline 
OPCR2_M3Cell =  OPCR2_M3CellIn AND OPCR2_M3CellOut
OPCR2_M3Marker = M3i AND RRuleGuideline
OPCR2_M3 = ((OPCR2_M3Cell OR OPCR2_M3Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M3
RR:GL:S:OPC.R.2:M3 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M3 < M3_W_1/2) TOUCH INSIDE EDGE OPCR2_M3
}
OPCR2_M4CellIn = INSIDE CELL M4i CellsForRRuleGuideline  
OPCR2_M4CellOut = NOT INSIDE CELL M4i ExclCellsForRRuleGuideline 
OPCR2_M4Cell =  OPCR2_M4CellIn AND OPCR2_M4CellOut
OPCR2_M4Marker = M4i AND RRuleGuideline
OPCR2_M4 = ((OPCR2_M4Cell OR OPCR2_M4Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M4
RR:GL:S:OPC.R.2:M4 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M4 < M4_W_1/2) TOUCH INSIDE EDGE OPCR2_M4
}
OPCR2_M5CellIn = INSIDE CELL M5i CellsForRRuleGuideline  
OPCR2_M5CellOut = NOT INSIDE CELL M5i ExclCellsForRRuleGuideline 
OPCR2_M5Cell =  OPCR2_M5CellIn AND OPCR2_M5CellOut
OPCR2_M5Marker = M5i AND RRuleGuideline
OPCR2_M5 = ((OPCR2_M5Cell OR OPCR2_M5Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M5
RR:GL:S:OPC.R.2:M5 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M5 < M5_W_1/2) TOUCH INSIDE EDGE OPCR2_M5
}
OPCR2_M6CellIn = INSIDE CELL M6i CellsForRRuleGuideline  
OPCR2_M6CellOut = NOT INSIDE CELL M6i ExclCellsForRRuleGuideline 
OPCR2_M6Cell =  OPCR2_M6CellIn AND OPCR2_M6CellOut
OPCR2_M6Marker = M6i AND RRuleGuideline
OPCR2_M6 = ((OPCR2_M6Cell OR OPCR2_M6Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M6
RR:GL:S:OPC.R.2:M6 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M6 < M6_W_1/2) TOUCH INSIDE EDGE OPCR2_M6
}
OPCR2_M7CellIn = INSIDE CELL M7i CellsForRRuleGuideline  
OPCR2_M7CellOut = NOT INSIDE CELL M7i ExclCellsForRRuleGuideline 
OPCR2_M7Cell =  OPCR2_M7CellIn AND OPCR2_M7CellOut
OPCR2_M7Marker = M7i AND RRuleGuideline
OPCR2_M7 = ((OPCR2_M7Cell OR OPCR2_M7Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M7
RR:GL:S:OPC.R.2:M7 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M7 < M7_W_1/2) TOUCH INSIDE EDGE OPCR2_M7
}
OPCR2_M8CellIn = INSIDE CELL M8i CellsForRRuleGuideline  
OPCR2_M8CellOut = NOT INSIDE CELL M8i ExclCellsForRRuleGuideline 
OPCR2_M8Cell =  OPCR2_M8CellIn AND OPCR2_M8CellOut
OPCR2_M8Marker = M8i AND RRuleGuideline
OPCR2_M8 = ((OPCR2_M8Cell OR OPCR2_M8Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M8
RR:GL:S:OPC.R.2:M8 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M8 < M8_W_1/2) TOUCH INSIDE EDGE OPCR2_M8
}
OPCR2_M9CellIn = INSIDE CELL M9i CellsForRRuleGuideline  
OPCR2_M9CellOut = NOT INSIDE CELL M9i ExclCellsForRRuleGuideline 
OPCR2_M9Cell =  OPCR2_M9CellIn AND OPCR2_M9CellOut
OPCR2_M9Marker = M9i AND RRuleGuideline
OPCR2_M9 = ((OPCR2_M9Cell OR OPCR2_M9Marker) NOT Block ) NOT excludeRRuleGuideline

// OPC.R.2g is checked by RR:GL:S:OPC.R.2:M9
RR:GL:S:OPC.R.2:M9 { @ Recommended edge length >= 1/2 minimum width for OPC friendly layout
  (LENGTH M9 < M9_W_1/2) TOUCH INSIDE EDGE OPCR2_M9
}

#ENDIF // _OPCR2_


#IFDEF _NWR1_
NWR1_NWCellIn = INSIDE CELL NWi CellsForRRuleGuideline  
NWR1_NWCellOut = NOT INSIDE CELL NWi ExclCellsForRRuleGuideline 
NWR1_NWCell =  NWR1_NWCellIn AND NWR1_NWCellOut
NWR1_NWMarker = NWi AND RRuleGuideline
NWR1_NW = ((( NWR1_NWCell OR NWR1_NWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// NW.R.1g is checked by RR:GL:SP:NW.R.1
RR:GL:SP:NW.R.1 { @ Recommended not to use floating well
 (((NWi OUTSIDE (NPODi INTERACT COi)) NOT LOGO) NOT INSIDE SRAM_EXCLUDE) INTERACT NWR1_NW
 ((PWELi OUTSIDE (PPODi INTERACT COi)) NOT INSIDE SRAM_EXCLUDE) INTERACT NWR1_NW  
}
#ENDIF // _NWR1_

#IFDEF _DNWR5_
DNWR5_DNWCellIn = INSIDE CELL DNWi CellsForRRuleGuideline  
DNWR5_DNWCellOut = NOT INSIDE CELL DNWi ExclCellsForRRuleGuideline 
DNWR5_DNWCell =  DNWR5_DNWCellIn AND DNWR5_DNWCellOut
DNWR5_DNWMarker = DNWi AND RRuleGuideline
DNWR5_DNW = ((( DNWR5_DNWCell OR DNWR5_DNWMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// DNW.R.5g is checked by RR:GL:SP:DNW.R.5
RR:GL:SP:DNW.R.5 { @ Recommended not to use floating RW
  ((RWi OUTSIDE (PPODi INTERACT COi)) NOT INSIDE SRAM_EXCLUDE) INTERACT DNWR5_DNW  
}
#ENDIF

#IFDEF _NWRODR3_NWRSTIR3_
NWRODR3_NWDMYCellIn = INSIDE CELL NWDMY CellsForRRuleGuideline  
NWRODR3_NWDMYCellOut = NOT INSIDE CELL NWDMY ExclCellsForRRuleGuideline 
NWRODR3_NWDMYCell =  NWRODR3_NWDMYCellIn AND NWRODR3_NWDMYCellOut
NWRODR3_NWDMYMarker = NWDMY AND RRuleGuideline
NWRODR3_NWDMY = ((( NWRODR3_NWDMYCell OR NWRODR3_NWDMYMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

//NWROD.R.3g is checked by RR:GL:P:NWROD.R.3__NWRSTI.R.3
//NWRSTI.R.3g is checked by RR:GL:P:NWROD.R.3__NWRSTI.R.3
RR:GL:P:NWROD.R.3__NWRSTI.R.3 { @ Recommended to use rectangle shape resistor
  NWRES_BODY = RNWEL AND (NWDMY INTERACT NWRODR3_NWDMY)     
  NOT RECTANGLE NWRES_BODY ORTHOGONAL ONLY 
}
#ENDIF

#IFDEF _COS6_
COS6_ODCellIn = INSIDE CELL ODi CellsForRRuleGuideline  
COS6_ODCellOut = NOT INSIDE CELL ODi ExclCellsForRRuleGuideline 
COS6_ODCell =  COS6_ODCellIn AND COS6_ODCellOut
COS6_ODMarker = ODi AND RRuleGuideline
COS6_OD = ((( COS6_ODCell OR COS6_ODMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// CO.S.6g is checked by RR:GL:P:CO.S.6
RR:GL:P:CO.S.6 { @ Recommended to put contacts at both source side and butted well pickup.
  BUTT_SOUR = SD INTERACT (BUTT_PSTP OR BUTT_NSTP)
  (BUTT_PSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_NSTP INTERACT COS6_OD ) NOT INTERACT COi
  (BUTT_SOUR INTERACT COS6_OD ) NOT INTERACT COi
}
#ENDIF // _COS6_

#IFDEF _COR5_
COR5_COCellIn = INSIDE CELL COi CellsForRRuleGuideline  
COR5_COCellOut = NOT INSIDE CELL COi ExclCellsForRRuleGuideline 
COR5_COCell =  COR5_COCellIn AND COR5_COCellOut
COR5_COMarker = COi AND RRuleGuideline
COR5_CO = ((( COR5_COCell OR COR5_COMarker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// CO.R.5g is checked by RR:GL:FDP:CO.R.5
RR:GL:FDP:CO.R.5 { @ Recommended to use redundant CO to avoid high Rc whenever layout allows.
  ((FPO1 AND M1) INTERACT COR5_CO == 1) AND COR5_CO
  ((SD AND M1) INTERACT COR5_CO == 1) AND COR5_CO
  ((DSTP AND M1) INTERACT COR5_CO == 1) AND COR5_CO
}
#ENDIF // _COR5_

#IFDEF _VIA1R9_
VIA1R9_VIA1CellIn = INSIDE CELL VIA1i CellsForRRuleGuideline  
VIA1R9_VIA1CellOut = NOT INSIDE CELL VIA1i ExclCellsForRRuleGuideline 
VIA1R9_VIA1Cell =  VIA1R9_VIA1CellIn AND VIA1R9_VIA1CellOut
VIA1R9_VIA1Marker = VIA1i AND RRuleGuideline
VIA1R9_VIA1 = ((( VIA1R9_VIA1Cell OR VIA1R9_VIA1Marker ) NOT INSIDE SRAM_EXCLUDE ) OUTSIDE Block) NOT excludeRRuleGuideline

// VIA1.R.9g is checked by RR:GL:FDP:VIA1.R.9
RR:GL:FDP:VIA1.R.9 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M1 AND M2) INTERACT VIA1R9_VIA1 == 1) AND VIA1R9_VIA1 
}
#ENDIF


#IFDEF _VIA2R9_
VIA2R9_VIA2CellIn = INSIDE CELL VIA2i CellsForRRuleGuideline  
VIA2R9_VIA2CellOut = NOT INSIDE CELL VIA2i ExclCellsForRRuleGuideline 
VIA2R9_VIA2Cell =  VIA2R9_VIA2CellIn AND VIA2R9_VIA2CellOut
VIA2R9_VIA2Marker = VIA2i AND RRuleGuideline
VIA2R9_VIA2 = ((VIA2R9_VIA2Cell OR VIA2R9_VIA2Marker) NOT Block ) NOT excludeRRuleGuideline

// VIA2.R.9g is checked by RR:GL:FDP:VIA2.R.9
RR:GL:FDP:VIA2.R.9 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M2 AND M3) INTERACT VIA2R9_VIA2 == 1) AND VIA2R9_VIA2 
}
#ENDIF
#IFDEF _VIA3R9_
VIA3R9_VIA3CellIn = INSIDE CELL VIA3i CellsForRRuleGuideline  
VIA3R9_VIA3CellOut = NOT INSIDE CELL VIA3i ExclCellsForRRuleGuideline 
VIA3R9_VIA3Cell =  VIA3R9_VIA3CellIn AND VIA3R9_VIA3CellOut
VIA3R9_VIA3Marker = VIA3i AND RRuleGuideline
VIA3R9_VIA3 = ((VIA3R9_VIA3Cell OR VIA3R9_VIA3Marker) NOT Block ) NOT excludeRRuleGuideline

// VIA3.R.9g is checked by RR:GL:FDP:VIA3.R.9
RR:GL:FDP:VIA3.R.9 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M3 AND M4) INTERACT VIA3R9_VIA3 == 1) AND VIA3R9_VIA3 
}
#ENDIF
#IFDEF _VIA4R9_
VIA4R9_VIA4CellIn = INSIDE CELL VIA4i CellsForRRuleGuideline  
VIA4R9_VIA4CellOut = NOT INSIDE CELL VIA4i ExclCellsForRRuleGuideline 
VIA4R9_VIA4Cell =  VIA4R9_VIA4CellIn AND VIA4R9_VIA4CellOut
VIA4R9_VIA4Marker = VIA4i AND RRuleGuideline
VIA4R9_VIA4 = ((VIA4R9_VIA4Cell OR VIA4R9_VIA4Marker) NOT Block ) NOT excludeRRuleGuideline

// VIA4.R.9g is checked by RR:GL:FDP:VIA4.R.9
RR:GL:FDP:VIA4.R.9 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M4 AND M5) INTERACT VIA4R9_VIA4 == 1) AND VIA4R9_VIA4 
}
#ENDIF
#IFDEF _VIA5R9_
VIA5R9_VIA5CellIn = INSIDE CELL VIA5i CellsForRRuleGuideline  
VIA5R9_VIA5CellOut = NOT INSIDE CELL VIA5i ExclCellsForRRuleGuideline 
VIA5R9_VIA5Cell =  VIA5R9_VIA5CellIn AND VIA5R9_VIA5CellOut
VIA5R9_VIA5Marker = VIA5i AND RRuleGuideline
VIA5R9_VIA5 = ((VIA5R9_VIA5Cell OR VIA5R9_VIA5Marker) NOT Block ) NOT excludeRRuleGuideline

// VIA5.R.9g is checked by RR:GL:FDP:VIA5.R.9
RR:GL:FDP:VIA5.R.9 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M5 AND M6) INTERACT VIA5R9_VIA5 == 1) AND VIA5R9_VIA5 
}
#ENDIF
#IFDEF _VIA6R9_
VIA6R9_VIA6CellIn = INSIDE CELL VIA6i CellsForRRuleGuideline  
VIA6R9_VIA6CellOut = NOT INSIDE CELL VIA6i ExclCellsForRRuleGuideline 
VIA6R9_VIA6Cell =  VIA6R9_VIA6CellIn AND VIA6R9_VIA6CellOut
VIA6R9_VIA6Marker = VIA6i AND RRuleGuideline
VIA6R9_VIA6 = ((VIA6R9_VIA6Cell OR VIA6R9_VIA6Marker) NOT Block ) NOT excludeRRuleGuideline

// VIA6.R.9g is checked by RR:GL:FDP:VIA6.R.9
RR:GL:FDP:VIA6.R.9 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M6 AND M7) INTERACT VIA6R9_VIA6 == 1) AND VIA6R9_VIA6 
}
#ENDIF
#IFDEF _VIA7R5_
VIA7R5_VIA7CellIn = INSIDE CELL VIA7i CellsForRRuleGuideline  
VIA7R5_VIA7CellOut = NOT INSIDE CELL VIA7i ExclCellsForRRuleGuideline 
VIA7R5_VIA7Cell =  VIA7R5_VIA7CellIn AND VIA7R5_VIA7CellOut
VIA7R5_VIA7Marker = VIA7i AND RRuleGuideline
VIA7R5_VIA7 = ((VIA7R5_VIA7Cell OR VIA7R5_VIA7Marker) NOT Block ) NOT excludeRRuleGuideline

// VIA7.R.5g is checked by RR:GL:FDP:VIA7.R.5
RR:GL:FDP:VIA7.R.5 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M7 AND M8) INTERACT VIA7R5_VIA7 == 1) AND VIA7R5_VIA7
}
#ENDIF
#IFDEF _VIA8R5_
VIA8R5_VIA8CellIn = INSIDE CELL VIA8i CellsForRRuleGuideline  
VIA8R5_VIA8CellOut = NOT INSIDE CELL VIA8i ExclCellsForRRuleGuideline 
VIA8R5_VIA8Cell =  VIA8R5_VIA8CellIn AND VIA8R5_VIA8CellOut
VIA8R5_VIA8Marker = VIA8i AND RRuleGuideline
VIA8R5_VIA8 = ((VIA8R5_VIA8Cell OR VIA8R5_VIA8Marker) NOT Block ) NOT excludeRRuleGuideline

// VIA8.R.5g is checked by RR:GL:FDP:VIA8.R.5
RR:GL:FDP:VIA8.R.5 { @ Recommended to use redundant VIAs to avoid high Rc whenever layout allows.
  ((M8 AND M9) INTERACT VIA8R5_VIA8 == 1) AND VIA8R5_VIA8
}
#ENDIF



#ENDIF
#ENDIF  //DFM
